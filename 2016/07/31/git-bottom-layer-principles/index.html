<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/Blog/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/Blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/Blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/Blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/Blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="git," />










<meta name="description" content="从根本上来讲 Git 是一套内容寻址 (content-addressable) 文件系统，在此之上提供了一个 VCS(版本控制) 用户界面。 底层命令 (Plumbing) 和高层命令 (Porcelain)Plimbing命令：底层命令。用于以 UNIX 风格使用或由脚本调用。其他的更友好的命令则被称为 porcelain 命令（高层命令）。 我们一般使用的 Git 命令 checkout b">
<meta name="keywords" content="git">
<meta property="og:type" content="article">
<meta property="og:title" content="git 的内部原理">
<meta property="og:url" content="http://Guoxs.github.io/Blog/2016/07/31/git-bottom-layer-principles/index.html">
<meta property="og:site_name" content="Guoxs&#39;s Blog">
<meta property="og:description" content="从根本上来讲 Git 是一套内容寻址 (content-addressable) 文件系统，在此之上提供了一个 VCS(版本控制) 用户界面。 底层命令 (Plumbing) 和高层命令 (Porcelain)Plimbing命令：底层命令。用于以 UNIX 风格使用或由脚本调用。其他的更友好的命令则被称为 porcelain 命令（高层命令）。 我们一般使用的 Git 命令 checkout b">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://git.oschina.net/progit/figures/18333fig0901-tn.png">
<meta property="og:image" content="http://git.oschina.net/progit/figures/18333fig0902-tn.png">
<meta property="og:image" content="http://git.oschina.net/progit/figures/18333fig0903-tn.png">
<meta property="og:image" content="http://git.oschina.net/progit/figures/18333fig0904-tn.png">
<meta property="og:updated_time" content="2018-01-19T15:14:12.706Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="git 的内部原理">
<meta name="twitter:description" content="从根本上来讲 Git 是一套内容寻址 (content-addressable) 文件系统，在此之上提供了一个 VCS(版本控制) 用户界面。 底层命令 (Plumbing) 和高层命令 (Porcelain)Plimbing命令：底层命令。用于以 UNIX 风格使用或由脚本调用。其他的更友好的命令则被称为 porcelain 命令（高层命令）。 我们一般使用的 Git 命令 checkout b">
<meta name="twitter:image" content="http://git.oschina.net/progit/figures/18333fig0901-tn.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/Blog/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://Guoxs.github.io/Blog/2016/07/31/git-bottom-layer-principles/"/>





  <title>git 的内部原理 | Guoxs's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/Blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Guoxs's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/Blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/Blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/Blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/Blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/Blog/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Guoxs.github.io/Blog/Blog/2016/07/31/git-bottom-layer-principles/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Guoxs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guoxs's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">git 的内部原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-31T20:01:08+08:00">
                2016-07-31
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/Blog/2016/07/31/git-bottom-layer-principles/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/07/31/git-bottom-layer-principles/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p>从根本上来讲 Git 是一套<strong>内容寻址</strong> (content-addressable) 文件系统，在此之上提供了一个 VCS(版本控制) 用户界面。</p>
<h2 id="底层命令-Plumbing-和高层命令-Porcelain"><a href="#底层命令-Plumbing-和高层命令-Porcelain" class="headerlink" title="底层命令 (Plumbing) 和高层命令 (Porcelain)"></a>底层命令 (Plumbing) 和高层命令 (Porcelain)</h2><p><code>Plimbing命令</code>：底层命令。用于以 UNIX 风格使用或由脚本调用。<br>其他的更友好的命令则被称为 <code>porcelain</code> 命令（高层命令）。</p>
<p>我们一般使用的 Git 命令 <code>checkout</code> <code>branch</code> <code>remote</code> 为 procelain 命令。<br><a id="more"></a><br>每一个 git 仓库都有一个 .git 目录，全新的 .git 目录的文件有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HEAD            #指向当前分支</span><br><span class="line">branches/       #老版本有，新版本不再使用</span><br><span class="line">config          #包含了项目特有的配置选项</span><br><span class="line">description     #仅供 GitWeb 程序使用</span><br><span class="line">hooks/          #保存了客户端或服务端钩子脚本</span><br><span class="line">index           #保存了暂存区域信息</span><br><span class="line">info/           #保存了一份不希望在 .gitignore 文件中管理的忽略模式 (ignored patterns) 的全局可执行文件</span><br><span class="line">objects/        #存储所有数据内容</span><br><span class="line">refs/           #存储指向数据 (分支) 的提交对象的指针</span><br></pre></td></tr></table></figure></p>
<h2 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h2><p>git 从核心来看只是简单的存储<strong>键值对</strong>（key-value）。它允许插入任意类型的内容，并会返回一个键值，通过该键值可以在任何时候再取出该内容。<br>通过底层的<code>hash-object</code> 可以演示该过程，传一些数据给该命令，它会将数据保存在 <code>.git</code> 目录并返回表示这些数据的键值。</p>
<p>Git 初始化了 <code>objects</code>目录，同时在该目录下创建了 <code>pack</code> 和 <code>info</code> 子目录，但是该目录下没有其他常规文件。<br>可以通过以下命令往 Git 数据库中写入内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;test content&apos; | git hash-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure></p>
<p>参数<code>-w</code>指示<code>hash-object</code>命令存储 (数据) 对象，若不指定这个参数该命令仅仅返回键值；<br><code>--stdin</code> 指定从标准输入设备 (stdin) 来读取内容，若不指定这个参数则需指定一个要存储的文件的路径。<br>该命令输出长度为 40 个字符的校验和。这是个 SHA-1 哈希值──其值为要存储的数据加上一种头信息的校验和。</p>
<p>查看到 Git 已经存储了数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure></p>
<p>可以看到，Git 存储数据内容的方式是： 为每份内容生成一个文件，取得该内容与头信息的 SHA-1 校验和，创建以该校验和<strong>前两个字符</strong>为名称的子目录，并以 (校验和) 剩下 38 个字符为文件命名 (保存至子目录下)。</p>
<p>通过 <code>cat-file</code> 命令可以将数据内容取回。。传入 -p 参数可以让该命令输出数据内容的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">test content</span><br></pre></td></tr></table></figure></p>
<p>也可以直接添加文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;version 1&apos; &gt; test.txt</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line"></span><br><span class="line">$ echo &apos;version 2&apos; &gt; test.txt               #写入新内容再次保存</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a    #可以发现SHA1码变了</span><br><span class="line"></span><br><span class="line">$ find .git/objects -type f                 #查看现在的objects内容</span><br><span class="line">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line"></span><br><span class="line">#将文件恢复到第一版本</span><br><span class="line">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt</span><br><span class="line">$ cat test.txt</span><br><span class="line">version 1</span><br></pre></td></tr></table></figure></p>
<h3 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h3><blockquote>
<p>Git 存储文件的形式：<br>所有内容以 <code>tree</code> 或 <code>blob</code> 对象存储，其中 <code>tree</code> 对象对应于 UNIX 中的目录，<code>blob</code> 对象则大致对应于 <code>inodes</code> 或文件内容。一个单独的 <code>tree</code> 对象包含一条或多条 <code>tree</code> 记录，每一条记录含有一个指向 <code>blob</code> 或子 <code>tree</code> 对象的 <code>SHA-1</code> 指针，并附有该对象的权限模式 (mode)、类型和文件名信息。</p>
</blockquote>
<p>树对象示意图：<br><img src="http://git.oschina.net/progit/figures/18333fig0901-tn.png" alt="树对象"></p>
<p><strong>可以自己创建树对象：</strong></p>
<pre><code>通常 Git 根据你的暂存区域或 index 来创建并写入一个 tree 。因此要创建一个 tree 对象的话首先要通过将一些文件暂存从而创建一个 index 。可以使用 plumbing 命令 update-index 为一个单独文件创建一个 index　。通过该命令人为的将文件的首个版本加入到了一个新的暂存区域中。由于该文件原先并不在暂存区域中 (甚至就连暂存区域也还没被创建出来) ，必须传入 --add 参数;由于要添加的文件并不在当前目录下而是在数据库中，必须传入 --cacheinfo 参数。同时指定了文件模式，SHA-1 值和文件名：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git update-index --add --cacheinfo 100644 \</span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30 test.txt</span><br></pre></td></tr></table></figure>
<p><code>100644</code> : 表明为普通文件<br><code>100755</code> : 可执行文件<br><code>120000</code> : 符号链接<br>这三种模式仅对 Git 中的 blob 有效。</p>
<p>现在可以用 <code>write-tree</code> 命令将暂存区域的内容写到一个 tree 对象了。无需 <code>-w</code> 参数 ── 如果目标 tree 不存在，调用 write-tree 会自动根据 index 状态创建一个 tree 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> $ git write-tree</span><br><span class="line">    d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">    100644 blob 83baae61804e65cc73a7201a7252750c76066a30 test.txt</span><br><span class="line">    </span><br><span class="line">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579      #验证是否为tree对象</span><br><span class="line">    tree</span><br><span class="line">    </span><br><span class="line">#创建一个新文件与新tree对象</span><br><span class="line">$ echo &apos;new file&apos; &gt; new.txt</span><br><span class="line">$ git update-index test.txt</span><br><span class="line">$ git update-index --add new.txt</span><br><span class="line"></span><br><span class="line">#创建该 tree 对象</span><br><span class="line">$ git write-tree</span><br><span class="line">    0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">    100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt</span><br><span class="line">    100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span><br><span class="line"></span><br><span class="line">#将一个已有的 tree 对象作为一个子 tree 读到暂存区域中</span><br><span class="line">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">$ git write-tree</span><br><span class="line">    3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">    040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579 bak</span><br><span class="line">    100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt</span><br><span class="line">    100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span><br></pre></td></tr></table></figure>
<p> 此时 tree 对象示意图：<br> <img src="http://git.oschina.net/progit/figures/18333fig0902-tn.png" alt="tree"></p>
<h3 id="commit-对象"><a href="#commit-对象" class="headerlink" title="commit 对象"></a>commit 对象</h3><p>commit 对象保存了“关于谁、何时以及为何保存了这些快照”的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#创建 commit 对象</span><br><span class="line">$ echo &apos;first commit&apos; | git commit-tree d8329f</span><br><span class="line">    fdf4fc3344e67ab068f836878b6c4951e3b15f3d</span><br><span class="line">    </span><br><span class="line">#查看 commit 对象</span><br><span class="line">$ git cat-file -p fdf4fc3</span><br><span class="line">    tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">    author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700</span><br><span class="line">    committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line">/*</span><br><span class="line">commit 对象有格式很简单：指明了该时间点项目快照的顶层树对象、作者/提交者信息（从 Git 设置的 user.name 和 user.email中获得)以及当前时间戳、一个空行，以及提交注释信息。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#查看 git 历史</span><br><span class="line">$ git log --stat 1a410e</span><br><span class="line">     commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d</span><br><span class="line">    Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">    Date: Fri May 22 18:09:34 2009 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line">    test.txt | 1 +</span><br><span class="line">    1 files changed, 1 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure></p>
<p> blob，tree 以及 commit 对象都各自以文件的方式保存在 <code>.git/objects</code> 目录下。</p>
<p> 目前对象示意图：<br> <img src="http://git.oschina.net/progit/figures/18333fig0903-tn.png" alt="对象图"></p>
<h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>当存储数据内容时，同时会有一个文件头被存储起来。 Git 是如何存储对象的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//进入ruby交互模式</span><br><span class="line">$irb</span><br><span class="line">    &gt;&gt; content = &quot;what is up, doc?&quot;</span><br><span class="line">    =&gt; &quot;what is up, doc?&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Git 以对象类型为起始内容构造一个文件头，本例中是一个 blob</span><br><span class="line">然后添加一个空格，接着是数据内容的长度，最后是一个空字节 (null byte)：</span><br><span class="line">*/</span><br><span class="line">    &gt;&gt; header = &quot;blob #&#123;content.length&#125;\0&quot;</span><br><span class="line">    =&gt; &quot;blob 16\000&quot;</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line"> Git 将文件头与原始数据内容拼接起来，并计算拼接后的新内容的 SHA-1 校验和。可以在 Ruby 中使用 require 语句导入 SHA1 digest 库，然后调用 Digest::SHA1.hexdigest() 方法计算字符串的 SHA-1 值：</span><br><span class="line"> */   </span><br><span class="line">    &gt;&gt; store = header + content</span><br><span class="line">    =&gt; &quot;blob 16\000what is up, doc?&quot;</span><br><span class="line">    &gt;&gt; require &apos;digest/sha1&apos;</span><br><span class="line">    =&gt; true</span><br><span class="line">    &gt;&gt; sha1 = Digest::SHA1.hexdigest(store)</span><br><span class="line">    =&gt; &quot;bd9dbf5aae1a3862dd1526723246b20206e5fc37&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Git 用 zlib 对数据内容进行压缩，在 Ruby 中可以用 zlib 库来实现。首先需要导入该库，然后用 Zlib::Deflate.deflate() 对数据进行压缩：</span><br><span class="line">*/</span><br><span class="line">    &gt;&gt; require &apos;zlib&apos;</span><br><span class="line">    =&gt; true</span><br><span class="line">    &gt;&gt; zlib_content = Zlib::Deflate.deflate(store)</span><br><span class="line">    =&gt; &quot;x\234K\312\311OR04c(\317H,Q\310,V(-\320QH\311O\266\a\000_\034\a\235&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">最后将用 zlib 压缩后的内容写入磁盘。需要指定保存对象的路径 (SHA-1 值的头两个字符作为子目录名称，剩余 38 个字符作为文件名保存至该子目录中)。在 Ruby 中，如果子目录不存在可以用 FileUtils.mkdir_p() 函数创建它。接着用 File.open 方法打开文件，并用 write() 方法将之前压缩的内容写入该文件：</span><br><span class="line">*/</span><br><span class="line">    &gt;&gt; path = &apos;.git/objects/&apos; + sha1[0,2] + &apos;/&apos; + sha1[2,38]</span><br><span class="line">    =&gt; &quot;.git/objects/bd/9dbf5aa  e1a3862dd1526723246b20206e5fc37&quot;</span><br><span class="line">    &gt;&gt; require &apos;fileutils&apos;</span><br><span class="line">    =&gt; true</span><br><span class="line">    &gt;&gt; FileUtils.mkdir_p(File.dirname(path))</span><br><span class="line">    =&gt; &quot;.git/objects/bd&quot;</span><br><span class="line">    &gt;&gt; File.open(path, &apos;w&apos;) &#123; |f| f.write zlib_content &#125;</span><br><span class="line">    =&gt; 32</span><br></pre></td></tr></table></figure></p>
<p>这就创建了一个正确的 blob 对象。所有的 Git 对象都以这种方式存储，惟一的区别是类型不同 ── 除了字符串 blob   ，文件头起始内容还可以是 commit 或 tree 。不过虽然 blob 几乎可以是任意内容，commit 和 tree 的数据却是有固定格式的。</p>
<h2 id="Git-References"><a href="#Git-References" class="headerlink" title="Git References"></a>Git References</h2><p>使用 SHA1 作为文件的索引是比较难记的，可以用一个简单的名字来记录这些 SHA-1 值。在 Git 中称为“引用”。可以在 <code>.git/refs</code> 目录下面可以找到这些包含 SHA-1 值的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/refs</span><br><span class="line">    .git/refs</span><br><span class="line">    .git/refs/heads</span><br><span class="line">    .git/refs/tags</span><br></pre></td></tr></table></figure></p>
<p>如果想要创建一个新的引用来记住最后一次提交，可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1a410efbd13591db07496601ebc7a059dd55cfe9&quot; &gt; .git/refs/heads/master</span><br></pre></td></tr></table></figure></p>
<p>现在，就可以在 Git 命令中使用刚才创建的引用而不是 SHA-1 值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline master</span><br><span class="line">    1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</span><br><span class="line">    cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">    fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure></p>
<p>基本上 Git 中的一个分支其实就是一个指向某个工作版本一条 HEAD 记录的指针或引用。你可以用这条命令创建一个指向其他提交的分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/heads/test cac0ca</span><br></pre></td></tr></table></figure></p>
<p><code>update-ref</code> 命令可以安全的更新一个引用。<br>现在 Git 数据库看起来是这样：<br> <img src="http://git.oschina.net/progit/figures/18333fig0904-tn.png" alt="Git 数据库"><br>每当执行 <code>git branch</code> (分支名称) 这样的命令，Git 基本上就是执行 <code>update-ref</code> 命令，把现在所在分支中最后一次提交的 SHA-1 值，添加到要创建的分支的引用。</p>
<h3 id="HEAD-标记"><a href="#HEAD-标记" class="headerlink" title="HEAD 标记"></a>HEAD 标记</h3><p>HEAD 文件是一个指向你当前所在分支的引用标识符。这样的引用标识符其实并不包含 SHA-1 值，而是一个指向另外一个引用的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line">    ref: refs/heads/master</span><br></pre></td></tr></table></figure></p>
<p>如果执行 <code>git checkout test</code>，HEAD 文件也会改变为 <code>ref: refs/heads/test</code><br>当再次执行 <code>git commit</code> 的时候，会创建了一个 commit 对象，把这个 commit 对象的父级设置为 HEAD 指向的引用的 SHA-1 值。</p>
<p>HEAD 文件安全修改命令： <code>symbolic-ref</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git symbolic-ref HEAD refs/heads/test</span><br><span class="line">$ cat .git/HEAD</span><br><span class="line">    ref: refs/heads/test</span><br></pre></td></tr></table></figure></p>
<h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><p>Tag 对象非常像一个 commit 对象——包含一个标签，一组数据，一个消息和一个指针。最主要的区别就是 <strong>Tag 对象指向一个 commit 而不是一个 tree</strong>。它就像是一个分支引用，但是不会变化——永远指向同一个 commit，仅仅是提供一个更加友好的名字。</p>
<p>可以类似下面这样的命令建立一个 lightweight tag：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</span><br></pre></td></tr></table></figure></p>
<p>如果创建一个 annotated tag，Git 会创建一个 tag 对象，然后写入一个指向它而不是直接指向 commit 的 reference。可以这样创建一个 annotated tag（-a 参数表明这是一个 annotated tag）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m &apos;test tag&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="Remotes"><a href="#Remotes" class="headerlink" title="Remotes"></a>Remotes</h3><p>第四种 reference 是 <code>remote reference</code>。如果你添加了一个 remote 然后推送代码过去，Git 会把你最后一次推送到这个 remote 的每个分支的值都记录在 refs/remotes 目录下。例如，你可以添加一个叫做 origin 的 remote 然后把你的 master 分支推送上去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:schacon/simplegit-progit.git</span><br><span class="line">$ git push origin master</span><br><span class="line">    Counting objects: 11, done.</span><br><span class="line">    Compressing objects: 100% (5/5), done.</span><br><span class="line">    Writing objects: 100% (7/7), 716 bytes, done.</span><br><span class="line">    Total 7 (delta 2), reused 4 (delta 1)</span><br><span class="line">    To git@github.com:schacon/simplegit-progit.git</span><br><span class="line">    a11bef0..ca82a6d master -&gt; master</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/remotes/origin/master</span><br><span class="line">    ca82a6dff817ec66f44342007202690a93763949</span><br></pre></td></tr></table></figure></p>
<p>Remote 应用和分支主要区别在于他们是不能被 checkout 的。Git 把他们当作是标记这些了这些分支在服务器上最后状态的一种书签。</p>
<h2 id="Packfiles"><a href="#Packfiles" class="headerlink" title="Packfiles"></a>Packfiles</h2><p>Git 往磁盘保存对象时默认使用的格式叫<strong>松散对象</strong> (loose object) 格式。Git 时不时地将这些对象打包至一个叫 <code>packfile</code> 的二进制文件以节省空间并提高效率。当仓库中有太多的松散对象，或是手工调用 <code>git gc</code> 命令，或推送至远程服务器时，Git 都会这样做。手工调用 <code>git gc</code> 命令让 Git 将库中对象打包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git gc</span><br><span class="line">    Counting objects: 17, done.</span><br><span class="line">    Delta compression using 2 threads.</span><br><span class="line">    Compressing objects: 100% (13/13), done.</span><br><span class="line">    Writing objects: 100% (17/17), done.</span><br><span class="line">    Total 17 (delta 1), reused 10 (delta 0)</span><br><span class="line"></span><br><span class="line">$ find .git/objects -type f</span><br><span class="line">    .git/objects/71/08f7ecb345ee9d0084193f147cdad4d2998293</span><br><span class="line">    .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">    .git/objects/info/packs</span><br><span class="line">    .git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx</span><br><span class="line">    .git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack</span><br></pre></td></tr></table></figure></p>
<p>查看一下 objects 目录，会发现大部分对象都不在了，与此同时在 pack 目录下出现了两个新文件。</p>
<p>仍保留着的几个对象是未被任何 commit 引用的 blob，它们没有添加至任何 commit，所以 Git 认为它们是 <strong>“悬空”</strong> 的，不会将它们打包进 packfile 。</p>
<p>剩下的文件是新创建的 <code>packfile</code> 以及一个索引。<code>packfile</code> 文件包含了刚才从文件系统中移除的所有对象。索引文件包含了 <code>packfile</code> 的<strong>偏移</strong>信息，这样就可以快速定位任意一个指定对象。运行 <code>gc</code> 命令前磁盘上的对象大小约为 <strong>12K</strong> ，而这个新生成的 <code>packfile</code> 仅为 <strong>6K</strong> 大小。通过打包对象减少了一半磁盘使用空间。</p>
<p>这是因为，Git 打包对象时，会查找命名及尺寸相近的文件，并只保存文件不同版本之间的差异内容。<code>git verify-pack</code> 命令用于显示已打包的内容。</p>
<h2 id="the-Refspec"><a href="#the-Refspec" class="headerlink" title="the Refspec"></a>the Refspec</h2><p>对于远程仓库连接的建立，在 <code>.git/config</code> 文件中有这样的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:schacon/simplegit-progit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>Refspec</code> 的格式是一个可选的 <strong>+</strong> 号，接着是 <code>&lt;src&gt;:&lt;dst&gt;</code> 的格式，这里 <code>&lt;src&gt;</code> 是<strong>远端</strong>上的引用格式， <code>&lt;dst&gt;</code> 是将要记录在本地的引用格式。可选的 <strong>+</strong> 号告诉 Git 在即使不能快速演进的情况下，也去强制更新它。</p>
<p>缺省情况下 <code>refspec</code> 会被 <code>git remote add</code> 命令所自动生成， Git 会获取远端上 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code>refs/remotes/origin/</code>。 所以，如果远端上有一个 master 分支，你在本地可以通过下面这种方式来访问它的历史记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log origin/master</span><br><span class="line">$ git log remotes/origin/master</span><br><span class="line"> $ git log refs/remotes/origin/master</span><br></pre></td></tr></table></figure></p>
<p>它们是等价的，因为 Git 把它们都扩展成 <code>refs/remotes/origin/master</code></p>
<p>如果每次只想拉取远程的master分支，则可以修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch = +refs/heads/master:refs/remotes/origin/master</span><br></pre></td></tr></table></figure></p>
<p>如果想一次性获取远程的多个分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:refs/remotes/origin/mymaster \</span><br><span class="line">    topic:refs/remotes/origin/topic</span><br></pre></td></tr></table></figure></p>
<p>也可以修改配置文件(这里不能用通配符)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:schacon/simplegit-progit.git</span><br><span class="line">    fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">    fetch = +refs/heads/experiment:refs/remotes/origin/experiment</span><br></pre></td></tr></table></figure></p>
<h3 id="推送-Refspec"><a href="#推送-Refspec" class="headerlink" title="推送 Refspec"></a>推送 Refspec</h3><p>推送到远程分支，可以这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master:refs/heads/qa/master</span><br></pre></td></tr></table></figure></p>
<p>如果想让 Git 每次运行 git push origin 时都这样自动推送，可以在配置文件中添加 push 值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:schacon/simplegit-progit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">    push = refs/heads/master:refs/heads/qa/master</span><br></pre></td></tr></table></figure></p>
<h3 id="删除引用"><a href="#删除引用" class="headerlink" title="删除引用"></a>删除引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :topic</span><br></pre></td></tr></table></figure>
<p>refspec 的格式是 <src>:<dst>, 通过把 <src> 部分留空的方式，这个意思是是把远程的 topic 分支变成空，也就是删除它。</src></dst></src></p>
<h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><p>Git 可以以两种主要的方式跨越两个仓库传输数据：基于HTTP协议之上，和 file://, ssh://, 和 git:// 等智能传输协议。</p>
<h3 id="哑协议"><a href="#哑协议" class="headerlink" title="哑协议"></a>哑协议</h3><p>基于HTTP之上传输通常被称为哑协议，这是因为它在服务端不需要有针对 Git 特有的代码。这个获取过程仅仅是一系列GET请求，客户端可以假定服务端的Git仓库中的布局。</p>
<p>使用 <code>git clone</code> 做的第1件事情就是获取 <code>info/refs</code> 文件。这个文件是在服务端运行了 <code>update-server-info</code> 所生成的，所以服务端要想使用HTTP传输，必须要开启 <code>post-receive</code> 钩子。</p>
<p>整个过程看起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git clone http://github.com/schacon/simplegit-progit.git</span><br><span class="line">    Initialized empty Git repository in /private/tmp/simplegit-progit/.git/</span><br><span class="line">    got ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">    walk ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">    got 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">    Getting alternates list for http://github.com/schacon/simplegit-progit.git</span><br><span class="line">    Getting pack list for http://github.com/schacon/simplegit-progit.git</span><br><span class="line">    Getting index for pack 816a9b2334da9953e530f27bcac22082a9f5b835</span><br><span class="line">    Getting pack 816a9b2334da9953e530f27bcac22082a9f5b835</span><br><span class="line">    which contains cfda3bf379e4f8dba8717dee55aab78aef7f4daf</span><br><span class="line">    walk 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">    walk a11bef06a3f659402fe7563abf99ad00de2209e6</span><br></pre></td></tr></table></figure></p>
<ul>
<li>获取 <code>info/refs</code> 文件，得到一个远程引用和SHA值得列表</li>
<li>寻找HEAD引用，确定什么应该被检出到工作目录</li>
<li>开始获取对象</li>
<li>使用 zlib 解压缩，去除头部，得到 commit 内容</li>
<li>得到进一步需要获取的对象</li>
<li>抓取树对象，分别从<strong>本仓库/替代仓库/打包文件</strong>中查找</li>
<li>在 commit 对象上继续下一步查找</li>
<li>下载全部完成后， 将 master 分支检出工作目录</li>
</ul>
<h3 id="智能协议"><a href="#智能协议" class="headerlink" title="智能协议"></a>智能协议</h3><p>这些协议在远端都有<strong>Git智能型进程</strong>在服务 － 它可以读出本地数据并计算出客户端所需要的，并生成合适的数据给它，这有两类传输数据的进程：一对用于<strong>上传数据</strong>和一对用于<strong>下载</strong>。</p>
<h4 id="上传数据"><a href="#上传数据" class="headerlink" title="上传数据"></a>上传数据</h4><p>当运行 <code>git push origin master</code>, 并且 origin 被定义为一个使用SSH协议的URL时， Git 会使用 <code>send-pack</code> 进程，它会启动一个基于SSH的连接到服务器。它尝试像这样透过SSH在服务端运行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -x git@github.com &quot;git-receive-pack &apos;schacon/simplegit-progit.git&apos;&quot;</span><br><span class="line">    005bca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status delete-refs</span><br><span class="line">    003e085bb3bcb608e1e84b2432f8ecbe6306e7e7 refs/heads/topic</span><br><span class="line">    0000</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>git-receive-pack</code> 命令会立即对它所拥有的每一个引用响应一行。每一行以4字节的十六进制开始，用于指定整行的长度。</p>
</blockquote>
<p>这里第1行以005b开始，这在十六进制中表示91，意味着第1行有91字节长第1行也包含了服务端的能力列表（这里是 report-status 和 delete-refs）。下一行以003e起始，表示有62字节长，所以需要读剩下的62字节。再下一行是0000开始，表示服务器已完成了引用列表过程。</p>
<p>了解了服务器的状态，<code>send-pack</code> 进程会判断哪些 commit 是它所拥有但服务端没有的。针对每个引用，这次推送都会告诉服务端的 <code>receive-pack</code> 这个信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0085ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6</span><br><span class="line">    refs/heads/master report-status</span><br><span class="line">    00670000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d refs/heads/experiment</span><br><span class="line">    0000</span><br></pre></td></tr></table></figure></p>
<p>这里的全 ‘0’ 的SHA-1值表示之前没有过这个对象 。如果你在删除一个引用，你会看到相反的： 就是右边是全’0’。</p>
<p>Git 针对每个引用发送这样一行信息，就是<strong>旧的SHA值，新的SHA值，和将要更新的引用</strong>的名称。第1行还会包含有客户端的能力。下一步，客户端会发送一个所有那些服务端所没有的对象的一<strong>个打包文件</strong>。最后，服务端以成功(或者失败)来响应：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">000Aunpack ok</span><br></pre></td></tr></table></figure></p>
<h4 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h4><p>下载数据时，客户端启动 <code>fetch-pack</code> 进程，连接至远端的 <code>upload-pack</code> 进程，以协商后续数据传输过程。</p>
<p><code>upload-pack</code> 进程的启动可以有多种方式，可以使用与 <code>receive-pack</code> 相同的透过SSH管道的方式，也可以通过 Git 后台来启动这个进程，它默认监听在9418号端口上。这里 <code>fetch-pack</code> 进程在连接后像这样向后台发送数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">003fgit-upload-pack schacon/simplegit-progit.git\0host=myserver.com\0</span><br></pre></td></tr></table></figure></p>
<p>它也是以<strong>4字节</strong>指定后续字节长度的方式开始，然后是要运行的命令，和一个空字节，然后是服务端的主机名，再跟随一个最后的空字节。 Git 后台进程会检查这个命令是否可以运行，以及那个仓库是否存在，以及是否具有公开权限。如果所有检查都通过了，它会启动这个 <code>upload-pack</code> 进程并将客户端的请求移交给它。</p>
<p>如果透过SSH使用获取功能， <code>fetch-pack</code> 是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -x git@github.com &quot;git-upload-pack &apos;schacon/simplegit-progit.git&apos;&quot;</span><br></pre></td></tr></table></figure></p>
<p>在 fetch-pack 连接之后， upload-pack 都会以这种形式返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0088ca82a6dff817ec66f44342007202690a93763949 HEAD\0multi_ack thin-pack \</span><br><span class="line">    side-band side-band-64k ofs-delta shallow no-progress include-tag</span><br><span class="line">    003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master</span><br><span class="line">    003e085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 refs/heads/topic</span><br><span class="line">    0000</span><br></pre></td></tr></table></figure></p>
<p>这与 <code>receive-pack</code> 响应很类似，但是这里指的能力是不同的。而且它还会<strong>指出HEAD引用</strong>，让客户端可以检查是否是一份克隆。</p>
<p>在这里， <code>fetch-pack</code> 进程检查它自己所拥有的对象和所有它需要的对象，通过发送 “want” 和所需对象的SHA值，发送 “have” 和所有它已拥有的对象的SHA值。在列表完成时，再发送 “done” 通知 upload-pack 进程开始发送所需对象的打包文件。这个过程看起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0054want ca82a6dff817ec66f44342007202690a93763949 ofs-delta</span><br><span class="line">    0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">    0000</span><br><span class="line">    0009done</span><br></pre></td></tr></table></figure></p>
<h2 id="维护及数据恢复"><a href="#维护及数据恢复" class="headerlink" title="维护及数据恢复"></a>维护及数据恢复</h2><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>Git 会不定时地自动运行称为 “auto gc” 的命令。大部分情况下该命令什么都不处理。不过要是存在太多松散对象 (loose object, 不在 packfile 中的对象) 或 packfile，Git 会进行调用 <strong>git gc</strong> 命令。 gc 指垃圾收集 (garbage collect)，此命令会做很多工作：收集所有松散对象并将它们存入 packfile，合并这些 packfile 进一个大的 packfile，然后将不被任何 commit 引用并且已存在一段时间 (数月) 的对象删除。</p>
<p>也可以手动运行 auto gc 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git gc --auto</span><br></pre></td></tr></table></figure></p>
<p>gc 还会将所有引用 (references) 并入一个单独文件。假设仓库中包含以下分支和标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/refs -type f</span><br><span class="line">    .git/refs/heads/experiment</span><br><span class="line">    .git/refs/heads/master</span><br><span class="line">    .git/refs/tags/v1.0</span><br><span class="line">    .git/refs/tags/v1.1</span><br></pre></td></tr></table></figure></p>
<p>这时如果运行 <code>git gc</code>, <code>refs</code> 下的所有文件都会消失。Git 会将这些文件挪到 <code>.git/packed-refs</code> 文件中去以提高效率，该文件是这个样子的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/packed-refs</span><br><span class="line">    # pack-refs with: peeled</span><br><span class="line">    cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment</span><br><span class="line">    ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master</span><br><span class="line">    cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0</span><br><span class="line">    9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1</span><br><span class="line">    ^1a410efbd13591db07496601ebc7a059dd55cfe9</span><br></pre></td></tr></table></figure></p>
<p>当更新一个引用时，Git 不会修改这个文件，而是在 refs/heads 下写入一个新文件。当查找一个引用的 SHA 时，Git 首先在 refs 目录下查找，如果未找到则到 <code>packed-refs</code> 文件中去查找。</p>
<p>上面文件最后以 <code>^</code> 开头的那一行。这表示该行上一行的那个标签是一个 <code>annotated</code> 标签，而该行正是那个标签所指向的 <code>commit</code> 。</p>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>恢复丢失后的 commit ，通常最快捷的办法是使用 <code>git reflog</code> 工具。当我们在一个仓库下 工作时，Git 会在我们每次修改了 <code>HEAD</code> 时悄悄地将改动记录下来。当提交或修改分支时，reflog 就会更新。<code>git update-ref</code> 命令也可以更新 reflog。运行 <code>git reflog</code> 命令可以查看当前的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">    1a410ef HEAD@&#123;0&#125;: 1a410efbd13591db07496601ebc7a059dd55cfe9: updating HEAD</span><br><span class="line">    ab1afef HEAD@&#123;1&#125;: ab1afef80fac8e34258ff41fc1b867c702daa24b: updating HEAD</span><br></pre></td></tr></table></figure></p>
<p>运行 <code>git log -g</code> 会输出 reflog 的正常日志，从而显示更多有用信息。从而找到删除的 commit ，然后新建一个分支指向它。</p>
<p>如果 commit 丢失并没有记录在 reflog 中，还可以使用 <code>git fsck</code> 工具，该工具会检查仓库的数据完整性。如果指定 –ful 选项，该命令显示所有未被其他对象引用 (指向) 的所有对象。</p>
<h3 id="移除对象"><a href="#移除对象" class="headerlink" title="移除对象"></a>移除对象</h3><p>git clone 会将仓库包含的每一个文件的历史版本下载下来，若仓库中有大型文件，这将使得仓库非常大。<br>可以利用 <code>git gc</code> 命令查看文件占用的空间，利用 <code>git count-objects</code> 查看使用多少空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git gc</span><br><span class="line">    Counting objects: 21, done.</span><br><span class="line">    Delta compression using 2 threads.</span><br><span class="line">    Compressing objects: 100% (16/16), done.</span><br><span class="line">    Writing objects: 100% (21/21), done.</span><br><span class="line">    Total 21 (delta 3), reused 15 (delta 1)</span><br></pre></td></tr></table></figure></p>
<p>$ git count-objects -v<br>    count: 4<br>    size: 16<br>    in-pack: 21<br>    packs: 1<br>    size-pack: 2016<br>    prune-packable: 0<br>    garbage: 0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 `git verfity-pack` 识别大对象，对输出的第三列信息即文件大小进行排序，还可以将输出定向到 tail 命令。</span><br></pre></td></tr></table></figure></p>
<p>$ git verify-pack -v .git/objects/pack/pack-3f8c0…bb.idx | sort -k 3 -n | tail -3<br>    e3f094f522629ae358806b17daf78246c27c007b blob 1486 734 4667<br>    05408d195263d853f09dca71d55116663690c27c blob 12908 3478 1189<br>    7a9eb2fba2b1811321254ac360970fc169ba2330 blob 2056716 2056872 5401<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如要删除最底下那个大文件，可以运行 `rev-list`命令。若在此传入 `--objects`选项，它会列出所有 commit SHA 值，blob SHA 值及相应的文件路径。可以这样查看 blob 的文件名：</span><br></pre></td></tr></table></figure></p>
<p>$ git rev-list –objects –all | grep 7a9eb2fb<br>    7a9eb2fba2b1811321254ac360970fc169ba2330 git.tbz2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来要将该文件从历史记录的所有 tree 中移除:</span><br></pre></td></tr></table></figure></p>
<p>$ git log –pretty=oneline –branches – git.tbz2<br>    da3f30d019005479c99eb4c3406225613985a1db oops - removed large tarball<br>    6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 added git tarball<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">必须重写从 6df76 开始的所有 commit 才能将文件从 Git 历史中完全移除。需要用到 `filter-branch` 命令：</span><br></pre></td></tr></table></figure></p>
<p>$ git filter-branch –index-filter \<br>    ‘git rm –cached –ignore-unmatch git.tbz2’ – 6df7640^..<br>    Rewrite 6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 (1/2)rm ‘git.tbz2’<br>    Rewrite da3f30d019005479c99eb4c3406225613985a1db (2/2)<br>    Ref ‘refs/heads/master’ was rewritten<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`--index-filter` 传入一个命令修改暂存区域或索引。使用 `git rm --cached` 来从索引而不是磁盘删除文件，这样能提高速度，也可以使用 `--tree-filter` 达到相同的目的。</span><br><span class="line">在这之后， `.git/refs/original` 添加的一些 refs 中仍有对它的引用，因此需要将这些引用删除并对仓库进行 repack 操作。</span><br></pre></td></tr></table></figure></p>
<p>$ rm -Rf .git/refs/original<br>$ rm -Rf .git/logs/<br>$ git gc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在此看看空间占用：</span><br></pre></td></tr></table></figure></p>
<p>$ git count-objects -v<br>    count: 8<br>    size: 2040<br>    in-pack: 19<br>    packs: 1<br>    size-pack: 7<br>    prune-packable: 0<br>    garbage: 0<br><code>``
repack 后仓库的大小减小到了 7K ，远小于之前的 2MB 。从 size 值可以看出大文件对象还在松散对象中，其实并没有消失，不过再进行推送或复制，这个对象不会再传送出去。如果真的要完全把这个对象删除，可以运行</code>git prune –expire` 命令。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/Blog/tags/git/" rel="tag"># git</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/Blog/2016/07/11/java-OOP-2/" rel="next" title="java 面向对象（二）">
                <i class="fa fa-chevron-left"></i> java 面向对象（二）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/Blog/2016/07/31/java-OOP-3/" rel="prev" title="Java 面向对象（三）">
                Java 面向对象（三） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/Blog/images/avatar.jpg"
                alt="Guoxs" />
            
              <p class="site-author-name" itemprop="name">Guoxs</p>
              <p class="site-description motion-element" itemprop="description">Redefine everything</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/Blog/archives">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/Blog/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Guoxs" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#底层命令-Plumbing-和高层命令-Porcelain"><span class="nav-number">1.</span> <span class="nav-text">底层命令 (Plumbing) 和高层命令 (Porcelain)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-对象"><span class="nav-number">2.</span> <span class="nav-text">Git 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树对象"><span class="nav-number">2.1.</span> <span class="nav-text">树对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#commit-对象"><span class="nav-number">2.2.</span> <span class="nav-text">commit 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象存储"><span class="nav-number">2.3.</span> <span class="nav-text">对象存储</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-References"><span class="nav-number">3.</span> <span class="nav-text">Git References</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HEAD-标记"><span class="nav-number">3.1.</span> <span class="nav-text">HEAD 标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tags"><span class="nav-number">3.2.</span> <span class="nav-text">Tags</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Remotes"><span class="nav-number">3.3.</span> <span class="nav-text">Remotes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Packfiles"><span class="nav-number">4.</span> <span class="nav-text">Packfiles</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#the-Refspec"><span class="nav-number">5.</span> <span class="nav-text">the Refspec</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#推送-Refspec"><span class="nav-number">5.1.</span> <span class="nav-text">推送 Refspec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除引用"><span class="nav-number">5.2.</span> <span class="nav-text">删除引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传输协议"><span class="nav-number">6.</span> <span class="nav-text">传输协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#哑协议"><span class="nav-number">6.1.</span> <span class="nav-text">哑协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#智能协议"><span class="nav-number">6.2.</span> <span class="nav-text">智能协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#上传数据"><span class="nav-number">6.2.1.</span> <span class="nav-text">上传数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#下载数据"><span class="nav-number">6.2.2.</span> <span class="nav-text">下载数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#维护及数据恢复"><span class="nav-number">7.</span> <span class="nav-text">维护及数据恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#维护"><span class="nav-number">7.1.</span> <span class="nav-text">维护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据恢复"><span class="nav-number">7.2.</span> <span class="nav-text">数据恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移除对象"><span class="nav-number">7.3.</span> <span class="nav-text">移除对象</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Guoxs</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/Blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/Blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/Blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/Blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/Blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/Blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/Blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/Blog/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/Blog/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/Blog/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/Blog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/Blog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/Blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://mooyu.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://Guoxs.github.io/Blog/2016/07/31/git-bottom-layer-principles/';
          this.page.identifier = '2016/07/31/git-bottom-layer-principles/';
          this.page.title = 'git 的内部原理';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://mooyu.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
    

  




	





  














  





  

  

  

  
  

  
  


  

  

</body>
</html>
