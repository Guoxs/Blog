<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>实验1：汇编指令编程</title>
    <url>/Blog/2016/06/22/Assembly-programming/</url>
    <content><![CDATA[<h3 id="debug的使用"><a href="#debug的使用" class="headerlink" title="debug的使用"></a>debug的使用</h3><p>Debug是DOS、Windows都提供的实模式（8086方式）程序的调试工具，使用它，可以查看CPU各种寄存器的内容，内存情况可机器码级跟踪程序的运行。</p>
<p>实验中用到的debug功能：</p>
<ul>
<li>-r 查看、改变CPU寄存器的内容</li>
<li>-d 查看内存中的内容</li>
<li>-e 改写内存中的内容</li>
<li>-u 将内存中的机器指令翻译成汇编指令</li>
<li>-t 执行一条机器指令</li>
<li>-a 已汇编指令的格式在内存中写入一条机器指令</li>
</ul>
<blockquote>
<p>注意：windows 7 以后就不提供带有debug的commond工具了，这里实验使用MS-DOS虚拟机完成实验。</p>
</blockquote>
<span id="more"></span>
<p>① 用R查看、改变CPU寄存器的内容</p>
<p><img src="http://static.zybuluo.com/guoxs/9a4p6ax934t80z9etspmgbsb/10.png" alt="用R查看、改变CPU寄存器的内容"></p>
<p>注意CS和IP的值，CS=0CA2，IP = 0100， 也就是说，内存0CA2：0100处的指令为当前CPU要读取执行的指令。下方还可以看到其对应的机器码与汇编指令。</p>
<p>② 用R改变寄存器中的内容</p>
<p><img src="http://static.zybuluo.com/guoxs/dj2gwgty2q74z9kein1egyrb/11.png" alt="用R改变寄存器中的内容"></p>
<p>③ 用D来查看内存中的内容</p>
<p><img src="http://static.zybuluo.com/guoxs/uu336hqn6gibqxwnb7vas22u/12.png" alt="用D来查看内存中的内容"></p>
<p>使用“d 段地址：偏移地址”的格式命令将列出从指定单元开始的128个内存单元的内容。 使用“ f ”表示列出一行。</p>
<p>结果显示中，左边的为内存地址，中间为地址对应的值，右边为该值对应的ASCII码。</p>
<p><img src="http://static.zybuluo.com/guoxs/ecmcub0a1tvxqkkw1yudz2q1/13.png" alt="一些其他查看格式"></p>
<blockquote>
<p>在使用“d 段地址：偏移地址”的格式命令后，接着使用D命令，可列出后续的内容。</p>
</blockquote>
<p>④ 用debug的E来改写内存中的值</p>
<p><img src="http://static.zybuluo.com/guoxs/o9w7qhxew2cwzct74473fm4k/14.png" alt="用debug的E来改写内存中的值"></p>
<p>可以写入数字、字符和字符串，在右边可以看到写入的字符与字符串。</p>
<p>⑤ 用E命令向内存中写入机器码，用U命令查看机器码的含义，用T命令执行内存中的机器码</p>
<p><img src="http://static.zybuluo.com/guoxs/v7o2daoh4paur50a5qrpid0y/15.png" alt="E U"></p>
<p><strong>在执行机器码之前，需要修改CS和IP的值，使其指向当前代码的起始内存位置。</strong></p>
<p><img src="http://static.zybuluo.com/guoxs/sf4b0ejpglqb3wuykag3idnb/16.png" alt="T"></p>
<p>⑥ 用A命令以汇编指令的形式在内存中写入机器指令</p>
<p><img src="http://static.zybuluo.com/guoxs/mhjlgu0ndtai90onmstzv57e/17.png" alt="用A命令以汇编指令的形式在内存中写入机器指令"></p>
<p><img src="http://static.zybuluo.com/guoxs/fknk4hodomzunqf6gwjyrwcf/18.png" alt="执行"></p>
<p>最后，做一个有趣的实验，向内存块B810：0000写入：</p>
<p><img src="http://static.zybuluo.com/guoxs/2ny7437gdklwqgich33lvid5/20.png" alt="做一个有趣的实验"></p>
<p>仔细观察，屏幕上某些地方显示了一些奇怪的字符。这是怎么回事呢？留作大家思考。</p>
]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 操作基础</title>
    <url>/Blog/2016/07/07/Basic-Operation-of-Linux/</url>
    <content><![CDATA[<h2 id="Linux-基础概念"><a href="#Linux-基础概念" class="headerlink" title="Linux 基础概念"></a>Linux 基础概念</h2><p>Linux实际上指的是Linux内核即Linux Kernel，而平时常说常用的Linux，如CentOS、Red Hat、Ubuntu等都是Linux发行版，即Linux Distribution</p>
<p>Linux Kernel + Software + Tools  → Linux Distribution</p>
<p><strong>Linux特点</strong>：免费开源，多任务、多用户，稳定，配置要求低</p>
<span id="more"></span>
<p><strong>常用工具</strong>： </p>
<ul>
<li>VMware</li>
<li><p>Putty</p>
<blockquote>
<p>Putty是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。</p>
</blockquote>
</li>
<li><p>SSH Secure Shell Client </p>
<blockquote>
<p><code>ssh secure shell client</code> 是一个用来替代TELNET、FTP以及R命令的工具包，主要是想解决口令在网上明文传输的问题。SSH是英文 <code>Secure Shell</code> 的简写形式。通过使用SSH，可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。</p>
</blockquote>
</li>
</ul>
<p><strong>几种用户界面</strong><br><strong>CLI:</strong> command-line interface，命令行界面<br><strong>GUI:</strong> Graphical User Interface，图形用户界面<br><strong>TUI:</strong> Text-based User Interface，文本用户界面</p>
<h2 id="Linux文件结构"><a href="#Linux文件结构" class="headerlink" title="Linux文件结构"></a>Linux文件结构</h2><p>Linux文件结构图：<br><img src="http://static.zybuluo.com/guoxs/pntt6qrd0wmsfz9366dx48u1/o_linux%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="Linux文件结构图"></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="/ 目录"></a>/ 目录</h3><p>第一层次结构的根、整个文件系统层次结构的根目录。</p>
<p><strong>/bin/</strong><br>需要在单用户模式可用的必要命令（可执行文件）；面向所有用户，例如：cat、ls、cp，和/usr/bin类似。</p>
<p><strong>/boot/</strong><br>引导程序文件，例如：kernel、initrd；时常是一个单独的分区。</p>
<p><strong>/dev/</strong><br>必要设备， 例如：/dev/null。</p>
<p><strong>/etc/</strong><br>特定主机，系统范围内的配置文件。</p>
<p><strong>/home/</strong><br>用户的家目录，包含保存的文件、个人设置等，一般为单独的分区。</p>
<p><strong>/lib/</strong><br>/bin/ and /sbin/ 中二进制文件必要的库文件。</p>
<p><strong>/media/</strong><br>可移除媒体(如CD-ROM)的挂载点 。</p>
<p><strong>/lost+found</strong><br>在ext3文件系统中，当系统意外崩溃或机器意外关机，会产生一些文件碎片在这里。当系统在开机启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。当系统发生问题。可能会有文件被移动到这个目录中，可能需要用手工的方式来修复，或移到文件到原来的位置上。</p>
<p><strong>/mnt/</strong><br>临时挂载的文件系统。比如cdrom,u盘等，直接插入光驱无法使用，要先挂载后使用。</p>
<p><strong>/opt/</strong><br>可选应用软件包。</p>
<p><strong>/proc/</strong><br>虚拟文件系统，将内核与进程状态归档为文本文件（系统信息都存放这目录下）。例如：uptime、 network。在Linux中，对应Procfs格式挂载。该目录下文件只能看不能改（包括root）。</p>
<p><strong>/root/</strong><br>超级用户的家目录。</p>
<p><strong>/sbin/</strong><br>必要的系统二进制文件，例如： init、 ip、 mount。<strong>sbin目录下的命令，普通用户都执行不</strong>了。</p>
<p><strong>/srv/</strong><br>站点的具体数据，由系统提供。</p>
<p><strong>/tmp/</strong><br>临时文件，<strong>在系统重启时目录中文件不会被保留</strong>。</p>
<p><strong>/usr/</strong><br>默认软件都会存于该目录下。用于存储只读用户数据的第二层次；包含绝大多数的(多)用户工具和应用程序。</p>
<p><strong>/var/</strong><br><strong>变量文件——在正常运行的系统中其内容不断变化的文件</strong>，如日志，脱机文件和临时电子邮件文件。有时是一个单独的分区。如果不单独分区，有可能会把整个分区充满。如果单独分区，给大给小都不合适。</p>
<h3 id="etc-目录"><a href="#etc-目录" class="headerlink" title="/etc/目录"></a>/etc/目录</h3><p><strong>/etc/sysconfig/network</strong><br>IP、掩码、网关、主机名配置。</p>
<p><strong>/etc/resolv.conf</strong><br>DNS服务器配置。</p>
<p><strong>/etc/fstab</strong><br>开机自动挂载系统，所有分区开机都会自动挂载。</p>
<p><strong>/etc/inittab</strong><br>设定系统启动时Init进程将把系统设置成什么样的runlevel及加载相关的启动文件配置。</p>
<p><strong>/etc/exports</strong><br>设置NFS系统用的配置文件路径。</p>
<p><strong>/etc/init.d</strong><br>这个目录来存放系统启动脚本。</p>
<p><strong>/etc/profile</strong>, /etc/csh.login,  /etc/csh.cshrc<br>全局系统环境配置变量</p>
<p><strong>/etc/issue</strong><br>认证前的输出信息，默认输出版本内核信息。</p>
<p><strong>/etc/group</strong><br>类似/etc/passwd ，但说明的不是用户而是组。</p>
<p><strong>/etc/passwd</strong><br>用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息。</p>
<p><strong>/etc/shadow</strong><br>在安装了影子口令软件的系统上的影子口令文件.影子口令文件将 /etc/passwd 文件中的加密口令移动到/etc/shadow 中，而后者只对root可读，这使破译口令更困难。</p>
<p><strong>/etc/sudoers</strong><br>可以sudo命令的配置文件</p>
<p><strong>/etc/syslog.conf</strong><br>系统日志参数配置</p>
<p><strong>/etc/skel/</strong><br>默认创建用户时，把该目录拷贝到家目录下。</p>
<h3 id="usr-目录"><a href="#usr-目录" class="headerlink" title="/usr/目录"></a>/usr/目录</h3><p><strong>/usr/doc</strong><br>Linux技术文档。</p>
<p><strong>/usr/include</strong><br>用来存放Linux下开发和编译应用程序所需要的头文件。</p>
<p><strong>/usr/lib</strong><br>存放一些常用的动态链接共享库和静态档案库。</p>
<p><strong>/usr/man</strong><br>帮助文档所在的目录。</p>
<p><strong>/usr/src</strong><br>Linux开放的源代码，就存在这个目录。</p>
<p><strong>/usr/bin/</strong><br>非必要可执行文件 (在单用户模式中不需要)；面向所有用户。</p>
<p><strong>/usr/local/</strong><br>本地数据的第三层次，具体到本台主机。通常而言有进一步的子目录，例如：bin/、lib/、share/。这是提供给一般用户的/usr目录，在这里安装一般的应用软件。</p>
<h3 id="var-目录"><a href="#var-目录" class="headerlink" title="/var/目录"></a>/var/目录</h3><p><strong>/var/log/message</strong><br>日志信息，按周自动轮询。</p>
<p><strong>/var/spool/cron/root</strong><br>定时器配置文件目录，默认按用户命名。</p>
<p><strong>/var/log/secure</strong><br>记录登陆系统存取信息的文件，不管认证成功还是认证失败都会记录。</p>
<p><strong>/var/log/wtmp</strong><br>记录登陆者信息的文件，last、who、w 命令信息来源于此。</p>
<p><strong>/var/spool/clientmqueue/</strong><br>当邮件服务未开启时，所有应发给系统管理员的邮件都将堆放在此。</p>
<p><strong>/var/spool/mail/</strong><br>邮件目录。</p>
<p><strong>/var/log/</strong><br>各种程序的Log文件，特别是login   (/var/log/wtmp log所有到系统的登录和注销) 和syslog (/var/log/messages 里存储所有核心和系统程序信息）。 /var/log 里的文件经常不确定地增长，应该定期清除。</p>
<p><strong>/var/run</strong><br>保存到下次引导前有效的关于系统的信息文件.例如， /var/run/utmp 包含当前登录的用户的信息.</p>
<p><strong>/var/cache/</strong><br>应用程序缓存数据。这些数据是在本地生成的一个耗时的I/O或计算结果。应用程序必须能够再生或恢复数据。缓存的文件可以被删除而不导致数据丢失。</p>
<h3 id="proc-目录"><a href="#proc-目录" class="headerlink" title="/proc/目录"></a>/proc/目录</h3><p><strong>/proc/meminfo</strong><br>查看内存信息。</p>
<p><strong>/proc/cpuinfo</strong><br>关于处理器的信息，如类型、厂家、型号和性能等。</p>
<p><strong>/proc/cmdline</strong><br>加载 kernel 时所下达的相关参数。查阅此文件，可了解系统是如何启动的。</p>
<p><strong>/proc/filesystems</strong><br>目前系统已经加载的文件系统。</p>
<p><strong>/proc/ioports</strong><br>目前系统上面各个装置所配置的 <strong>I/O 位址</strong>。</p>
<p><strong>/proc/kcore</strong><br>内存的大小。</p>
<p><strong>/proc/modules</strong><br>目前我们的 Linux 已经加载的模块列表，也可以想成是驱动程序。</p>
<p><strong>/proc/mounts</strong><br>系统已经挂载的数据。</p>
<h3 id="dev-目录"><a href="#dev-目录" class="headerlink" title="/dev/目录"></a>/dev/目录</h3><p><strong>/dev/hd[a-t]</strong>  IDE设备</p>
<p><strong>/dev/sd[a-z]</strong>  SCSI设备</p>
<p><strong>/dev/ram[0-15]</strong> 内存</p>
<p><strong>/dev/null</strong> 无限数据接收设备,相当于黑洞</p>
<p><strong>/dev/zero</strong> 无限零资源</p>
<p><strong>/dev/tty[0-63]</strong> 虚拟终端</p>
<p><strong>/dev/ttyS[0-3]</strong> 串口</p>
<p><strong>/dev/lp[0-3]</strong> 并口</p>
<p><strong>/dev/console</strong> 控制台</p>
<h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p>1、<code>man [command]</code> 查看命令帮助。也可以用 <code>command –h</code> 或 <code>–-help</code> 查看简要帮助。查看帮助文件时，按Enter键下翻行，q键退出</p>
<p>2、<code>date</code> 显示时间日期，<code>uptime</code> 显示系统运行时间</p>
<p>3、<code>uname –a</code> 显示内核版本</p>
<p>4、-a = —all， -r -t = -rt</p>
<p>5、TAB 键自动补全，如有多个可补全项，连按TAB可现实是出所有可补全的文件名</p>
<p>6、<code>clear</code> 清屏， Shift + PgUp、PgDn 上下翻屏</p>
<p>7、<code>history</code> 查看历史命令，并可加参数以重复历史命令，<code>history –c</code> 清空历史命令，<code>history [n]</code> 显示最近的n条命令，<code>![n]</code> 执行history中的第n条命令</p>
<h3 id="电源操作"><a href="#电源操作" class="headerlink" title="电源操作"></a>电源操作</h3><p>1、<code>poweroff</code> 关机</p>
<p>2、<code>reboot</code> 重启</p>
<p>3、<code>init</code><br> init 0 关机<br> init 4 安全模式<br> init 6 重启</p>
<h3 id="用户及用户组操作"><a href="#用户及用户组操作" class="headerlink" title="用户及用户组操作"></a>用户及用户组操作</h3><p>1、<code>su [user]</code> 切换用户<br><code>su –</code> 或 <code>su = su root</code></p>
<p>2、<code>sudo [command]</code> 以<strong>root权限</strong>执行命令</p>
<p>3、<code>passwd</code> 修改密码</p>
<p>4、<code>id</code> 显示 uid 和 gid，root的id是0</p>
<p>5、<code>useradd [username]</code> 增加用户</p>
<blockquote>
<p>默认情况下新增用户如果不指定用户组则会新建一个以用户名命名的新用户组</p>
</blockquote>
<p>6、<code>groupadd [groupname]</code> 增加用户组</p>
<p>7、<code>usermod -g [groupname] [username]</code> 修改用户所属组</p>
<p>8、<code>whoami</code>，<code>who，</code>w` 显示用户信息</p>
<p>9、<code>exit</code> 退出登录</p>
<h3 id="文件及目录操作"><a href="#文件及目录操作" class="headerlink" title="文件及目录操作"></a>文件及目录操作</h3><p> 1、<code>~</code>为用户目录（root的就是/root，user的就是/home/user）<br>相对路径：<code>.</code>为当前目录，<code>..</code>为上一级目录，<code>-</code> 为上一目录</p>
<p>2、<code>pwd</code> 显示当前工作目录</p>
<p>3、<code>ls</code> 列出命令</p>
<blockquote>
<p><strong>-a</strong> 列出所有文件（包括文件名以 . 开头的隐藏文件）<br><strong>-R</strong> 显示子目录结构<br><strong>-l</strong> 显示详细信息 = <code>ll</code></p>
</blockquote>
<p>4、<code>cd</code> 切换目录</p>
<p>5、<code>cat</code> 查看文件</p>
<blockquote>
<p><code>tac</code>逆向查看文件</p>
</blockquote>
<p>6、<code>more</code>，<code>less</code> 翻页查看文件 （more只能下翻，less可上可下）</p>
<p>7、<code>head</code> 查看头几行，<code>tail</code> 查看后几行</p>
<blockquote>
<p><code>head +n/-n</code> 表示显示头n行或不显示后n行<br><code>tail +n/-n</code> 表示不显示头n行或显示后n行</p>
</blockquote>
<p>8、<code>touch</code> 更新文件修改时间或新建文件</p>
<blockquote>
<p><strong>-a</strong> 仅修改访问时间<br> <strong>-c</strong> 仅修改时间，如无文件也不新建文件<br> <strong>-m</strong> 仅修改修改时间</p>
<p>Linux 的三个时间参数<br><strong>modification time（mtime）</strong>：文件内容更改的时间，ls默认显示的时间<br><strong>status time（ctime）</strong>：状态更改（权限或属性更改）的时间<br><strong>access time（atime）</strong>：文件内容被取用的时间</p>
</blockquote>
<p>9、<code>mkdir</code> 新建目录，<code>rmdir</code> 删除空目录</p>
<p>10、<code>cp [option] source destination</code> 复制</p>
<blockquote>
<p><strong>-a</strong> 相当于<code>-pdr</code>，常用于备份<br><strong>-i</strong> 交互模式，目标文件已存在时询问是否覆盖<br><strong>-p</strong> 文件属性也复制（默认情况下，目标文件的所有者是cp命令操作者）<br><strong>-d</strong> 若源文件为连接文件，则只复制连接文件<br><strong>-r</strong> 递归复制，用于目录的复制<br><strong>-l</strong> 创建硬连接<br><strong>-s</strong> 创建软连接</p>
</blockquote>
<p>11、<code>mv [option] source destination</code> 移动或重命名</p>
<blockquote>
<p><strong>-f</strong> 强制，直接覆盖<br><strong>-i</strong> 询问是否覆盖<br><strong>-u</strong> 若source比较新才会更新</p>
</blockquote>
<p>12、<code>rm</code> 删除<br> <strong>-f</strong> 强制<br> <strong>-r</strong> 递归<br> <strong>-i</strong> 交互<br>  <strong>rm -rf</strong> 强制删除文件夹</p>
<p>13、<code>file</code> 查看文件类型</p>
<p>14、<code>which</code> 在 <strong>$PATH</strong> 中查找可执行文件</p>
<p>15、<code>whereis</code> 在数据库中查找</p>
<p>16、<code>find [PATH] [option] [action]</code> 高级的查找命令</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><blockquote>
<p><strong>d</strong> 目录<br><strong>-</strong> 文件<br><strong>2</strong> 连接文件（hard link，symbolic link），只记录硬链接数<br><strong>b</strong> 可供存储设备<br><strong>c</strong> 串行端口设备<br><code>file [filename]</code> 查看文件类型</p>
</blockquote>
<p><img src="http://static.zybuluo.com/guoxs/3crpmnmvl82ztl10tf1t8wt4/%E5%9B%BE%E7%89%871.png" alt="文件信息"><br>信息从左到右分别是：<br>文件类型、权限、连接、用户、用户组、大小、修改时间、文件名</p>
<p><strong>hard link 和 symbolic link</strong></p>
<p>硬链接和软连接：<br><img src="http://static.zybuluo.com/guoxs/3k3zvl4evgn2tuar1t2oq80t/111041250301052.png" alt="硬链接和软连接"></p>
<p><strong>硬连接</strong><br>指通过<strong>索引节点</strong>来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号 (<strong>Inode Index</strong>)。在Linux中，多个文件名指向同一索引节点是存在的，一般这种连接就是硬连接。</p>
<p><code>硬连接的作用</code>： 允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。<strong>文件真正删除的条件是与之相关的所有硬连接文件均被删除</strong>。</p>
<p><strong>硬连接的2个限制</strong></p>
<ul>
<li>不允许给目录创建硬链接</li>
<li>只有在同一文件系统中的文件之间才能创建链接。<blockquote>
<p>即不同硬盘分区上的两个文件之间不能够建立硬链接。这是因为硬链接是通过结点指向原始文件的，而文件的<code>i-结点</code>在不同的文件系统中可能会不同。</p>
</blockquote>
</li>
</ul>
<p><strong>软连接</strong></p>
<p>也称为为符号连接（Symbolic）。软链接文件<strong>类似于Windows的快捷方式</strong>。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个<strong>文本文件</strong>，其中包含的有另一文件的位置信息。删除原文件，对硬链接没有影响。</p>
<h2 id="文件权限操作"><a href="#文件权限操作" class="headerlink" title="文件权限操作"></a>文件权限操作</h2><p><strong>UGO模式</strong> <strong>user</strong> <strong>group</strong> <strong>others</strong></p>
<p><strong>a</strong>（all） = u+g+o</p>
<p><strong>rwx</strong>  read write execute ，421，7=4+2+1=rwx</p>
<p> <strong>对于文件</strong>：</p>
<ul>
<li><code>r</code>，可读取文件内容</li>
<li><code>w</code>，可编辑文件内容（不包含删除文件的权限）</li>
<li><p><code>x</code>，可执行</p>
<p><strong>对于目录</strong>：</p>
</li>
<li><p><code>r</code>，可查询目录下文件名数据，即可ls</p>
</li>
<li><code>w</code>，新建、删除、重命名、移动目录内文件</li>
<li><code>x</code>，可进入该目录，即可cd</li>
</ul>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>1、<code>chown user file</code> 改变文件所有者</p>
<p>2、<code>chgrp group file</code> 改变文件用户组</p>
<p>3、<code>chmod</code>改变文件权限</p>
<blockquote>
<p>chmod u/g/o/a +/- r/w/x file<br>chmod mark file  （mark必须用三个数字同时修改，如777）</p>
</blockquote>
<p><strong>默认权限</strong> <code>umask</code><br><code>umask</code> 查看umask，<code>umask mark</code> 设置umask<br> 文件的默认权限为：666 - umask<br> 目录的默认权限为：777 - umask</p>
<h3 id="文件权限操作-1"><a href="#文件权限操作-1" class="headerlink" title="文件权限操作"></a>文件权限操作</h3><p><strong>文件隐藏属性</strong><br>1、<code>chattr +/-/= [option] file</code></p>
<blockquote>
<p><strong>-A</strong> 访问文件将不修改 atime<br><strong>-S</strong> 对该文件修改马上同步到磁盘（异步写入 VS 同步写入）<br><strong>-a</strong> 文件只能增加数据，不能修改和删除数据，只有 root 可设置<br><strong>-c</strong> 压缩文件<br><strong>-d</strong> 该文件不被 dump 备份<br><strong>-i</strong> 完全无法修改，添加删除文件的内容<br><strong>-s</strong> 该文件被删除时，所有数据将一干二净<br><strong>-u</strong> 与 s 相反</p>
</blockquote>
<p>2、<code>lsattr</code> 列出文件的隐藏属性</p>
<p>3、<strong>文件特殊权限</strong> SUID，SGID，SBIT</p>
<ul>
<li><code>SUID</code>，/usr/bin/password，执行者对该程序有x权限，程序执行时，获得程序所有者 owner 的权限，只能作用于二进制程序</li>
<li><code>SGID</code>，类似 SUID，针对 group 设置，可作用于文件或目录</li>
<li><code>SBIT</code>，只作用于目录，用户在目录下创建文件或目录时，只有自己和 root 有权移动删除</li>
</ul>
<blockquote>
<p><strong>特殊权限的设置</strong><br>SUID = 4, SGID = 2, SBIT = 1<br>权限数字前加上特殊权限的数字即可，如chmod 4777 file，在 <code>rwx</code> 中只是把 <code>x</code> 改为 <code>s</code> 。</p>
</blockquote>
<h2 id="vi-vim-编辑器"><a href="#vi-vim-编辑器" class="headerlink" title="vi,vim 编辑器"></a>vi,vim 编辑器</h2><p><code>命令模式</code>，默认进入，任何模式下按 <strong>ESC</strong> 返回命令模式<br> <code>o</code> 在当前行的下面插入新行<br> <code>dd</code> 删除整行<br> <code>yy</code> 将当前行的内容放入缓存区 （复制）<br> <code>n+yy</code> 复制多行<br> <code>p</code> 粘贴<br><code>u</code> 撤销<br> <code>r</code> 替换<br> <code>/</code> 查找关键字<br> <code>i</code> 进入插入 <strong>insert</strong> 模式<br> <code>：</code> 进入<strong>ex模式</strong><br> <code>:w</code> 保存<br> <code>:q</code> 退出<br> <code>:q!</code> 强制退出<br> <code>:x</code> 保存并退出<br> <code>:set number</code> 显示行号<br> <code>：!</code> 系统命令<br> <code>:sh</code> 切换到命令行，<code>ctrl+d</code> 切回</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Compression Algorithm</title>
    <url>/Blog/2016/10/29/Compression-Algorithm/</url>
    <content><![CDATA[<p>本篇学习笔记参考《算法》四版第五章“数据压缩”部分。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="数据压缩模型"><a href="#数据压缩模型" class="headerlink" title="数据压缩模型"></a>数据压缩模型</h3><p>数据压缩的模型可以这样表示：<br><img src="http://static.zybuluo.com/guoxs/005d7cgcybdu84kuf7wy28qr/1.png" alt="模型"><br>模型由两部分组成，压缩盒与展开盒。压缩盒将一个比特流B转化成压缩后的版本C(B)，展开盒能够将C(B)转化回B。<br>若用 |B| 表示比特流中比特的数量，则 μ = |C(B)|/|B| 称为<strong>压缩率</strong>，该值越小，表示压缩算法越高效。<br>这种模型叫做无损压缩模型——保证不丢失任何信息，即压缩和展开之后的比特流必须和原始的比特流完全相同。许多类型的文件都会用到无损压缩，例如数值数据或者可执行代码。<br><span id="more"></span></p>
<h3 id="数据压缩算法的局限性"><a href="#数据压缩算法的局限性" class="headerlink" title="数据压缩算法的局限性"></a>数据压缩算法的局限性</h3><p><strong>① 不存在能够压缩任意比特流的算法。</strong>也就是说通用性的数据压缩是不可能存在的。</p>
<blockquote>
<p>这里可以用反证法来说明：假设存在一个能够压缩任意比特流的算法，那么也就可以用它来压缩它自己的输出以得到一段更短的比特流，循环反复直到比特流长度为0。显然能够将任意比特流的长度压缩至0是不可能的，所以不存在这样的压缩算法。</p>
</blockquote>
<p><strong>② 不可能找到最佳的压缩算法。</strong>也就是说最优数据压缩（找到能够产生给定字符串的最短程序）是一个<strong>不可判定</strong>的问题。</p>
<blockquote>
<p>压缩一个文件最好的办法是找到创建这些数据的程序。我们处理的大多数数据都是由某种程序产生的。</p>
</blockquote>
<p>一个简单的例子，比如下面这张包含100万个伪随机比特的图：<br><img src="http://static.zybuluo.com/guoxs/zboutt5lmdow7inf61bom2zu/12.png" alt="伪随机比特"><br>乍一看要压缩这张图似乎难以进行，但是如果你知道生成这张图的是下面这段代码，那么压缩就易如反掌了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomBits</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">11111</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</span><br><span class="line">            x = x * <span class="number">314159</span> + <span class="number">218281</span>;</span><br><span class="line">            BinaryStdOut.write(x &gt; <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryStdOut.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="游程编码"><a href="#游程编码" class="headerlink" title="游程编码"></a>游程编码</h2><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>比特流中最简单的形式就是一长串重复的比特，比如下面这条40位长的字符串：<br>0000000000000001111111000000011111111111<br>该字符串包含15个0，7个1，然后又7个0，最后是11个1。因此我们可以将该比特字符编码为15，7，7，11。所有字符都是由交替出现的0和1组成，因此我们只需要将游程的长度进行编码就行了。因此我们可以得到一个16字节的字符串（15=1111,7=0111,11=1011）：<br>1111011101111011<br>压缩率 μ = 16/40 = 40%。</p>
<blockquote>
<p>只有游程的长度大于将它们用二进制表示所需的长度时才能节省空间。</p>
</blockquote>
<p>游程编码还可以用于位图的压缩。如下图所示，一个字符 “q” ，每行的右侧是该行的游程编码，因为每行的开始于结束都是0，所以每行的游程数量都是奇数。因为每一行的结束之后就是另一行的开始，所以比特流中相对应的游程长度就是每一行的最后一个游程长度和下一行的第一个游程长度之和。<br><img src="http://static.zybuluo.com/guoxs/ijiu6vkvp9aulf8tejhw0oal/2.png" alt="q"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (!BinaryStdIn.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">char</span> cnt = BinaryStdIn.readChar();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">			BinaryStdOut.write(b);</span><br><span class="line">		b = !b;</span><br><span class="line">	&#125;</span><br><span class="line">	BinaryStdOut.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> b, old = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!BinaryStdIn.isEmpty())&#123;</span><br><span class="line">        b = BinaryStdIn.readBoolean();</span><br><span class="line">        <span class="keyword">if</span> (b != old)&#123;</span><br><span class="line">            BinaryStdOut.write(cnt);</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            old = !old;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">255</span>)&#123;</span><br><span class="line">                BinaryStdOut.write(cnt);</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                BinaryStdOut.write(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    BinaryStdOut.write(cnt);</span><br><span class="line">    BinaryStdOut.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>expand()</strong>实现相对简单：读取一个游程的长度，将当前比特按照长度复制并打印，装换当前比特后继续，直到输入结束；<br>对于<strong>compress()</strong>方法，流程是这样的：</p>
<blockquote>
<p>1、读取一个比特；<br>2、如果它和上一个比特不同，写入当前的计数值并将计数器归零；<br>3、如果它与上一个比特相同且计数器已经达到最大值，则写入计数值，再写入一个0计数值，然后将计数器归零；<br>4、增加计数器的值；<br>当输入流结束后，写入计数值（最后一个游程的长度）并结束。</p>
</blockquote>
<p> 游程编码在很多场景中非常有效，但是在许多情况下我们希望压缩的比特流并不含有较长的游程（例如典型的英文文档），这时我们需要用到另外的压缩算法。</p>
<h2 id="霍夫曼压缩"><a href="#霍夫曼压缩" class="headerlink" title="霍夫曼压缩"></a>霍夫曼压缩</h2><h3 id="前缀码"><a href="#前缀码" class="headerlink" title="前缀码"></a>前缀码</h3><p>霍夫曼压缩算法是一种能够大幅压缩自然语言文件空间（以及许多其他类型文件）的数据压缩技术，它的主要思想就是放弃文本文件的普遍保存方式，不再使用7位或者8位二进制数表示每一个字符，而是用较少的比特表示出现频率高的字符，用较多的比特表示出现频率低的字符。</p>
<p>为了避免编码的二义性，引入了<strong>前缀码</strong>的概念，所谓的前缀码，就是所有字符编码都不会成为其他字符编码的前缀，这样的话就不需要使用分隔符来区分每一个字符编码。</p>
<p>表示前缀码的一种简便方法就是使用单词查找树。下图是字符串 BRACADABRA! 中字符的两种前缀编码方式。<br><img src="http://static.zybuluo.com/guoxs/dathtd77mhd5huweluptmehy/3.png" alt="单词查找树"><br>对于同一段字符串可以有很多种不同的前缀码编码，如何找到最优的前缀码呢？霍夫曼找到了这种通用方法，因此这种编码方式被称为霍夫曼编码。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>使用前缀码进行数据压缩需要经过5个主要步骤：</p>
<blockquote>
<p>1、构造一棵编码单词查找树；<br>2、将该树以字节流的形式写入输出以供展开使用；<br>3、使用该树将字节流编码为比特流。</p>
</blockquote>
<p>在展开式需要：</p>
<blockquote>
<p>1、读取比特流开头的单词查找树；<br>2、使用该树将比特流解码。</p>
</blockquote>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p><strong>单词查找树节点表示：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">// Huffman trie node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> ch; <span class="comment">// unused for internal nodes</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> freq; <span class="comment">// unused for expand</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node left, right;</span><br><span class="line">    </span><br><span class="line">    Node(<span class="keyword">char</span> ch, <span class="keyword">int</span> freq, Node left, Node right)&#123;</span><br><span class="line">        <span class="keyword">this</span>.ch = ch;</span><br><span class="line">        <span class="keyword">this</span>.freq = freq;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node that)</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.freq - that.freq; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>expend()代码：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node root = readTrie(); <span class="comment">//读取单词查找树</span></span><br><span class="line">    <span class="keyword">int</span> N = BinaryStdIn.readInt();  <span class="comment">//读取编码字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++&#125;&#123;</span><br><span class="line">        Node x = root;  <span class="comment">//从树根节点开始</span></span><br><span class="line">        <span class="keyword">while</span> (!x.isLeaf())&#123;</span><br><span class="line">            <span class="keyword">if</span> (BinaryStdIn.readBoolean())&#123;</span><br><span class="line">                 x = x.right;   <span class="comment">//1则往右子数查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x = x.left;    <span class="comment">//0则往左子数查找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryStdOut.write(x.ch);   <span class="comment">//输出编码对应字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    BinaryStdOut.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>压缩</strong>时，使用单词查找树定义的编码来构造编译表。编译表就是一张将每个字符和它的比特字符串相关联的符号表。以下代码使用一个字符索引数组st[]作为符号表，在构造该符号表时，buildCode()递归遍历整棵树并为每个节点维护了一条从根节点到它的路径所对应的二进制字符串（0代表左链接，1代表右链接），每当到达一个叶子节点时，算法就将节点的编码设为该二进制字符串。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] buildCode(Node root)&#123; </span><br><span class="line">    <span class="comment">// 使用单词查找树构造编译表</span></span><br><span class="line">    String[] st = <span class="keyword">new</span> String[R];</span><br><span class="line">    buildCode(st, root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildCode</span><span class="params">(String[] st, Node x, String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.isLeaf())&#123; st[x.ch] = s; <span class="keyword">return</span>; &#125;</span><br><span class="line">    buildCode(st, x.left, s + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    buildCode(st, x.right, s + <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用编译表压缩</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length; i++)&#123;</span><br><span class="line">    String code = st[input[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; code.length(); j++)</span><br><span class="line">    <span class="keyword">if</span> (code.charAt(j) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    BinaryStdOut.write(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">else</span> BinaryStdOut.write(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>单词查找树的构造</strong><br>构造单词查找树是一个构造最小生成树的过程。以以下字符串为例：</p>
<blockquote>
<p>it was the best of times it was the worst of times</p>
</blockquote>
<p>我们在每个结点中维护一个变量freq表示该字符出现的频率（要得到freq值，需要完整读取输出流一次）。构造的第一步就是创建一片由许多只有一个结点的树组成的森林，然后自底向上根据频率构造这棵单词查找树。构造过程如下：首先取得freq值最小的两棵树，然后创建以这两棵树为子结点的新结点，该结点freq值为其两个子结点之和，反复重复这个过程，最终只剩下一颗树，就是我们要的单词查找树。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildTrie</span><span class="params">(<span class="keyword">int</span>[] freq)</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用多棵单节点树初始化优先队列</span></span><br><span class="line">    MinPQ&lt;Node&gt; pq = <span class="keyword">new</span> MinPQ&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">        <span class="keyword">if</span> (freq[c] &gt; <span class="number">0</span>)</span><br><span class="line">            pq.insert(<span class="keyword">new</span> Node(c, freq[c], <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>)&#123; </span><br><span class="line">        <span class="comment">// 合并两棵频率最小的树</span></span><br><span class="line">        Node x = pq.delMin();</span><br><span class="line">        Node y = pq.delMin();</span><br><span class="line">        Node parent = <span class="keyword">new</span> Node(<span class="string">&#x27;\0&#x27;</span>, x.freq + y.freq, x, y);</span><br><span class="line">        pq.insert(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.delMin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>构造过程图示如下：<br><img src="http://static.zybuluo.com/guoxs/ulr05nrbsyabjyn8ofhgz8aa/5.png" alt="构造过程"><br>最终生成的单词查找树如下：<br><img src="http://static.zybuluo.com/guoxs/38avhoeamg2du03p5qsohf48/6.png" alt="单词查找树"></p>
<p>接下来需要解决的是<strong>写入和读取单词查找树</strong>。代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTrie</span><span class="params">(Node x)</span></span>&#123; </span><br><span class="line">    <span class="comment">//输出单词查找树的比特字符串</span></span><br><span class="line">    <span class="keyword">if</span> (x.isLeaf())&#123;</span><br><span class="line">        BinaryStdOut.write(<span class="keyword">true</span>);</span><br><span class="line">        BinaryStdOut.write(x.ch);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BinaryStdOut.write(<span class="keyword">false</span>);</span><br><span class="line">    writeTrie(x.left);</span><br><span class="line">    writeTrie(x.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">readTrie</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BinaryStdIn.readBoolean())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(BinaryStdIn.readChar(), <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">&#x27;\0&#x27;</span>, <span class="number">0</span>, readTrie(), readTrie());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>writeTree()过程是这样的：使用<strong>前序遍历</strong>单词查找树，当它访问的是一个内部结点是写入0；当它访问的是叶子结点时写入1，然后紧接着写入该叶子结点中字符的8位ASCII编码。<br>readTree()过程是这样的：首先读取一个比特得到当前结点的类型，如果是叶子结点就读取字符编码并创建一个叶子结点，如果是内部结点就创建一个内部结点并递归地继续构造它的左右子树。<br>以字符串 “ABRACADABRA!”为例，写入过程如下图：<br><img src="http://static.zybuluo.com/guoxs/m21kag56d7xbe77bma6vvpn3/7.png" alt="读写单词查找二叉树"></p>
<p>好，现在我们来完整地回顾一下霍夫曼编码的过程：</p>
<blockquote>
<p>压缩过程<br>1、读取输入；<br>2、将输入中每个char值得出现频率制成表格；<br>3、根据频率构造相应的霍夫曼编码树；<br>4、构造编码表，将输入中的每个char值和一个比特字符相关联；<br>5、将单词查找树编码为比特字符串并写入输出流；<br>6、将单词总数编码为比特字符串并写入输出流；<br>7、使用编译表翻译每个输入字符。<br>解压过程<br>1、读取比特流开头的单词查找树；<br>2、读取需解码的字符数量；<br>3、使用单词查找树将比特流解码。</p>
</blockquote>
<p>完整代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Huffman</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> R = <span class="number">256</span>; <span class="comment">// ASCII 字母表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 读取输入</span></span><br><span class="line">        String s = BinaryStdIn.readString();</span><br><span class="line">        <span class="keyword">char</span>[] input = s.toCharArray();</span><br><span class="line">        <span class="comment">// 统计频率</span></span><br><span class="line">        <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[R];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length; i++)</span><br><span class="line">            freq[input[i]]++;</span><br><span class="line">        <span class="comment">// 构造霍夫曼编码树</span></span><br><span class="line">        Node root = buildTrie(freq);</span><br><span class="line">        <span class="comment">// 递归地构造编码表</span></span><br><span class="line">        String[] st = <span class="keyword">new</span> String[R];</span><br><span class="line">        buildCode(st, root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印解码用的单词查找表</span></span><br><span class="line">        writeTrie(root);</span><br><span class="line">        <span class="comment">// 打印字符总数</span></span><br><span class="line">        BinaryStdOut.write(input.length);</span><br><span class="line">        <span class="comment">// 使用霍夫曼编码处理输入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length; i++)&#123;</span><br><span class="line">            String code = st[input[i]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; code.length(); j++)</span><br><span class="line">                <span class="keyword">if</span> (code.charAt(j) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    BinaryStdOut.write(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">else</span> BinaryStdOut.write(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BinaryStdOut.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="LZW压缩"><a href="#LZW压缩" class="headerlink" title="LZW压缩"></a>LZW压缩</h2><p>LZW压缩是由 A.Lempel、J.Ziv和T.Welch发明的一种算法，这种算法的基本思想和霍夫曼编码刚好相反。霍夫曼算法是输入中的定长模式产生一张变长的编码编译表，但是这种算法是为输入的变长模式生成一张定长的编码编译表。简单来说，这种压缩算法维护了一张（字符串：数字）的串表，将每个第一次出现的串放在一个串表中，用一个数字来表示串，压缩文件只存贮数字，则不存贮串，从而使文件的压缩效率得到较大的提高。奇妙的是，不管是在压缩还是在解压缩的过程中都能正确的建立这个串表，压缩或解压缩完成后，这个串表又被丢弃。</p>
<h3 id="算法基本思想"><a href="#算法基本思想" class="headerlink" title="算法基本思想"></a>算法基本思想</h3><p>LZW压缩算法有点难懂，我也是看了许久才发现其中的精妙之处……<br>在介绍基本思想之前，先说明几个名词：<br><code>字符</code>：输入的字节<br><code>字符串</code>：输入的字节序列<br><code>编码</code>：输出的字节</p>
<blockquote>
<p>这些名词在其它地方可能有其他含义，但是在LZW压缩中专指以上含义。</p>
</blockquote>
<p>LZW算法的操作是这样的：<br>对于一串输入，确定其字符的种类，然后进行编码。一般对于ASCII码，在符号表中将128个单字符键的值初始化为8位编码，如果用16进制表示，则A的编码是41，R的编码是52等等。最后把80保留为文件结尾的标志，这样的话从 0-80 就都有使用了。如果接下来要对输入中遇到的各种子字符串进行编码，则从81开始递增。</p>
<p>只要输入还没有结束，则不断进行以下操作：<br>① 找出未处理的输入中在符号表中最长的前缀字符串s；<br>② 输出 s 的八位编码；<br>③ 继续扫描 s 之后的一个字符 c （前瞻字符）；<br>④ 在符号表中将 s+c (连接s和c)的值设置为下一个编码值。</p>
<p>大致流程如下图所示：<br><img src="http://static.zybuluo.com/guoxs/qdmgtyu3wgibzjsew1xe9h8a/%E7%BB%98%E5%9B%BE2.png" alt="流程"></p>
<h3 id="LZW压缩-1"><a href="#LZW压缩-1" class="headerlink" title="LZW压缩"></a>LZW压缩</h3><p>下图是对于输入 A B R A C A D AB RA BR ABR A 压缩的详细过程。<br>这里假设单字符集为ASCII所有字符，即对子字符串的编码从81开始。<br><img src="http://static.zybuluo.com/guoxs/ef10j5pqaky53bxepeforcb5/30.png" alt="lzw举例"><br>从头开始扫描，一开始是最长前缀匹配是A，直接输出A的编码，此时扫描到(AB)，发现在编码表中没有该项，则把该项加入，即（AB:81）；接着将B作为前缀，最长匹配为B，直接输出B的编码，然后扫描到（BR），发现在编码表中没有该项，则把该项加入，即（BR:82）……以此类推可得到右边的编码表。<br>经过完整的过程，最终的压缩输出为：41(A) 42(B) 52(R) 41(A) 43(C) 41(A) 44(D) 81(AB) 83(RA) 82(BR) 88(ABR) 41(A) 80（end）<br>输入为17个7位ASCII字符，共119位；输出为13位八位编码，共104位——压缩比为87%。<br>LZW压缩的伪代码为：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STRING = get input character</span><br><span class="line">WHILE there are still input characters DO</span><br><span class="line">    CHARACTER = get input character</span><br><span class="line">    IF STRING+CHARACTER is in the string table then</span><br><span class="line">        STRING = STRING+character</span><br><span class="line">    ELSE</span><br><span class="line">        output the code for STRING</span><br><span class="line">        add STRING+CHARACTER to the string table</span><br><span class="line">        STRING = CHARACTER</span><br><span class="line">    END of IF</span><br><span class="line">END of WHILE</span><br><span class="line">output the code for STRING </span><br></pre></td></tr></table></figure></p>
<h3 id="LZW压缩的展开"><a href="#LZW压缩的展开" class="headerlink" title="LZW压缩的展开"></a>LZW压缩的展开</h3><p><img src="http://static.zybuluo.com/guoxs/ev95b0qhsjsk9fw83v3ih3fd/32.png" alt="展开"><br>在展开时，会维护一张关联字符串和编码值的符号表，这张表中加入了从00到7F和所有单个ASCII字符的字符串的关联条目，将第一个未关联的编码值设为81，将保留了当前字符串的变量val设为含有第一个字符的字符串，在遇到80之前不断进行如下操作：<br>① 输出当前字符串val<br>② 从输入中读取一个编码x<br>③ 在符号表中将s设为和x关联的值<br>④ 在符号表中将下一个未分配的编码值设为val+c，其中c为s的首字母<br>⑤ 将当前字符串val设为s</p>
<p><strong>特殊情况</strong><br>以上的操作有可能遇到处理不了的情况，考虑如下字符串：<br>A B AB ABA<br>被压缩得到的编码为：<br>41 42 81 83 80<br><img src="http://static.zybuluo.com/guoxs/v5xjpgh7v1ue2g04m6tinwy9/33.png" alt="特殊情况"><br>在展开时，首先得到编码41输出A，然后得到编码42得到前瞻字符并将（AB:81）插入符号表，输出B；读取81得到前瞻字符并将（BA:82）插入符号表，输出AB；到目前为止进展还不错，但接下来读取83并希望得到前瞻字符时发现此时要不全的符号表条目正是83，在这里就卡住了。幸运的是，检查（只有在读取的编码和需要完成的编码条目相同时才会出现）并修正（此时，前瞻字符必然是当前字符串的首字母，因为她就是下个将被输出的字符）这种情况并不难。在这个例子中，前瞻字符必然是A，因此，下一个被输出的字符串和符号表中83的值都是ABA。</p>
]]></content>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>语义分割中 CRF 的运用</title>
    <url>/Blog/2018/03/10/CRF/</url>
    <content><![CDATA[<p>图像语义分割的深度学习方法发展到现在，一个通用的框架基本确定了，即如下图所示：</p>
<p><img src="/Blog/.io//CRF01.jpg" alt="通用框架图"></p>
<p>其中， FCN 表示各种全卷积网络，CRF 为条件随机场，MRF 为马尔科夫随机场</p>
<p>前端使用 FCN 进行特征粗提取，后端使用 CRF/MRF 优化前端的输出，最后得到分割图。在<a href="http://guoxs.github.io/Blog/2018/02/06/deep-learning-limu-note08/#more">前一篇</a>关于语义分割的总结中，我已经把前端的不同架构大致总结了，这篇主要介绍后端优化方法。<br><span id="more"></span></p>
<h2 id="全连接条件随机场-DenseCRF"><a href="#全连接条件随机场-DenseCRF" class="headerlink" title="全连接条件随机场 (DenseCRF)"></a>全连接条件随机场 (DenseCRF)</h2><blockquote>
<p><a href="https://papers.nips.cc/paper/4296-efficient-inference-in-fully-connected-crfs-with-gaussian-edge-potentials.pdf">Efficient Inference in Fully Connected CRFs with Gaussian Edge Potentials</a></p>
</blockquote>
<p>对于每个像素 $i$ 具有类别标签 $x_i$ 还有对应的观测值 $y_i$，这样每个像素点作为节点，像素与像素间的关系作为边，即构成了一个<strong>条件随机场</strong>。而且我们通过观测变量 $y_i$ 来推测像素 $i$ 对应的类别标签 $x_i$。条件随机场如下：</p>
<p><img src="/Blog/.io//CRF02.jpg" alt="CRF"></p>
<p>条件随机场符合吉布斯分布：(此处的 x 即上面说的观测值)</p>
<script type="math/tex; mode=display">
P(\mathbf{X=x|I})=\frac{1}{Z(\mathbf{I})}\exp(-E(\mathbf{x|I}))</script><p>其中的 $E(\mathbf{x|I})$ 是能量函数，为了简便，以下省略全局观测 $\mathbf{I}$：</p>
<script type="math/tex; mode=display">
E(\mathbf{x})=\sum_i{\Psi_u(x_i)}+\sum_{i\<j}\Psi_p(x_i, x_j)</script><p>其中的一元势函数 $\sum_i{\Psi_u(x_i)}$ 即来自于前端 FCN 的输出。而二元势函数如下：</p>
<script type="math/tex; mode=display">
\Psi_p(x_i, x_j)=u(x_i, x_j)\sum_{m=1}^M{\omega^{(m)}k_G^{(m)}(\mathbf{f_i, f_j)}}</script><p>二元势函数就是描述像素点与像素点之间的关系，鼓励相似像素分配相同的标签，而相差较大的像素分配不同标签，而这个“距离”的定义与颜色值和实际相对距离有关。所以这样 CRF 能够使图片尽量在边界处分割。</p>
<p>而全连接条件随机场的不同就在于，二元势函数描述的是每一个像素与其他所有像素的关系，所以叫“全连接”。</p>
<h2 id="CRFasRNN"><a href="#CRFasRNN" class="headerlink" title="CRFasRNN"></a>CRFasRNN</h2><blockquote>
<p><a href="https://arxiv.org/pdf/1502.03240.pdf">Conditional Random Fields as Recurrent Neural Networks</a></p>
</blockquote>
<p>最开始使用 DenseCRF 是直接加在 FCN 的输出后面，可想这样是比较粗糙的。而且在深度学习中，我们都追求 end-to-end 的系统，所以 CRFasRNN 这篇文章将 DenseCRF 真正结合进了 FCN 中。</p>
<p>这篇文章也使用了<strong>平均场近似</strong>的方法，因为分解的每一步都是一些相乘相加的计算，和普通的加减（具体公式还是看论文吧），所以可以方便的把每一步描述成一层类似卷积的计算。这样即可结合进神经网络中，并且前后向传播也不存在问题。</p>
<p>当然，这里作者还将它进行了迭代，不同次数的迭代得到的结果优化程度也不同（一般取 10 以内的迭代次数），所以文章才说是 as RNN。优化结果如下：</p>
<p><img src="/Blog/.io//CRF03.png" alt="CRFasRNN"></p>
<h2 id="马尔科夫随机场-MRF"><a href="#马尔科夫随机场-MRF" class="headerlink" title="马尔科夫随机场 (MRF)"></a>马尔科夫随机场 (MRF)</h2><blockquote>
<p><a href="https://arxiv.org/pdf/1509.02634.pdf">Semantic Image Segmentation via Deep Parsing Network</a></p>
</blockquote>
<p>在 Deep Parsing Network 中使用的是 MRF，它的公式具体的定义和 CRF 类似，只不过作者对二元势函数进行了修改：</p>
<script type="math/tex; mode=display">
\Psi(y_i^u, y_i^v)=\sum_{k=1}^K\lambda_ku_k(i, u, j, v)\sum_{\forall{z\in{N_j}}}d(j, z)p_z^v</script><p>其中，作者加入的 $\lambda_k$ 为 label context，因为 $u_k$ 只是定义了两个像素同时出现的频率，而 $\lambda_k$ 可以对一些情况进行惩罚，比如，人可能在桌子旁边，但是在桌子下面的可能性就更小一些。所以这个量可以学习不同情况出现的概率。而原来的距离 $d(i,j)$ 只定义了两个像素间的关系，作者在这儿加入了个 triple penalty，即还引入了 $j$ 附近的 $z$，这样描述三方关系便于得到更充足的局部上下文。具体结构如下：</p>
<p><img src="/Blog/.io//CRF04.png" alt="MRF"></p>
<p>这个结构的优点在于：</p>
<ul>
<li>将平均场构造成了 CNN</li>
<li>联合训练并且可以 one-pass inference，而不用迭代</li>
</ul>
<h2 id="高斯条件随机场-G-CRF"><a href="#高斯条件随机场-G-CRF" class="headerlink" title="高斯条件随机场(G-CRF)"></a>高斯条件随机场(G-CRF)</h2><blockquote>
<p><a href="https://arxiv.org/pdf/1603.08358v1.pdf">Fast, Exact and Multi-Scale Inference for Semantic Image Segmentation with Deep Gaussian CRFs</a></p>
</blockquote>
<p>这个结构使用 CNN 分别来学习一元势函数和二元势函数。这样的结构是我们更喜欢的：<br><img src="/Blog/.io//CRF05.png" alt="G-CRF"><br>而此中的能量函数又不同于之前：</p>
<script type="math/tex; mode=display">
E(\mathbf{x})=\frac{1}{2}\mathbf{x}^T(\mathbf{A+\lambda I)x}-\mathbf{Bx}</script><p>而当 $(\mathbf{A+\lambda I)}$ 是对称正定时，求 $E(\mathbf{x})$ 的最小值等于求解：</p>
<script type="math/tex; mode=display">
(\mathbf{A+\lambda I)x}=\mathbf{B}</script><p>而 G-CRF 的优点在于：</p>
<ul>
<li>二次能量有明确全局</li>
<li>解线性简便很多</li>
</ul>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><ul>
<li>深度学习+概率图模型（PGM）是一种趋势。其实 DL 说白了就是进行特征提取，而 PGM 能够从数学理论很好的解释事物本质间的联系。</li>
<li>概率图模型的网络化。因为 PGM 通常不太方便加入 DL 的模型中，将 PGM 网络化后能够使 PGM 参数自学习，同时构成 end-to-end 的系统。</li>
</ul>
<p>参考文章：<br><a href="https://zhuanlan.zhihu.com/p/22308032">【总结】图像语义分割之FCN和CRF</a></p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>寄存器（内存访问）</title>
    <url>/Blog/2016/06/24/RAM/</url>
    <content><![CDATA[<h2 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h2><p><code>字单元</code> ： 即存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元存放字型数据的低位字节。</p>
<blockquote>
<p>任何两个地址连续的内存单元，N 号单元和N+1 号单元，可以将它们看成两个内存单元，也可看成一个地址为N的字单元中的高位字节单元和低位字节单元。</p>
</blockquote>
<h2 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h2><p>8086 CPU有一个DS寄存器，通常用来存放要访问的数据的段地址：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx</span><br><span class="line">mov al,[0]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>“[…]”表示一个内存单元，“[…]”中的0表示内存单元的偏移地址。段地址存在DS寄存器中。8086 CPU不支持将数据直接送入段寄存器，故需要用一个寄存器进行中转。</p>
</blockquote>
<p>8086 CPU一次性传送16位的数据，即一个字。</p>
<span id="more"></span>
<h2 id="mov、add、sub指令"><a href="#mov、add、sub指令" class="headerlink" title="mov、add、sub指令"></a>mov、add、sub指令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov 寄存器，数据</span><br><span class="line">mov 寄存器，寄存器</span><br><span class="line">mov 寄存器，内存单元</span><br><span class="line">mov 寄存器，段寄存器</span><br><span class="line">mov 内存单元，寄存器</span><br><span class="line">mov 段寄存器，寄存器</span><br><span class="line">mov 段寄存器，内存单元</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add 寄存器，数据</span><br><span class="line">add 寄存器，寄存器</span><br><span class="line">add 寄存器，内存单元</span><br><span class="line">add 内存单元，寄存器</span><br></pre></td></tr></table></figure>
<p>将add换成sub也一样</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">push ax</span><br><span class="line">mov bx,2266H</span><br><span class="line">push bx</span><br><span class="line">mov cx,1122H</span><br><span class="line">push cx</span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br><span class="line">pop cx</span><br></pre></td></tr></table></figure>
<p>执行过程如下图：<br><img src="http://static.zybuluo.com/guoxs/1eqn57elqtooh0r8akw0spfp/1.png" alt="执行过程"></p>
<p>CPU通过CS IP知道当前要执行的指令所在的地址，但是如何知道栈顶的位置呢？<br>在8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。<strong>任意时刻，SS:SP指向栈顶元素。</strong></p>
<p>push ax 的执行，有以下两步完成：</p>
<ul>
<li>SP = SP - 2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶。</li>
<li>将ax中的内容送到 SS:SP 指向的内存单元处，SS:SP 此时指向栈顶。</li>
</ul>
<p><img src="http://static.zybuluo.com/guoxs/myi2z4phv3lq1yx8y259vcoa/2.png" alt="push指令执行过程"><br>从图中可以看出，8086CPU中，入栈时，栈顶从高地址向地址方向增长。</p>
<blockquote>
<p>当栈为空时，栈中没有元素，也就不存在栈顶元素。所以SS:SP只能指向栈的最底部单元下面的单元。如果栈底部单元地址为1000:000E，则栈空时，SS:SP = 1000：0010H</p>
</blockquote>
<p>pop指令执行过程<br><img src="http://static.zybuluo.com/guoxs/en8fxsbwaotp7y54k5ajzg8t/3.png" alt="pop指令执行过程"></p>
<p><strong>8086 CPU没有记录栈顶元素上限和栈底的寄存器，这要程序员自己注意。</strong></p>
<h2 id="pop、push指令"><a href="#pop、push指令" class="headerlink" title="pop、push指令"></a>pop、push指令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push 寄存器</span><br><span class="line">push 段寄存器</span><br><span class="line">push 内存单元</span><br></pre></td></tr></table></figure>
<p>pop也一样。</p>
<h2 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h2><p>一段内存，可以即使代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么都不是。关键在于CPU中寄存器的设置，即CS IP SS SP DS的指向。</p>
<p>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段的内容当做数据来访问。</p>
<p>对于代码段，将它的段地址放在CS中，将段的第一条指令地址放在IP中，这样CPU就会执行我们定义的代码段中的指令。</p>
<p>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中。</p>
<h2 id="汇编指令编程"><a href="#汇编指令编程" class="headerlink" title="汇编指令编程"></a>汇编指令编程</h2><p>（1）关于D命令<br><code>-d 1000:0000</code> : 执行时段地址1000存放在DS中。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d cs:0     //查看当前代码段中的指令代码</span><br><span class="line">-d ss:0     //查看当前栈段中的内容</span><br></pre></td></tr></table></figure></p>
<p>E A U也可以带内存单元地址<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-r ds</span><br><span class="line">-e ds:0 11 22 33 44 55 66</span><br><span class="line">-u cs:0</span><br><span class="line">-a ds:0</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机相关国际学术期刊与会议</title>
    <url>/Blog/2018/03/10/academic-journal-and-conference-on-CS/</url>
    <content><![CDATA[<p>来源：<a href="http://history.ccf.org.cn/sites/ccf/biaodan.jsp?contentId=2903940690839">中国计算机学会推荐 国际学术会议与期刊目录</a></p>
<p>官网蓝底亮瞎眼，所以弄了个好看点的。</p>
<h2 id="中国计算机学会推荐国际学术-期刊"><a href="#中国计算机学会推荐国际学术-期刊" class="headerlink" title="中国计算机学会推荐国际学术 期刊"></a>中国计算机学会推荐国际学术 期刊</h2><h3 id="A-类"><a href="#A-类" class="headerlink" title="A 类"></a>A 类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">刊物简称</th>
<th style="text-align:center">刊物全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">AI</td>
<td style="text-align:center">Artificial Intelligence</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ai/">http://dblp.uni-trier.de/db/journals/ai/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">TPAMI</td>
<td style="text-align:center">IEEE Trans on Pattern Analysis and Machine Intelligence</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/pami/">http://dblp.uni-trier.de/db/journals/pami/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">IJCV</td>
<td style="text-align:center">International Journal of Computer Vision</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ijcv/">http://dblp.uni-trier.de/db/journals/ijcv/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">JMLR</td>
<td style="text-align:center">Journal of Machine Learning Research</td>
<td style="text-align:center">MIT Press</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/jmlr/">http://dblp.uni-trier.de/db/journals/jmlr/</a></td>
</tr>
</tbody>
</table>
</div>
<span id="more"></span>
<h3 id="B-类"><a href="#B-类" class="headerlink" title="B 类"></a>B 类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">刊物简称</th>
<th style="text-align:center">刊物全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">TAP</td>
<td style="text-align:center">ACM Transactions on Applied Perception</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/tap/">http://dblp.uni-trier.de/db/journals/tap/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">TSLP</td>
<td style="text-align:center">ACM Transactions on Speech and Language Processing</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/tslp/">http://dblp.uni-trier.de/db/journals/tslp/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"></td>
<td style="text-align:center">Computational Linguistics</td>
<td style="text-align:center">MIT Press</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/coling/">http://dblp.uni-trier.de/db/journals/coling/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">CVIU</td>
<td style="text-align:center">Computer Vision and Image Understanding</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/cviu/">http://dblp.uni-trier.de/db/journals/cviu/</a></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">DKE</td>
<td style="text-align:center">Data and Knowledge Engineering</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/dke/index.html">http://dblp.uni-trier.de/db/journals/dke/index.html</a></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"></td>
<td style="text-align:center">Evolutionary Computation</td>
<td style="text-align:center">MIT Press</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ec/">http://dblp.uni-trier.de/db/journals/ec/</a></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">TAC</td>
<td style="text-align:center">IEEE Transactions on Affective Computing</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/taffco/">http://dblp.uni-trier.de/db/journals/taffco/</a></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">TASLP</td>
<td style="text-align:center">IEEE Transactions on Audio, Speech, and Language Processing</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/taslp/">http://dblp.uni-trier.de/db/journals/taslp/</a></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center"></td>
<td style="text-align:center">IEEE Transactions on Cybernetics</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/tcyb/">http://dblp.uni-trier.de/db/journals/tcyb/</a></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">TEC</td>
<td style="text-align:center">IEEE Transactions on Evolutionary Computation</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/tec/">http://dblp.uni-trier.de/db/journals/tec/</a></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">TFS</td>
<td style="text-align:center">IEEE Transactions on Fuzzy Systems</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/tfs/">http://dblp.uni-trier.de/db/journals/tfs/</a></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">TNNLS</td>
<td style="text-align:center">IEEE Transactions on Neural Networks and learning systems</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/tnn/">http://dblp.uni-trier.de/db/journals/tnn/</a></td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">IJAR</td>
<td style="text-align:center">International Journal of Approximate Reasoning</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ijar/">http://dblp.uni-trier.de/db/journals/ijar/</a></td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">JAIR</td>
<td style="text-align:center">Journal of AI Research</td>
<td style="text-align:center">AAAI</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/jair/index.html">http://dblp.uni-trier.de/db/journals/jair/index.html</a></td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center"></td>
<td style="text-align:center">Journal of Automated Reasoning</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/jar/">http://dblp.uni-trier.de/db/journals/jar/</a></td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">JSLHR</td>
<td style="text-align:center">Journal of Speech, Language, and Hearing Research</td>
<td style="text-align:center">American Speech-Language Hearing Association</td>
<td style="text-align:center"><a href="http://jslhr.pubs.asha.org/">http://jslhr.pubs.asha.org/</a></td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center"></td>
<td style="text-align:center">Machine Learning</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ml/">http://dblp.uni-trier.de/db/journals/ml/</a></td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center"></td>
<td style="text-align:center">Neural Computation</td>
<td style="text-align:center">MIT Press</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/neco/">http://dblp.uni-trier.de/db/journals/neco/</a></td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center"></td>
<td style="text-align:center">Neural Networks</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/nn/">http://dblp.uni-trier.de/db/journals/nn/</a></td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center"></td>
<td style="text-align:center">Pattern Recognition</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/par/">http://dblp.uni-trier.de/db/conf/par/</a></td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center">AAMAS</td>
<td style="text-align:center">Autonomous Agents and Multi-Agent Systems</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/aamas/">http://dblp.uni-trier.de/db/journals/aamas/</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="C-类"><a href="#C-类" class="headerlink" title="C 类"></a>C 类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">刊物简称</th>
<th style="text-align:center">刊物全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">TALIP</td>
<td style="text-align:center">ACM Transactions on Asian LanguageInformation Processing</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/talip/">http://dblp.uni-trier.de/db/journals/talip/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center">Applied Intelligence</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/apin/">http://dblp.uni-trier.de/db/journals/apin/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">AIM</td>
<td style="text-align:center">Artificial Intelligence in Medicine</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/artmed/">http://dblp.uni-trier.de/db/journals/artmed/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"></td>
<td style="text-align:center">Artificial Life</td>
<td style="text-align:center">MIT Press</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/alife/">http://dblp.uni-trier.de/db/journals/alife/</a></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"></td>
<td style="text-align:center">Computational Intelligence</td>
<td style="text-align:center">Wiley</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ci/">http://dblp.uni-trier.de/db/journals/ci/</a></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center"></td>
<td style="text-align:center">Computer Speech and Language</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/csl/">http://dblp.uni-trier.de/db/journals/csl/</a></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center"></td>
<td style="text-align:center">Connection Science</td>
<td style="text-align:center">Taylor &amp; Francis</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/connection/">http://dblp.uni-trier.de/db/journals/connection/</a></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">DSS</td>
<td style="text-align:center">Decision Support Systems</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/dss/">http://dblp.uni-trier.de/db/journals/dss/</a></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">EAAI</td>
<td style="text-align:center">Engineering Applications of Artificial Intelligence</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/eaai/">http://dblp.uni-trier.de/db/journals/eaai/</a></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center">Expert Systems</td>
<td style="text-align:center">Blackwell/Wiley</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/es/">http://dblp.uni-trier.de/db/journals/es/</a></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">ESWA</td>
<td style="text-align:center">Expert Systems with Applications</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/eswa/">http://dblp.uni-trier.de/db/journals/eswa/</a></td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center"></td>
<td style="text-align:center">Fuzzy Sets and Systems</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/fss/">http://dblp.uni-trier.de/db/journals/fss/</a></td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">T-CIAIG</td>
<td style="text-align:center">IEEE Transactions on Computational Intelligence and AI in Games</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/tciaig/">http://dblp.uni-trier.de/db/journals/tciaig/</a></td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">IET-CVI IET</td>
<td style="text-align:center">Computer Vision</td>
<td style="text-align:center">IET</td>
<td style="text-align:center"><a href="http://digital-library.theiet.org/content/journals/iet-cvi">http://digital-library.theiet.org/content/journals/iet-cvi</a></td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center"></td>
<td style="text-align:center">IET Signal Processing</td>
<td style="text-align:center">IET *</td>
<td style="text-align:center"><a href="http://digital-library.theiet.org/content/journals/iet-spr">http://digital-library.theiet.org/content/journals/iet-spr</a></td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">IVC</td>
<td style="text-align:center">Image and Vision Computing</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ivc/">http://dblp.uni-trier.de/db/journals/ivc/</a></td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">IDA</td>
<td style="text-align:center">Intelligent Data Analysis</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ida/">http://dblp.uni-trier.de/db/journals/ida/</a></td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">IJCIA</td>
<td style="text-align:center">International Journal of Computational Intelligence and Applications</td>
<td style="text-align:center">World Scientific</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ijcia/">http://dblp.uni-trier.de/db/journals/ijcia/</a></td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">IJDAR</td>
<td style="text-align:center">International Journal on Document Analysis and Recognition</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ijdar/">http://dblp.uni-trier.de/db/journals/ijdar/</a></td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center">IJIS</td>
<td style="text-align:center">International Journal of Intelligent Systems</td>
<td style="text-align:center">Wiley</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ijis/">http://dblp.uni-trier.de/db/journals/ijis/</a></td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td style="text-align:center">IJNS</td>
<td style="text-align:center">International Journal of Neural Systems</td>
<td style="text-align:center">World Scientific</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ijns/">http://dblp.uni-trier.de/db/journals/ijns/</a></td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td style="text-align:center">IJPRAI</td>
<td style="text-align:center">International Journal of Pattern Recognition and Artificial Intelligence</td>
<td style="text-align:center">World Scientific</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ijprai/">http://dblp.uni-trier.de/db/journals/ijprai/</a></td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:center"></td>
<td style="text-align:center">International Journal of Uncertainty,Fuzziness and KBS</td>
<td style="text-align:center">World Scientific</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ijcia/">http://dblp.uni-trier.de/db/journals/ijcia/</a></td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center">JETAI</td>
<td style="text-align:center">Journal of Experimental and Theoretical Artificial Intelligence</td>
<td style="text-align:center">Taylor &amp; Francis</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/jetai/">http://dblp.uni-trier.de/db/journals/jetai/</a></td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td style="text-align:center">KBS</td>
<td style="text-align:center">Knowledge-Based Systems</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/kbs/">http://dblp.uni-trier.de/db/journals/kbs/</a></td>
</tr>
<tr>
<td style="text-align:center">27</td>
<td style="text-align:center"></td>
<td style="text-align:center">Machine Translation</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/mt/">http://dblp.uni-trier.de/db/journals/mt/</a></td>
</tr>
<tr>
<td style="text-align:center">28</td>
<td style="text-align:center"></td>
<td style="text-align:center">Machine Vision and Applications</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/mva/">http://dblp.uni-trier.de/db/journals/mva/</a></td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center"></td>
<td style="text-align:center">Natural Computing</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/nc/">http://dblp.uni-trier.de/db/journals/nc/</a></td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td style="text-align:center">NLE</td>
<td style="text-align:center">Natural Language Engineering</td>
<td style="text-align:center">Cambridge University</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/nle/">http://dblp.uni-trier.de/db/journals/nle/</a></td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td style="text-align:center">NCA</td>
<td style="text-align:center">Neural Computing &amp; Applications</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/nca/">http://dblp.uni-trier.de/db/journals/nca/</a></td>
</tr>
<tr>
<td style="text-align:center">32</td>
<td style="text-align:center">NPL</td>
<td style="text-align:center">Neural Processing Letters</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/npl/">http://dblp.uni-trier.de/db/journals/npl/</a></td>
</tr>
<tr>
<td style="text-align:center">33</td>
<td style="text-align:center"></td>
<td style="text-align:center">Neurocomputing</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/ijon/">http://dblp.uni-trier.de/db/journals/ijon/</a></td>
</tr>
<tr>
<td style="text-align:center">34</td>
<td style="text-align:center">PAA</td>
<td style="text-align:center">Pattern Analysis and Applications</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/paa/">http://dblp.uni-trier.de/db/journals/paa/</a></td>
</tr>
<tr>
<td style="text-align:center">35</td>
<td style="text-align:center">PRL</td>
<td style="text-align:center">Pattern Recognition Letters</td>
<td style="text-align:center">Elsevier</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/prl/">http://dblp.uni-trier.de/db/journals/prl/</a></td>
</tr>
<tr>
<td style="text-align:center">36</td>
<td style="text-align:center"></td>
<td style="text-align:center">Soft Computing</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/soco/">http://dblp.uni-trier.de/db/journals/soco/</a></td>
</tr>
<tr>
<td style="text-align:center">37</td>
<td style="text-align:center">WIAS</td>
<td style="text-align:center">Web Intelligence and Agent Systems</td>
<td style="text-align:center">IOS Press</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/journals/wias/">http://dblp.uni-trier.de/db/journals/wias/</a></td>
</tr>
</tbody>
</table>
</div>
<h2 id="中国计算机学会推荐国际学术会议"><a href="#中国计算机学会推荐国际学术会议" class="headerlink" title="中国计算机学会推荐国际学术会议"></a>中国计算机学会推荐国际学术会议</h2><h3 id="A-类-1"><a href="#A-类-1" class="headerlink" title="A 类"></a>A 类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">刊物简称</th>
<th style="text-align:center">刊物全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">AAAI</td>
<td style="text-align:center">AAAI Conference on Artificial Intelligence</td>
<td style="text-align:center">AAAI</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/aaai/">http://dblp.uni-trier.de/db/conf/aaai/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">CVPR</td>
<td style="text-align:center">IEEE Conference on Computer Vision and Pattern Recognition</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/cvpr/">http://dblp.uni-trier.de/db/conf/cvpr/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">ICCV</td>
<td style="text-align:center">International Conference on Computer Vision</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/iccv/">http://dblp.uni-trier.de/db/conf/iccv/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">ICML</td>
<td style="text-align:center">International Conference on Machine Learning</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/icml/">http://dblp.uni-trier.de/db/conf/icml/</a></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">IJCAI</td>
<td style="text-align:center">International Joint Conference on Artificial Intelligence</td>
<td style="text-align:center">Morgan Kaufmann</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ijcai/">http://dblp.uni-trier.de/db/conf/ijcai/</a></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">NIPS</td>
<td style="text-align:center">Annual Conference on Neural Information Processing Systems</td>
<td style="text-align:center">MIT Press</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/nips/">http://dblp.uni-trier.de/db/conf/nips/</a></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">ACL</td>
<td style="text-align:center">Annual Meeting of the Association for Computational Linguistics</td>
<td style="text-align:center">ACL</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/acl/">http://dblp.uni-trier.de/db/conf/acl/</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="B-类-1"><a href="#B-类-1" class="headerlink" title="B 类"></a>B 类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">刊物简称</th>
<th style="text-align:center">刊物全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">COLT</td>
<td style="text-align:center">Annual Conference on Computational Learning Theory</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/colt/">http://dblp.uni-trier.de/db/conf/colt/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">EMNLP</td>
<td style="text-align:center">Conference on Empirical Methods in Natural Language Processing</td>
<td style="text-align:center">ACL</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/emnlp/">http://dblp.uni-trier.de/db/conf/emnlp/</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">ECAI</td>
<td style="text-align:center">European Conference on Artificial Intelligence</td>
<td style="text-align:center">IOS Press</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ecai/">http://dblp.uni-trier.de/db/conf/ecai/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">ECCV</td>
<td style="text-align:center">European Conference on Computer Vision</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/eccv/">http://dblp.uni-trier.de/db/conf/eccv/</a></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">ICRA</td>
<td style="text-align:center">IEEE International Conference on Robotics and Automation</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/icra/">http://dblp.uni-trier.de/db/conf/icra/</a></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">ICAPS</td>
<td style="text-align:center">International Conference on Automated Planning and Scheduling</td>
<td style="text-align:center">AAAI</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/aips/">http://dblp.uni-trier.de/db/conf/aips/</a></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">ICCBR</td>
<td style="text-align:center">International Conference on Case-Based Reasoning</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/iccbr/">http://dblp.uni-trier.de/db/conf/iccbr/</a></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">COLING</td>
<td style="text-align:center">International Conference on Computational Linguistics</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/coling/">http://dblp.uni-trier.de/db/conf/coling/</a></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">KR</td>
<td style="text-align:center">International Conference on Principles of Knowledge Representation and Reasoning</td>
<td style="text-align:center">Morgan Kaufmann</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/kr/">http://dblp.uni-trier.de/db/conf/kr/</a></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">UAI</td>
<td style="text-align:center">International Conference on Uncertainty in Artificial Intelligence</td>
<td style="text-align:center">AUAI</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/uai/">http://dblp.uni-trier.de/db/conf/uai/</a></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">AAMAS</td>
<td style="text-align:center">International Joint Conference on Autonomous Agents and Multi-agent Systems</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/atal/index.html">http://dblp.uni-trier.de/db/conf/atal/index.html</a></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">PPSN</td>
<td style="text-align:center">Parallel Problem Solving from Nature</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ppsn/">http://dblp.uni-trier.de/db/conf/ppsn/</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="C-类-1"><a href="#C-类-1" class="headerlink" title="C 类"></a>C 类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">刊物简称</th>
<th style="text-align:center">刊物全称</th>
<th style="text-align:center">出版社</th>
<th style="text-align:center">网址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">ACCV</td>
<td style="text-align:center">Asian Conference on Computer Vision</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/accv/">http://dblp.uni-trier.de/db/conf/accv/</a></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">CoNLL</td>
<td style="text-align:center">Conference on Natural Language Learning</td>
<td style="text-align:center">CoNLL</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/conll">http://dblp.uni-trier.de/db/conf/conll</a></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">GECCO</td>
<td style="text-align:center">Genetic and Evolutionary Computation Conference</td>
<td style="text-align:center">ACM</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/gecco/">http://dblp.uni-trier.de/db/conf/gecco/</a></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">ICTAI</td>
<td style="text-align:center">IEEE International Conference on Tools with Artificial Intelligence</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ictai/">http://dblp.uni-trier.de/db/conf/ictai/</a></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">ALT</td>
<td style="text-align:center">International Conference on Algorithmic Learning Theory</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/alt/">http://dblp.uni-trier.de/db/conf/alt/</a></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">ICANN</td>
<td style="text-align:center">International Conference on Artificial Neural Networks</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/icann/">http://dblp.uni-trier.de/db/conf/icann/</a></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">FGR</td>
<td style="text-align:center">International Conference on Automatic Face and Gesture Recognition</td>
<td style="text-align:center">IEEE <a href="http://dblp.uni-trier.de/db/conf/fgr/">http://dblp.uni-trier.de/db/conf/fgr/</a></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">ICDAR</td>
<td style="text-align:center">International Conference on Document Analysis and Recognition</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/icdar/">http://dblp.uni-trier.de/db/conf/icdar/</a></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">ILP</td>
<td style="text-align:center">International Conference on Inductive Logic Programming</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ilp/">http://dblp.uni-trier.de/db/conf/ilp/</a></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">KSEM</td>
<td style="text-align:center">International conference on Knowledge Science,Engineering and Management</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ksem/">http://dblp.uni-trier.de/db/conf/ksem/</a></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">ICONIP</td>
<td style="text-align:center">International Conference on Neural Information Processing</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/iconip/">http://dblp.uni-trier.de/db/conf/iconip/</a></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">ICPR</td>
<td style="text-align:center">International Conference on Pattern Recognition</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/icpr/">http://dblp.uni-trier.de/db/conf/icpr/</a></td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">ICB</td>
<td style="text-align:center">International Joint Conference on Biometrics</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/icb/">http://dblp.uni-trier.de/db/conf/icb/</a></td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">IJCNN</td>
<td style="text-align:center">International Joint Conference on Neural Networks</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/ijcnn/">http://dblp.uni-trier.de/db/conf/ijcnn/</a></td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">PRICAI</td>
<td style="text-align:center">Pacific Rim International Conference on Artificial Intelligence</td>
<td style="text-align:center">Springer</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/pricai/">http://dblp.uni-trier.de/db/conf/pricai/</a></td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">NAACL</td>
<td style="text-align:center">The Annual Conference of the North American Chapter of the Association for Computational Linguistics</td>
<td style="text-align:center">NAACL</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/naacl/">http://dblp.uni-trier.de/db/conf/naacl/</a></td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">BMVC</td>
<td style="text-align:center">British Machine Vision Conference</td>
<td style="text-align:center">British Machine Vision Association</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/bmvc/">http://dblp.uni-trier.de/db/conf/bmvc/</a></td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">IROS</td>
<td style="text-align:center">IEEE\RSJ International Conference on Intelligent Robots and Systems</td>
<td style="text-align:center">IEEE</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/iros/">http://dblp.uni-trier.de/db/conf/iros/</a></td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">AISTATS</td>
<td style="text-align:center">Artificial Intelligence and Statistics</td>
<td style="text-align:center">JMLR</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/aistats/">http://dblp.uni-trier.de/db/conf/aistats/</a></td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">ACML</td>
<td style="text-align:center">Asian Conf. on Machine Learning</td>
<td style="text-align:center">JMLR</td>
<td style="text-align:center"><a href="http://dblp.uni-trier.de/db/conf/acml/">http://dblp.uni-trier.de/db/conf/acml/</a></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>论文写作</tag>
      </tags>
  </entry>
  <entry>
    <title>《Deep Forest》文献阅读</title>
    <url>/Blog/2017/11/06/deep-forest/</url>
    <content><![CDATA[<p>近日，西瓜书《机器学习》作者、国内机器学习大牛周志华教授发表了一篇论文，提出了一种基于树的方法——gcForest，挑战深度神经网络。本篇学习笔记为对其论文的解读。</p>
<h2 id="深度神经网络的缺陷"><a href="#深度神经网络的缺陷" class="headerlink" title="深度神经网络的缺陷"></a>深度神经网络的缺陷</h2><p>深度神经网络的巨大成功掀起了一股深度学习热潮，然而，深度学习取得巨大成就的同时，其不可避免的缺陷也渐渐暴露出来。<br>深度学习主要的缺陷有以下几个方面：</p>
<ul>
<li>深度神经网络训练时需要大量的数据，无法被运用到小规模的数据任务中；</li>
<li>深度神经网络是个非常复杂的模型（complicated models），训练过程中通常需要强大的计算设施(powerful computational facilities)，这导致身处大公司外的个人无法充分发挥其学习的潜力。</li>
<li>深度神经网络超参数（hyper-parameters）太多，其学习性能严重依赖于调参的过程。</li>
<li><p>深度神经网络的理论分析很困难，学习的过程就像一个黑箱子。</p>
<span id="more"></span>
<h2 id="gcForest-相对于深度神经网络的优点"><a href="#gcForest-相对于深度神经网络的优点" class="headerlink" title="gcForest 相对于深度神经网络的优点"></a>gcForest 相对于深度神经网络的优点</h2><p>文章中提出了 <strong>gcForest</strong>（multi-Grained Cascade forest，<strong>多粒度级联森林</strong>），以及一种全新的决策树集成方法。这种方法生成一个<strong>深度树集成方法</strong>（deep forest ensemble method），使用级联结构让 gcForest 做表征学习。当输入带有高维度时，通过多粒度扫描，其表征学习能力还能得到进一步的提升，而这有望使 gcForest 能注意到<strong>上下文或结构</strong>（contextual or structural aware）。级联的数量能够根据情况进行调节，从而使 gcForest 在只有小数据的情况下也表现出优异的性能。<br>相对于深度神经网络，gcForest 有以下优点：</p>
</li>
<li><p>gcForest 的超参数比深度神经网络少得多；且超参数设定性能鲁棒性相当高；</p>
</li>
<li>因为基于树模型，故 gcForest 理论分析更加简单；</li>
<li>gcForest 天然适合用于并行部署，因此效率更高。</li>
</ul>
<h2 id="gcForest-方法介绍"><a href="#gcForest-方法介绍" class="headerlink" title="gcForest 方法介绍"></a>gcForest 方法介绍</h2><p>gcForest 的整体流程如下：</p>
<p><img src="http://7xjzhz.com1.z0.glb.clouddn.com/Deep%20Forest4.jpg" alt="整体流程"></p>
<p>整个流程包含两大步，第一步是数据的多粒度扫描，第二步是级联森林学习。<br>假设原始数据有400个原始特征，图示使用三种不同的窗口对其进行扫描，每次向下移动一个特征。对于每个训练样本，100特征的窗口可以产生301 个100维的特征向量，如果有 M 个训练样本，则共有 301*M 个100维的训练样本。这些数据被用来训练一个完全随机森林和一个随机森林，每个森林包含了30棵决策树。<br>假设结果分为三类，则每个森林会为301个实例中每个实例都生成一个3维向量。 和等和200个特征和300个特征的滑动窗口数据相结合后，原始的400维特征向量被表示成了3618维特征向量，达到了特征向量的增强。</p>
<p>以下为使用滑动窗口扫描的特征重新表示的图示。对于图片等二维数据，用一个 10*10的窗口将产生121个特征向量，其具体实现和多尺寸的滑动窗口和一维数据类似。</p>
<p><img src="http://7xjzhz.com1.z0.glb.clouddn.com/Deep%20Forest3.jpg" alt="滑动窗口扫描原始数据"></p>
<p>随后，M 个 3618维特征向量被传入级联森林。级联森林结构如下图所示：</p>
<p><img src="http://7xjzhz.com1.z0.glb.clouddn.com/Deep%20Forest1.jpg" alt="级联深林结构图"></p>
<p>其中级联中的每一级接收到由前一级处理的特征信息，并将该级的处理结果输出给下一级。每个级是决策树森林的一个集合，即集成的集成（ensemble of ensembles）。使用不同类型的森林是为了增加多样性，因为多样性是集合结构的关键。论文中使用了两个<strong>完全随机的树森林</strong>（complete-random tree forests）和两个<strong>随机森林</strong>，每个完全随机的树森林包含1000个<strong>完全随机树</strong>，通过随机选择一个特征在树的每个节点进行分割实现生成，树一直生长，直到每个叶节点只包含相同类的实例或不超过10个实例。类似地，每个随机森林也包含1000棵树，通过随机选择 $\sqrt{d}$ 数量的特征作为候选（d是输入特征的数量），然后选择具有最佳 <strong>gini 值</strong>的特征作为分割。</p>
<p>给定一个实例，每个森林会通过计算在相关实例落入的叶节点处的不同类的训练样本的百分比，然后对森林中的所有树计平均值，以生成对类的分布的估计。如下图所示，其中红色部分突出了每个实例遍历到叶节点的路径。</p>
<p><img src="http://7xjzhz.com1.z0.glb.clouddn.com/Deep%20Forest2.jpg" alt="类向量生成图示"></p>
<p>被估计的类分布形成<strong>类向量</strong>（class vector），该类向量接着与输入到级联的下一级的原始特征向量相连接。例如，假设有三个类，则四个森林每一个都将产生一个三维的类向量，因此，级联的下一级将接收12 = 3×4个增强特征（augmented feature）。</p>
<p>为了降低过拟合风险，每个森林产生的类向量由<strong>k折交叉验证</strong>（k-fold cross validation）产生。每个实例都将被用作 k − 1 次训练数据，产生 k − 1 个类向量，然后对其取平均值以产生作为级联中下一级的增强特征的最终类向量。在扩展一个新的级后，整个级联的性能将在验证集上进行估计，如果没有显着的性能增益，训练过程将终止；因此，级联中级的数量是自动确定的。与模型的复杂性固定的大多数深度神经网络相反，gcForest 能够适当地通过终止训练来决定其模型的复杂度。这使得 gcForest 能够适用于不同规模的训练数据，而不局限于大规模训练数据。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正如文字中最后所说的：</p>
<blockquote>
<p>There are other possibilities to construct deep forest. As a seminar study, we have only explored a little in this direction. If we had stronger computational facilities, we would like to try big data and deeper forest, which is left for future work. In principle, deep forest should be able to exhibit other powers of deep neural networks, such as serving as feature extractor or pre-trained model. <strong>It is worth mentioning that in order to tackle complicated tasks, it is likely that learning models have to go deep.</strong> Current deep models, however, are always neural networks. This paper illustrates how to construct deep forest, and we believe it may open a door towards alternative to deep neural networks for many tasks.</p>
</blockquote>
<p>要解决复杂的问题，学习模型需要往深了走。然而当前的深度模型全部都是神经网络，其实，除了神经网络，还有很多深度学习的方法等待着去发掘。</p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>MXNet/Gluon 深度学习笔记（一）</title>
    <url>/Blog/2018/01/20/deep-learning-limu-note01/</url>
    <content><![CDATA[<p>如何在远端开启 jupyter notebook 服务，而在本地访问？</p>
<p>可以把远端的端口映射到本地，让浏览器能够在本地打开 notebook。<br>先在远端运行 jupyter notebook，然后使用 <code>ssh</code> 将远端的jupyter notebook 端口映射到本地的未使用的端端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -L8008:localhost:8888 remote-ip</span><br></pre></td></tr></table></figure>
<p>其中 <code>8008</code> 为本地未使用的一个端口号，<code>8888</code> 为在远端开启 jupyter notebook 时的默认端口号。</p>
<span id="more"></span>
<h2 id="NDArray-处理数据"><a href="#NDArray-处理数据" class="headerlink" title="NDArray 处理数据"></a>NDArray 处理数据</h2><p>NDArray 是 MXNet 存储和变换数据的主要工具，它和 Numpy 的多维数组非常相似。</p>
<p>创建数组，它的元素服从均值0标准差1的正态分布：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = nd.random_normal(0, 1, shape=(3, 4))</span><br></pre></td></tr></table></figure><br><strong>广播（Broadcasting）</strong><br>当二元操作符左右两边ndarray形状不一样时，系统会尝试将其复制到一个共同的形状。例如a的第0维是3, b的第0维是1，那么a+b时会将b沿着第0维复制3遍：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = nd.arange(3).reshape((3,1))</span><br><span class="line">b = nd.arange(2).reshape((1,2))</span><br><span class="line">print(&#x27;a:&#x27;, a)</span><br><span class="line">print(&#x27;b:&#x27;, b)</span><br><span class="line">print(&#x27;a+b:&#x27;, a+b)</span><br><span class="line"></span><br><span class="line">a: 3x1</span><br><span class="line">[[ 0.]</span><br><span class="line"> [ 1.]</span><br><span class="line"> [ 2.]]</span><br><span class="line"></span><br><span class="line"> b: 1x2</span><br><span class="line">[[ 0.  1.]]</span><br><span class="line"></span><br><span class="line">a+b: 3x2</span><br><span class="line">[[ 0.  1.]</span><br><span class="line"> [ 1.  2.]</span><br><span class="line"> [ 2.  3.]]</span><br></pre></td></tr></table></figure><br><strong>原位操作</strong><br>减少运算消耗的内存<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nd.elemwise_add(x, y, out=z)</span><br></pre></td></tr></table></figure></p>
<h2 id="autograd-自动求导"><a href="#autograd-自动求导" class="headerlink" title="autograd 自动求导"></a>autograd 自动求导</h2><p>mxnet 中进行求导的时候，需要一个地方来存 x 的导数，可以通过 NDArray 的方法 attach_grad() 来要求系统申请对应的空间。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x.attach_grad()</span><br></pre></td></tr></table></figure><br>默认条件下，MXNet 不会自动记录和构建用于求导的计算图，我们需要使用 autograd 里的 record() 函数来显式的要求 MXNet 记录我们需要求导的程序。譬如 $f = 2 \times x^2$<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with ag.record():</span><br><span class="line">  y = x * 2</span><br><span class="line">  z = y * x</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>一定要先为待求导的变量分配存储导数的空间 x.attach_grad()，再定义求导函数 with ag.record()，不然会报错。</p>
</blockquote>
<p>接下来可以通过 <code>z.backward()</code> 来进行求导。如果 z 不是一个标量，那么 <code>z.backward()</code> 等价于 <code>nd.sum(z).backward()</code>.</p>
<h2 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h2><p>线性模型</p>
<script type="math/tex; mode=display">y = X \cdot w + b + \eta, \quad \text{for } \eta \sim \mathcal{N}(0,\sigma^2)</script><p>训练神经网络的时候，网络需要不断读取数据块。可以定义一个函数，每次返回 batch_size 个随机的样本和对应的目标。这个功能可以使用 python 中的 yield 来构造一个迭代器实现：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">batch_size = 10</span><br><span class="line">def data_iter():</span><br><span class="line">    # 产生一个随机索引</span><br><span class="line">    idx = list(range(num_examples))</span><br><span class="line">    random.shuffle(idx)</span><br><span class="line">    for i in range(0, num_examples, batch_size):</span><br><span class="line">        j = nd.array(idx[i:min(i+batch_size,num_examples)])</span><br><span class="line">        yield nd.take(X, j), nd.take(y, j)</span><br><span class="line"></span><br><span class="line">#读取数据</span><br><span class="line">for data, label in data_iter():</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure></p>
<p>gluon 中提供了封装好的函数<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">batch_size = 10</span><br><span class="line">dataset = gluon.data.ArrayDataset(X, y)</span><br><span class="line">data_iter = gluon.data.DataLoader(dataset, batch_size, shuffle=True)</span><br><span class="line"></span><br><span class="line">#读取</span><br><span class="line">for data, label in data_iter:</span><br><span class="line">    print(data, label)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>batch_size 对模型的训练也有很大影响，详见：<a href="https://www.zhihu.com/question/32673260/answer/71137399">深度机器学习中的batch的大小对学习效果有何影响？</a></p>
</blockquote>
<p>使用 gluon 训练模型<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#定义一个空的模型</span><br><span class="line">net = gluon.nn.Sequential()</span><br><span class="line">#加入一个全连接层</span><br><span class="line">net.add(gluon.nn.Dense(1))</span><br><span class="line">#初始化模型参数</span><br><span class="line">net.initialize()</span><br><span class="line">#损失函数</span><br><span class="line">square_loss = gluon.loss.L2Loss()</span><br><span class="line">#优化</span><br><span class="line">trainer = gluon.Trainer(net.collect_params(),&#x27;sgd&#x27;,&#123;learning_rate:0.2&#125;)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里我们不需要定义层的输入节点是多少，节点数在读取数据的时候系统会自动赋值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#训练</span><br><span class="line">epochs = 10</span><br><span class="line">batch_size = 15</span><br><span class="line">for e in range(epochs):</span><br><span class="line">    total_loss = 0</span><br><span class="line">    for data, label in data_iter:</span><br><span class="line">        with autograd.record():</span><br><span class="line">            output = net(data)</span><br><span class="line">            loss = square_loss(output, label)</span><br><span class="line">        loss.backward()</span><br><span class="line">        #更新模型，因为拿到的是一个 batch_size 的梯度和，故最后还需除 batch_size</span><br><span class="line">        trainer.step(batch_size)</span><br><span class="line">        total_loss += nd.sum(loss).asscalar()</span><br><span class="line">    print(&quot;Epoch %d, average loss: %f&quot; % (e, total_loss/num_examples))</span><br></pre></td></tr></table></figure>
<p>可从 net 中拿到需要的层，然后访问其权重和位移<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dense = net[0]</span><br><span class="line">true_w, dense.weight.data()</span><br><span class="line">true_b, dense.bias.data()</span><br><span class="line">#拿到梯度</span><br><span class="line">dense.weight.grad()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Tips: 可通过 <code>help(functionName)</code> 来从 jupyter notebook 中查看函数的文档，通过 <code>functionName??</code> 可直接调出函数的源码</p>
</blockquote>
<h2 id="Softmax-Regression"><a href="#Softmax-Regression" class="headerlink" title="Softmax Regression"></a>Softmax Regression</h2><p>Softmax 函数<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def softmax(X):</span><br><span class="line">    exp = nd.exp(X)</span><br><span class="line">    # 假设exp是矩阵，这里对行进行求和，并要求保留axis 1，</span><br><span class="line">    # 就是返回 (nrows, 1) 形状的矩阵</span><br><span class="line">    partition = exp.sum(axis=1, keepdims=True)</span><br><span class="line">    return exp / partition</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，这样实现的 softmax 在后面求损失值时可能出现数值越界问题，解决方法详见博文末尾。</p>
</blockquote>
<p>定义模型：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def net(X):</span><br><span class="line">    return softmax(nd.dot(X.reshape((-1,num_inputs)), W) + b)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里 X.reshape() 第一个参数为 <code>-1</code> 表示该值可以由已知条件（这里是 num_inputs）推导出来</p>
</blockquote>
<p><strong>交叉熵损失函数</strong><br>这是针对概率值得损失函数，它将两个概率分布的负交叉熵作为目标值，最小化这个值等价于最大化这两个概率的相似度。</p>
<script type="math/tex; mode=display">J(\theta) = - \frac{1}{m} \sum^m_{i=1} y^{(i)}log(h_{\theta}(x^{(i)})) + (1 - y^{(i)})log(1 - h_{\theta}(x^{(i)}))</script><p>具体来说，我们先将真实标号表示成一个概率分布，例如如果 y=1，那么其对应的分布就是一个除了第二个元素为1其他全为 0 的长为 10 的向量，也就是 yvec = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]。那么交叉熵就是 yvec[0]*log(yhat[0])+…+yvec[n]*log(yhat[n])。注意到 yvec 里面只有一个 1，那么前面等价于 log(yhat[y])。所以我们可以定义这个损失函数了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def cross_entropy(yhat, y):</span><br><span class="line">    return - nd.pick(nd.log(yhat), y)</span><br></pre></td></tr></table></figure>
<p>gluon提供一个将这两个函数合起来的数值更稳定的版本<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">softmax_cross_entropy = gluon.loss.SoftmaxCrossEntropyLoss()</span><br></pre></td></tr></table></figure></p>
<p><strong>预测概率最高的类</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def accuracy(output, label):</span><br><span class="line">    return nd.mean(output.argmax(axis=1)==label).asscalar()</span><br><span class="line"></span><br><span class="line">    def evaluate_accuracy(data_iterator, net):</span><br><span class="line">        acc = 0.</span><br><span class="line">        for data, label in data_iterator:</span><br><span class="line">            output = net(data)</span><br><span class="line">            acc += accuracy(output, label)</span><br><span class="line">        return acc / len(data_iterator)</span><br></pre></td></tr></table></figure></p>
<h2 id="Softmax-与数值稳定性"><a href="#Softmax-与数值稳定性" class="headerlink" title="Softmax 与数值稳定性"></a>Softmax 与数值稳定性</h2><p>首先，Softmax 函数 $\sigma(z) = (\sigma_1(z),…,\sigma_m(z))$ 定义如下：</p>
<script type="math/tex; mode=display">
\sigma_i(z) = \frac{e^{z_i}}{\sum^m_{j=1}e^{z_j}}, i = 1,...,m</script><p>假设 $z_i = \omega^T_ix + b_i$ 是第 $i$ 类别的线性预测结果，则 Softmax 的结果其实就是先对每一个  $z_i$ 取 exponential 变成非负，然后除以所有项之和进行归一化。$\sigma_i(z)$ 可以解释为观察到的数据 $x$ 属于类别 $i$ 的概率， 或者称为似然(Likelihood)。</p>
<p>对这个函数求导的过程是这样的：<br>当 $i = j$ 时</p>
<script type="math/tex; mode=display">
\frac{\partial y_i}{\partial z_j} = \frac{\partial \frac{e^{z_i}}{\sum^m_{j=1}e^{z_j}}}{\partial z_j} = \frac{e^{z_i}\sum - e^{z_i} e^{z_j}}{\sum^2} = \frac{e^{z_i}}{\sum} \frac{\sum - e^{z_j}}{\sum} = y_i(1-y_j)</script><p>当 $i \neq j$ 时</p>
<script type="math/tex; mode=display">
\frac{\partial y_i}{\partial z_j} = \frac{\partial \frac{e^{z_i}}{\sum^m_{j=1}e^{z_j}}}{\partial z_j} = \frac{0 - e^{z_i} e^{z_j}}{\sum^2} = \frac{e^{z_i}}{\sum} \frac{e^{z_j}}{\sum} = y_iy_j</script><p>其中 $\sum = \sum^m_{j=1} e^{z_j}$</p>
<p>上面我们用 python 实现的 softmax 函数为：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def softmax(X):</span><br><span class="line">  exp = nd.exp(X)</span><br><span class="line">  partition = exp.sum(axis=1, keepdims=True)</span><br><span class="line">  return exp / partition</span><br></pre></td></tr></table></figure><br>注意到，当 x 很大时，exp(x) 会出现溢出的现象。一个简单的方法就是 x 乘以一个小的常数，将其缩放到一个合适的值。</p>
<script type="math/tex; mode=display">
y_i = \frac{e^{z_i}}{\sum^m_{j=1}e^{z_j}} = \frac{Ee^{z_i}}{\sum^m_{j=1}Ee^{z_j}} = \frac{e^{z_i + log(E)}}{\sum^m_{j=1}e^{z_j +  log(E)}} = \frac{e^{z_i + F}}{\sum^m_{j=1}e^{z_j +  F}}</script><p>其中，常数 $ F = -max(z_1,…,z_m)$ 可将所有值放缩在 0 附近。</p>
<p>但即使解决了 exp(x) 的数值溢出，在求导数的阶段还是有可能出现数值溢出的情况，一个更好的方法是使用 softmax-loss，详见 <a href="http://freemind.pluskid.org/machine-learning/softmax-vs-softmax-loss-numerical-stability/">Softmax vs. Softmax-Loss: Numerical Stability</a></p>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/27223959">Softmax函数与交叉熵</a></p>
<p><a href="http://freemind.pluskid.org/machine-learning/softmax-vs-softmax-loss-numerical-stability/">Softmax vs. Softmax-Loss: Numerical Stability</a></p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>MXNet/Gluon 深度学习笔记 (二)</title>
    <url>/Blog/2018/01/22/deep-learning-limu-note02/</url>
    <content><![CDATA[<p>本篇学习笔记主要介绍了正则化的贝叶斯解释、过拟合、Dropout、批量归一化、K 折交叉验证以及 MXNet 中 GPU 的使用。</p>
<h2 id="正则化的贝叶斯解释"><a href="#正则化的贝叶斯解释" class="headerlink" title="正则化的贝叶斯解释"></a>正则化的贝叶斯解释</h2><p>计算损失函数时加入　$L_2$ 范数正则化，那么最小化损失函数时实际上是在最小化：</p>
<script type="math/tex; mode=display">loss + \lambda \sum_{p \in params} ||p||^2_2</script><p>然而这个正则化项也可以在贝叶斯方法中得到解释。</p>
<p>统计学中有两个学派，一派叫做　Frequentiet （频率派），一派叫做　Bayesian （贝叶斯学派）。以线性回归为例，假设　$y_i = \omega x_i + noise$ ，noise 服从正态分布，均值 0 方差为 $\sigma^2$.</p>
<p>从贝叶斯的角度：<br>假设 $\omega$ 的 prior 是高斯 prior: $\omega \sim N(0, 1/\lambda)$，这里的 N 为高斯（正态）分布，因为有 MAP = ML * Proir (MAP: 最大先验概率，ML: 似然函数最大值)，所以由最大先验概率估计有：</p>
<script type="math/tex; mode=display">
\omega = argmax_{\omega} \mathcal{ln} \Pi^n_i \frac{1}{\sigma \sqrt(2\pi)} exp(-\frac{1}{2}(y_i-\omega^TX_i)^2)
   \Pi^n_j \frac{1}{\tau \sqrt(2\pi)} exp(-\frac{1}{2}(\frac{\omega_j}{\tau})^2)\\
 = -\frac{1}{2\sigma^2}\sum^n_i(y_i-\omega^TX_i)^2 - \frac{1}{2\tau^2}\sum^n_i\omega^2 - nln\sigma\sqrt{2\pi} - nln\tau\sqrt{2\pi}</script><span id="more"></span>
<p>去掉不影响估计 $\omega$ 的常数项，得：</p>
<script type="math/tex; mode=display">
\omega = argmax_{\omega}  \sum^n_i-(y_i-\omega^TX_i)^2 - \frac{\tau^2}{\sigma^2}\sum^n_j\omega^2</script><p>把负号去掉，即求 $\omega$ 也就是最小化 $\sum^n_i (y_i-\omega^TX_i)^2 + \lambda||\omega||^2$ (其中 $\lambda = \frac{\tau^2}{\sigma^2}$)</p>
<p>这就和频率学派说的直接最小化损失函数（最大似然估计）$\sum^n_i(y_i-\omega^T X_i)^2$ 然后再在后面加个 L2 范数正则化 $\lambda \omega^2$ 一样了。</p>
<p>故 $\lambda$ 来自贝叶斯先验，如果为 0 则没有先验。</p>
<blockquote>
<p>L2 正则化对应着高斯分布下的后验最大估计，L1 正则化对应着先验服从拉普拉斯分布下的后验最大估计。详见 <a href="http://charleshm.github.io/2016/03/Regularized-Regression/">Regularized Regression: A Bayesian point of view</a></p>
</blockquote>
<h2 id="如何应对过拟合现象"><a href="#如何应对过拟合现象" class="headerlink" title="如何应对过拟合现象"></a>如何应对过拟合现象</h2><p>过拟合（overfitting）是指在模型参数拟合过程中的问题，由于训练数据包含<strong>抽样误差</strong>，训练时，复杂的模型将抽样误差也考虑在内，将抽样误差也进行了很好的拟合。 具体表现就是最终模型在训练集上效果好，在测试集上效果差，模型泛化能力弱。</p>
<p>可以通过以下方法防止过拟合：</p>
<ul>
<li>获取更多数据<ul>
<li>从数据源头获取更多数据</li>
<li>根据当前数据集估计数据分布参数，使用该分布生成更多的数据</li>
<li>数据增强</li>
</ul>
</li>
<li>使用合适的模型<ul>
<li>降低网络复杂度，比如减少网络层数，神经元个数等限制网络的拟合能力</li>
<li>限制训练时间 （Early stoping）</li>
<li>正则化</li>
<li>增加噪音，可以在输入、权值和网络的响应上增加噪音</li>
</ul>
</li>
<li>结合多种模型<ul>
<li>Bagging, 用不同模型拟合不同部分的训练集</li>
<li>Boosting, 通过训练一系列简单的神经网络，加权平均其输出</li>
<li>Dropout, 训练是每次随机忽略隐层的默写节点，类似于集成了多个小模型</li>
</ul>
</li>
<li>贝叶斯方法</li>
</ul>
<p>参考：<a href="https://www.zhihu.com/question/59201590/answer/167392763">机器学习中用来防止过拟合的方法有哪些</a></p>
<h2 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h2><p>Dropout 是一种常见的应对过拟合的方法，通常是对输入层或者隐含层做以下操作：</p>
<ul>
<li>随机选择一部分该层的输出作为丢弃元素</li>
<li>把丢弃元素乘以0</li>
<li>把非丢弃元素拉伸</li>
</ul>
<p>实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropout</span>(<span class="params">X, drop_probability</span>):</span></span><br><span class="line">    keep_probability = <span class="number">1</span> - drop_probability</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt;= keep_probability &lt;= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 这种情况下把全部元素都丢弃。</span></span><br><span class="line">    <span class="keyword">if</span> keep_probability == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> X.zeros_like()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机选择一部分该层的输出作为丢弃元素。</span></span><br><span class="line">    mask = nd.random.uniform(</span><br><span class="line">        <span class="number">0</span>, <span class="number">1.0</span>, X.shape, ctx=X.context) &lt; keep_probability</span><br><span class="line">    <span class="comment"># 保证 E[dropout(X)] == X</span></span><br><span class="line">    scale =  <span class="number">1</span> / keep_probability</span><br><span class="line">    <span class="keyword">return</span> mask * X * scale</span><br></pre></td></tr></table></figure><br>Dropout 实际上是在模拟集成学习。我们在训练神经网络模型时一般随机采样一个批量的训练数据。Dropout 实质上是对每一个这样的数据集分别训练一个原神经网络子集的分类器。与一般的集成学习不同，这里每个原神经网络子集的分类器用的是同一套参数。因此丢弃法只是在模拟集成学习。</p>
<p>Dropout 神经网络子集的分类器在不同的训练数据批量上训练并使用同一套参数，因此，使用丢弃法的神经网络实质上是对输入层和隐含层的参数做了正则化：学到的参数使得原神经网络不同子集在训练数据上都尽可能表现良好。</p>
<p>注意， Dropout 只在训练的时候使用，在测试的时候不需要随机失活，但是对于两个隐层的输出都要乘以 p，调整其数值范围。因为在测试时所有的神经元都能看见它们的输入，因此我们想要神经元的输出与训练时的预期输出是一致的。基于这一点，实际上推荐使用 <strong>反向随机失活（invert dropout）</strong>，在训练时就进行数值范围调整，从而让前向传播在测试时保持不变，这也是上面实现中保证 E[dropout(X)] == X 之后代码的作用。</p>
<h2 id="批量归一化-Batch-Normalization"><a href="#批量归一化-Batch-Normalization" class="headerlink" title="批量归一化 (Batch Normalization)"></a>批量归一化 (Batch Normalization)</h2><p>在多层神经网路训练中，由于每一层的参数在训练时都是不断变化的，网络靠后的层所使用的激活函数的输入值可能由于乘法效应而变得极小或者极大，这种情况会造成模型训练的不稳定性。例如，给定一个学习率，某次参数迭代后，目标函数值会剧烈变化或甚至升高。这在数学上的解释是，如果把目标函数 $f$ 根据参数  $\omega$ 迭代（如 $f(\omega − \eta \Delta f(\omega))$ ）进行泰勒展开，有关学习率  $\eta$ 的高阶项的系数可能由于数量级的原因（通常由于层数多）而不容忽略。然而常用的低阶优化算法（如梯度下降）对于不断降低目标函 数的有效性通常基于一个基本假设：在以上泰勒展开中把有关学习率的高阶项通通忽略不计。</p>
<p>为了应对上述这种情况，Sergey Ioffe 和 Christian Szegedy 在 2015 年提出了批量归一化的方法。简而言之，在训练时给定一个批量输入，批量归一化试图对深度学习模型的某一层所使用的激活函数的输入进行归一化：<strong>使批量呈标准正态分布（均值为0，标准差为1）</strong>。</p>
<p>批量归一化通常应用于输入层或任意中间层。</p>
<p>Batch Normalization 具体实现如下:<br>给定一个批量 $B = {x_1,…,x_m}$, 我们需要学习拉升参数 $\gamma$ 和偏移参数 $\beta$<br>定义:</p>
<script type="math/tex; mode=display">\mu_B \leftarrow \frac{1}{m}\sum_{i = 1}^{m}x_i</script><script type="math/tex; mode=display">\sigma_B^2 \leftarrow \frac{1}{m} \sum_{i=1}^{m}(x_i - \mu_B)^2</script><script type="math/tex; mode=display">\hat{x_i} \leftarrow \frac{x_i - \mu_B}{\sqrt{\sigma_B^2 + \epsilon}}</script><script type="math/tex; mode=display">y_i \leftarrow \gamma \hat{x_i} + \beta \equiv \mbox{BN}_{\gamma,\beta}(x_i)</script><p>批量归一化层的输出是 ${y<em>i = BN</em>{\gamma, \beta}(x_i)}$。</p>
<p>python 实现如下:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pure_batch_norm</span>(<span class="params">X, gamma, beta, eps=<span class="number">1e-5</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(X.shape) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="comment"># 全连接: batch_size x feature</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(X.shape) == <span class="number">2</span>:</span><br><span class="line">        <span class="comment"># 每个输入维度在样本上的平均和方差</span></span><br><span class="line">        mean = X.mean(axis=<span class="number">0</span>)</span><br><span class="line">        variance = ((X - mean)**<span class="number">2</span>).mean(axis=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 2D卷积: batch_size x channel x height x width</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 对每个通道算均值和方差，需要保持4D形状使得可以正确地广播</span></span><br><span class="line">        mean = X.mean(axis=(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>), keepdims=<span class="literal">True</span>)</span><br><span class="line">        variance = ((X - mean)**<span class="number">2</span>).mean(axis=(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>), keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 均一化</span></span><br><span class="line">    X_hat = (X - mean) / nd.sqrt(variance + eps)</span><br><span class="line">    <span class="comment"># 拉升和偏移</span></span><br><span class="line">    <span class="keyword">return</span> gamma.reshape(mean.shape) * X_hat + beta.reshape(mean.shape)</span><br></pre></td></tr></table></figure><br>以上是模型训练时的实现，在测试时，我们还是需要使用批量归一化。但是考虑到只有一个测试数据的情况，具体实现和训练时有差别。</p>
<p>具体来说，在测试时，我们需要把原先训练时用到的批量均值和方差替换成整个训练数据的均值和方差。但 是当训练数据极大时，这个计算开销很大。因此，我们用移动平均的方法来近似计算。</p>
<p>同时考虑训练与测试时的批量归一化实现:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_norm</span>(<span class="params">X, gamma, beta, is_training, moving_mean, moving_variance,</span></span></span><br><span class="line"><span class="params"><span class="function">               eps = <span class="number">1e-5</span>, moving_momentum = <span class="number">0.9</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(X.shape) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="comment"># 全连接: batch_size x feature</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(X.shape) == <span class="number">2</span>:</span><br><span class="line">        <span class="comment"># 每个输入维度在样本上的平均和方差</span></span><br><span class="line">        mean = X.mean(axis=<span class="number">0</span>)</span><br><span class="line">        variance = ((X - mean)**<span class="number">2</span>).mean(axis=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 2D卷积: batch_size x channel x height x width</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 对每个通道算均值和方差，需要保持4D形状使得可以正确的广播</span></span><br><span class="line">        mean = X.mean(axis=(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>), keepdims=<span class="literal">True</span>)</span><br><span class="line">        variance = ((X - mean)**<span class="number">2</span>).mean(axis=(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>), keepdims=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 变形使得可以正确的广播</span></span><br><span class="line">        moving_mean = moving_mean.reshape(mean.shape)</span><br><span class="line">        moving_variance = moving_variance.reshape(mean.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 均一化</span></span><br><span class="line">    <span class="keyword">if</span> is_training:</span><br><span class="line">        X_hat = (X - mean) / nd.sqrt(variance + eps)</span><br><span class="line">        <span class="comment">#!!! 更新全局的均值和方差</span></span><br><span class="line">        moving_mean[:] = moving_momentum * moving_mean + (</span><br><span class="line">            <span class="number">1.0</span> - moving_momentum) * mean</span><br><span class="line">        moving_variance[:] = moving_momentum * moving_variance + (</span><br><span class="line">            <span class="number">1.0</span> - moving_momentum) * variance</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#!!! 测试阶段使用全局的均值和方差</span></span><br><span class="line">        X_hat = (X - moving_mean) / nd.sqrt(moving_variance + eps)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拉升和偏移</span></span><br><span class="line">    <span class="keyword">return</span> gamma.reshape(mean.shape) * X_hat + beta.reshape(mean.shape)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在实践中，使用了批量归一化的网络对于不好的初始值有更强的鲁棒性。批量归一化可以理解为在网络的每一层之前都做预处理，只是这种操作以另一种方式与网络集成在了一起。</p>
</blockquote>
<h2 id="K折交叉验证"><a href="#K折交叉验证" class="headerlink" title="K折交叉验证"></a>K折交叉验证</h2><p>过度依赖训练数据集的误差来推断测试数据集的误差容易导致过拟合。事实上，当我们调参时，往往需要基于K折交叉验证。</p>
<p>在 K 折交叉验证中，我们把初始采样分割成 K 个子样本，一个单独的子样本被保留作为验证模型的数据，其他 K−1 个样本用来训练，K 种不同验证子样本共训练 K 次，然后取 K 次验证模型的测试结果的平均值和训练误差的平均值。</p>
<p>实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_fold_cross_valid</span>(<span class="params">k, epochs, verbose_epoch, X_train, y_train,</span></span></span><br><span class="line"><span class="params"><span class="function">                       learning_rate, weight_decay</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> k &gt; <span class="number">1</span></span><br><span class="line">    fold_size = X_train.shape[<span class="number">0</span>] // k</span><br><span class="line">    train_loss_sum = <span class="number">0.0</span></span><br><span class="line">    test_loss_sum = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> test_i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        X_val_test = X_train[test_i * fold_size: (test_i + <span class="number">1</span>) * fold_size, :]</span><br><span class="line">        y_val_test = y_train[test_i * fold_size: (test_i + <span class="number">1</span>) * fold_size]</span><br><span class="line"></span><br><span class="line">        val_train_defined = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">if</span> i != test_i:</span><br><span class="line">                X_cur_fold = X_train[i * fold_size: (i + <span class="number">1</span>) * fold_size, :]</span><br><span class="line">                y_cur_fold = y_train[i * fold_size: (i + <span class="number">1</span>) * fold_size]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> val_train_defined:</span><br><span class="line">                    X_val_train = X_cur_fold</span><br><span class="line">                    y_val_train = y_cur_fold</span><br><span class="line">                    val_train_defined = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    X_val_train = nd.concat(X_val_train, X_cur_fold, dim=<span class="number">0</span>)</span><br><span class="line">                    y_val_train = nd.concat(y_val_train, y_cur_fold, dim=<span class="number">0</span>)</span><br><span class="line">        net = get_net()</span><br><span class="line">        train_loss, test_loss = train(</span><br><span class="line">            net, X_val_train, y_val_train, X_val_test, y_val_test,</span><br><span class="line">            epochs, verbose_epoch, learning_rate, weight_decay)</span><br><span class="line">        train_loss_sum += train_loss</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Test loss: %f&quot;</span> % test_loss)</span><br><span class="line">        test_loss_sum += test_loss</span><br><span class="line">    <span class="keyword">return</span> train_loss_sum / k, test_loss_sum / k</span><br></pre></td></tr></table></figure></p>
<h2 id="使用-GPU"><a href="#使用-GPU" class="headerlink" title="使用 GPU"></a>使用 GPU</h2><p>Linux 下使用 <code>!nvidia-smi</code> 可查看 GPU状态。</p>
<p><strong>Context</strong><br>MXNet 使用 Context 来指定使用哪个设备来存储和计算。默认会将数据开在主内存，然后利用 CPU 来计算，这个由 <code>mx.cpu()</code> 来表示。GPU 则由 <code>mx.gpu()</code> 来表示。注意 <code>mx.cpu()</code> 表示所有的物理 CPU 和内存，意味着计算上会尽量使用多有的 CPU 核。但 <code>mx.gpu()</code> 只代表一块显卡和其对应的显卡内存。如果有多块 GPU，用 <code>mx.gpu(i)</code> 来表示第 i 块 GPU（ i 从 0 开始）。</p>
<p><strong>创建内存</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = nd.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], ctx=mx.gpu())</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>copyto</code> 和 <code>as_in_context</code> 来在设备直接传输数据。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = x.copyto(mx.gpu())</span><br><span class="line">z = x.as_in_context(mx.gpu())</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这两个函数的主要区别是，如果源和目标的 context 一致，<code>as_in_context</code> 不复制，而 <code>copyto</code> 总是会新建内存。</p>
</blockquote>
<p><strong>计算</strong></p>
<p>计算会在数据的 context 上执行。所以为了使用 GPU，只需要事先将数据放在上面就行了。结果会自动保存在对应的设备上。注意 MXNet 中所有计算要求输入数据在同一个设备上，不一致的时候系统不进行自动复制。这个设计的目的是因为设备之间的数据交互通常比较昂贵，作者希望用户确切的知道数据放在哪里，而不是隐藏这个细节。</p>
<p>如果某个操作需要将 GPU 里面的内容转出来，例如打印或变成 numpy 格式，如果需要的话系统都会自动将数据 copy 到主内存。</p>
<p>Gluon的大部分函数可以通过ctx指定设备。下面代码将模型参数初始化在GPU上：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> gluon</span><br><span class="line">net = gluon.nn.Sequential()</span><br><span class="line">net.add(gluon.nn.Dense(<span class="number">1</span>))</span><br><span class="line">net.initialize(ctx=mx.gpu())</span><br></pre></td></tr></table></figure></p>
<h3 id="多-GPU-的使用"><a href="#多-GPU-的使用" class="headerlink" title="多 GPU 的使用"></a>多 GPU 的使用</h3><p><strong>数据并行</strong></p>
<p>数据并行目前是深度学习里面使用最广泛的用来将任务划分到多设备的办法。它是这样工作的：假设这里有 k 个 GPU，每个 GPU 将维护一个模型参数的复制。然后每次我们将一个批量里面的样本划分成 k 块并分每个 GPU 一块。每个 GPU 使用分到的数据计算梯度。然后我们将所有 GPU 上梯度相加得到这个批量上的完整梯度。之后每个 GPU 使用这个完整梯度对自己维护的模型做更新。</p>
<p><strong>在多GPU之间同步数据</strong><br>用一个实例介绍</p>
<p>将模型参数复制到某个特定设备并初始化梯度：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> gpu</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_params</span>(<span class="params">params, ctx</span>):</span></span><br><span class="line">    new_params = [p.copyto(ctx) <span class="keyword">for</span> p <span class="keyword">in</span> params]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> new_params:</span><br><span class="line">        p.attach_grad()</span><br><span class="line">    <span class="keyword">return</span> new_params</span><br></pre></td></tr></table></figure><br>给定分布在多个 GPU 之间数据，定义一个函数它将这些数据加起来，然后再广播到所有 GPU 上：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allreduce</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="comment"># sum on data[0].context, and then broadcast</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(data)):</span><br><span class="line">        data[<span class="number">0</span>][:] += data[i].copyto(data[<span class="number">0</span>].context)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(data)):</span><br><span class="line">        data[<span class="number">0</span>].copyto(data[i])</span><br></pre></td></tr></table></figure><br>最后给定一个批量，我们划分它并复制到各个GPU上：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_and_load</span>(<span class="params">data, ctx</span>):</span></span><br><span class="line">    n, k = data.shape[<span class="number">0</span>], <span class="built_in">len</span>(ctx)</span><br><span class="line">    m = n // k</span><br><span class="line">    <span class="keyword">assert</span> m * k == n, <span class="string">&#x27;# examples is not divided by # devices&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> [data[i*m:(i+<span class="number">1</span>)*m].as_in_context(ctx[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br></pre></td></tr></table></figure><br>现在我们可以实现如何使用数据并行在多个GPU上训练一个批量了:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;..&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> utils</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_batch</span>(<span class="params">data, label, params, ctx, lr</span>):</span></span><br><span class="line">    <span class="comment"># split the data batch and load them on GPUs</span></span><br><span class="line">    data_list = split_and_load(data, ctx)</span><br><span class="line">    label_list = split_and_load(label, ctx)</span><br><span class="line">    <span class="comment"># run forward on each GPU</span></span><br><span class="line">    <span class="keyword">with</span> autograd.record():</span><br><span class="line">        losses = [loss(lenet(X, W), Y)</span><br><span class="line">                  <span class="keyword">for</span> X, Y, W <span class="keyword">in</span> <span class="built_in">zip</span>(data_list, label_list, params)]</span><br><span class="line">    <span class="comment"># run backward on each gpu</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> losses:</span><br><span class="line">        l.backward()</span><br><span class="line">    <span class="comment"># aggregate gradient over GPUs</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(params[<span class="number">0</span>])):</span><br><span class="line">        allreduce([params[c][i].grad <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ctx))])</span><br><span class="line">    <span class="comment"># update parameters with SGD on each GPU</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> params:</span><br><span class="line">        utils.SGD(p, lr/data.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><br>训练函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">num_gpus, batch_size, lr</span>):</span></span><br><span class="line">    train_data, test_data = utils.load_data_fashion_mnist(batch_size)</span><br><span class="line"></span><br><span class="line">    ctx = [gpu(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_gpus)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Running on&#x27;</span>, ctx)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># copy parameters to all GPUs</span></span><br><span class="line">    dev_params = [get_params(params, c) <span class="keyword">for</span> c <span class="keyword">in</span> ctx]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="comment"># train</span></span><br><span class="line">        start = time()</span><br><span class="line">        <span class="keyword">for</span> data, label <span class="keyword">in</span> train_data:</span><br><span class="line">            train_batch(data, label, dev_params, ctx, lr)</span><br><span class="line">        nd.waitall()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch %d, training time = %.1f sec&#x27;</span>%(</span><br><span class="line">            epoch, time()-start))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># validating on GPU 0</span></span><br><span class="line">        net = <span class="keyword">lambda</span> data: lenet(data, dev_params[<span class="number">0</span>])</span><br><span class="line">        test_acc = utils.evaluate_accuracy(test_data, net, ctx[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;validation accuracy = %.4f&#x27;</span>%(test_acc))</span><br></pre></td></tr></table></figure></p>
<h2 id="多机器分布式训练"><a href="#多机器分布式训练" class="headerlink" title="多机器分布式训练"></a>多机器分布式训练</h2><p>详见：<a href="https://docs.aws.amazon.com/mxnet/latest/dg/mxnet-on-ec2-cluster.html">Set Up a Stack for Distributed Deep Learning Using Apache MXNet</a></p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>MXNet/Gluon 深度学习笔记 (三) —— 卷积神经网络模型整理</title>
    <url>/Blog/2018/01/28/deep-learning-limu-note03/</url>
    <content><![CDATA[<p>在神经网络火起来之前，特征表示这步都是基于硬拼出来的直觉，机械化手工地生成。做出一组特征，改进结果，并把方法写出来是计算机视觉论文里的一个重要流派。</p>
<p>然而另一些人则认为特征本身是可以学习而来的，他们还相信，为了表征足够复杂的输入，特征本身应该阶级式地组合起来。持这一想法的研究者们，<br>包括 Yann LeCun，Geoff Hinton，Yoshua Bengio，Andrew Ng，Shun-ichi Amari，Juergen Schmidhuber，相信通过把许多神经网络层组合起来训练，<br>他们可能可以让网络学得阶级式的数据表征。在图片中，底层可以表示边，色彩和纹理。</p>
<div align="center">
  <img src="/Blog/.io//deep-learning-limu-note03-02.png">
  <p>网络提取的特征</p>
</div>

<p>高层可能可以基于这些表示，来表征更大的结构，如眼睛，鼻子，草叶和其他特征。更高层可能可以表征整个物体，如人，飞机，狗，飞盘。最终，在分类器层前的隐含层可能会表征经过汇总的内容，其中不同的类别将会是线性可分的。然而许多年来，研究者们由于缺乏大规模的数据，计算力不行等原因未能实现这一愿景。</p>
<span id="more"></span>
<p>这一状况直到 ImageNet 的出现以及现代计算机算力的迅速增长而改变，从而开启了深度学习的时代。本篇博文根据 MXNet/Gluon 的视频教程，整理了近些年曾“呼风唤雨”过的神经网络模型。</p>
<h2 id="CNN-简介"><a href="#CNN-简介" class="headerlink" title="CNN 简介"></a>CNN 简介</h2><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>卷积神经网络是主要由卷积层构成的神经网络。卷积层跟全连接层类似，但输入和权重不是做简单的矩阵乘法，而是使用每次作用在一个窗口上的卷积。下图演示了输入是一个 5×5 矩阵，进行 1 单位的填充，使用一个 3×3 的权重，步长为 2，计算得到 3×3 结果的过程。每次采样一个跟权重一样大小的窗口，让它跟权重做按元素（element-wise）的乘法然后相加, 通常也把这个权重叫 kernel 或者 filter。</p>
<div align="center">
  <img src="/Blog/.io//deep-learning-limu-note03-01.gif">
  <p>卷积操作示意图</p>
</div>

<p>当输入有多个通道时，每个通道都会有对应的权重，然后会对每个通道做卷积之后在通道之间求和</p>
<script type="math/tex; mode=display">conv(data,w,b) = \sum_i conv(data[:,i,:,:], w[:,1,:,:],b)</script><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p>因为卷积层每次作用在一个窗口，它对位置很敏感。池化层能够很好的缓解这个问题。它跟卷积类似每次作用一个小窗口，然后选出窗口里面最大的元素，或者平均元素作为输出。</p>
<h3 id="使用-Gluon-定义模型"><a href="#使用-Gluon-定义模型" class="headerlink" title="使用 Gluon 定义模型"></a>使用 Gluon 定义模型</h3><p>下面是 leNet 的 Gluon 实现<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line">net = nn.Sequential()</span><br><span class="line"><span class="keyword">with</span> net.name_scope():</span><br><span class="line">    net.add(</span><br><span class="line">        nn.Conv2D(channels=<span class="number">20</span>, kernel_size=<span class="number">5</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        nn.MaxPool2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>),</span><br><span class="line">        nn.Conv2D(channels=<span class="number">50</span>, kernel_size=<span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        nn.MaxPool2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>),</span><br><span class="line">        nn.Flatten(),</span><br><span class="line">        nn.Dense(<span class="number">128</span>, activation=<span class="string">&quot;relu&quot;</span>),</span><br><span class="line">        nn.Dense(<span class="number">10</span>)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><br>LeNet 模型结构</p>
<div align="center">
  <img src="/Blog/.io//deep-learning-limu-note03-04.jpg">
  <p>卷积操作示意图</p>
</div>

<h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><p>2012年，Khrizhevsky，Sutskever 和 Hinton 凭借他们的 cuda-convnet 实现的 8 层卷积神经网络以很大的优势赢得了 ImageNet 2012 图像识别挑战。<br>他们在这篇论文中的模型与 1995 年的 LeNet 结构非常相似。</p>
<p>AlexNet 模型有一些显著的特征。第一，与相对较小的 LeNet 相比，AlexNet 包含 8 层变换，其中有五层卷积和两层全连接隐含层，以及一个输出层。</p>
<p>第一层中的卷积核大小是 11×11 ，接着第二层中的是 5×5，之后都是 3×3。此外，第一，第二和第五个卷积层之后都有重叠的大小为 3×3，步距为 2×2 的池化操作。</p>
<p>紧接着卷积层，原版的 AlexNet 有每层大小为 4096 个节点的全连接层。这两个巨大的全连接层带来将近 1GB 的模型大小。由于早期GPU显存的限制，最早的AlexNet包括了双数据流的设计，以让网络中一半的节点能存入一个GPU。这两个数据流，也就是说两个GPU只在一部分层进行通信，这样达到限制GPU同步时的额外开销的效果。幸运的是，GPU在过去几年得到了长足的发展，除了一些特殊的结构外，我们也就不再需要这样的特别设计了。</p>
<div align="center">
  <img src="/Blog/.io//deep-learning-limu-note03-05.jpg">
  <p>AlexNet 结构示意图</p>
</div>

<p>下面是用 Gluon 实现的简化版 AlexNet:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line">net = nn.Sequential()</span><br><span class="line"><span class="keyword">with</span> net.name_scope():</span><br><span class="line">    net.add(</span><br><span class="line">        <span class="comment"># 第一阶段</span></span><br><span class="line">        nn.Conv2D(channels=<span class="number">96</span>, kernel_size=<span class="number">11</span>, strides=<span class="number">4</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>),</span><br><span class="line">        <span class="comment"># 第二阶段</span></span><br><span class="line">        nn.Conv2D(channels=<span class="number">256</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>),</span><br><span class="line">        <span class="comment"># 第三阶段</span></span><br><span class="line">        nn.Conv2D(channels=<span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        nn.Conv2D(channels=<span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        nn.Conv2D(channels=<span class="number">256</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>),</span><br><span class="line">        <span class="comment"># 第四阶段</span></span><br><span class="line">        nn.Flatten(),</span><br><span class="line">        nn.Dense(<span class="number">4096</span>, activation=<span class="string">&quot;relu&quot;</span>),</span><br><span class="line">        nn.Dropout(<span class="number">.5</span>),</span><br><span class="line">        <span class="comment"># 第五阶段</span></span><br><span class="line">        nn.Dense(<span class="number">4096</span>, activation=<span class="string">&quot;relu&quot;</span>),</span><br><span class="line">        nn.Dropout(<span class="number">.5</span>),</span><br><span class="line">        <span class="comment"># 第六阶段</span></span><br><span class="line">        nn.Dense(<span class="number">10</span>)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>从LeNet到Alexnet，虽然实现起来也就多了几行而已。但这个观念上的转变和真正跑出好实验结果，学术界整整花了20年。</p>
</blockquote>
<h2 id="VGG-Net"><a href="#VGG-Net" class="headerlink" title="VGG Net"></a>VGG Net</h2><p>VGG Net 全称 very deep convolutional networks。 顾名思义， VGG 比之前的网络都要深。此外，VGG 也是第一个在网络结构中使用大量重复结构的模型，这使得 VGG 的编程构造异常紧凑。VGG的一个关键是使用很多有着相对小的kernel（ 3×33×3 ）的卷积层然后接上一个池化层，之后再将这个模块重复多次。<br>以下是一个 VGG 块的定义<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vgg_block</span>(<span class="params">num_convs, channels</span>):</span></span><br><span class="line">    out = nn.Sequential()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_convs):</span><br><span class="line">        out.add(</span><br><span class="line">            nn.Conv2D(channels=channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        )</span><br><span class="line">    out.add(nn.MaxPool2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><br>然后将这些块堆起来：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vgg_stack</span>(<span class="params">architecture</span>):</span></span><br><span class="line">  out = nn.Sequential()</span><br><span class="line">  <span class="keyword">for</span> (num_convs, channels) <span class="keyword">in</span> architecture:</span><br><span class="line">        out.add(vgg_block(num_convs, channels))</span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><br>这里定义一个最简单的一个 VGG 结构，它有 8 个卷积层，和跟 Alexnet 一样的 3 个全连接层。这个网络又称 VGG 11. (更改不同的 architecture 就可以实现不同的 VGG)<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_outputs = <span class="number">10</span></span><br><span class="line">architecture_vgg11 = ((<span class="number">1</span>,<span class="number">64</span>), (<span class="number">1</span>,<span class="number">128</span>), (<span class="number">2</span>,<span class="number">256</span>), (<span class="number">2</span>,<span class="number">512</span>), (<span class="number">2</span>,<span class="number">512</span>))</span><br><span class="line"><span class="comment">#architecture_vgg16 = ((2,64), (2,128), (3,256), (3,512), (3,512))</span></span><br><span class="line"><span class="comment">#architecture_vgg19 = ((2,64), (2,128), (4,256), (4,512), (4,512))</span></span><br><span class="line">net = nn.Sequential()</span><br><span class="line"><span class="comment"># add name_scope on the outermost Sequential</span></span><br><span class="line"><span class="keyword">with</span> net.name_scope():</span><br><span class="line">    net.add(</span><br><span class="line">        vgg_stack(architecture_vgg11),</span><br><span class="line">        nn.Flatten(),</span><br><span class="line">        nn.Dense(<span class="number">4096</span>, activation=<span class="string">&quot;relu&quot;</span>),</span><br><span class="line">        nn.Dropout(<span class="number">.5</span>),</span><br><span class="line">        nn.Dense(<span class="number">4096</span>, activation=<span class="string">&quot;relu&quot;</span>),</span><br><span class="line">        nn.Dropout(<span class="number">.5</span>),</span><br><span class="line">        nn.Dense(num_outputs))</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>通过使用重复的元素，可以利用循环和函数来定义模型。使用不同的配置(architecture)可以得到一系列不同的模型。</p>
</blockquote>
<p>论文中，作者提及的其他几种 VGG 的模型，如下表所示：</p>
<div align="center">
  <img src="/Blog/.io//deep-learning-limu-note03-06.png">
  <p>VGG 网络结构</p>
</div>

<h2 id="Net-in-Net"><a href="#Net-in-Net" class="headerlink" title="Net in Net"></a>Net in Net</h2><p>Alexnet之后一个重要的工作是 <a href="https://arxiv.org/abs/1312.4400">Network in Network（NiN）</a>，这篇论文提出的两个想法影响了后面的网络设计。</p>
<p>这之前的神经网络结构一般分为两块，一块主要由卷积层构成，另一块主要是全连接层。在 Alexnet 里我们看到如何把卷积层块和全连接层分别加深加宽从而得到深度网络。另外一个自然的想法是，我们可以串联数个卷积层块和全连接层块来构建深度网络。</p>
<div align="center">
  <img src="/Blog/.io//deep-learning-limu-note03-07.svg">
  <p> </p>
</div>

<p>不过这里有个难题， 卷记得输入输出都是 4D 矩阵，然而全连接层是 2D 的。 如果将 4D 矩阵转成 2D 做全连接，则会导致全连接层有过多的参数。NiN 提出<strong>只对通道层做全连接</strong>并且像素之间<strong>共享权重</strong>来解决上述问题，也就是说，我们使用的 kernel 大小为 1x1 的卷积。</p>
<div align="center">
  <img src="/Blog/.io//deep-learning-limu-note03-08.png">
  <p>Network in Network</p>
</div>

<p>下面的代码定义了一个模块，它由一个正常的卷积层接上两个 kernel 为 1x1 的卷积层构成，后面两个卷积层充当了两个全连接的角色。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mlpconv</span>(<span class="params">channels, kernel_size, padding,</span></span></span><br><span class="line"><span class="params"><span class="function">            strides=<span class="number">1</span>, max_pooling=<span class="literal">True</span></span>):</span></span><br><span class="line">    out = nn.Sequential()</span><br><span class="line">    out.add(</span><br><span class="line">        nn.Conv2D(channels=channels, kernel_size=kernel_size, strides=strides,</span><br><span class="line">            padding=padding, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        <span class="comment">#充当全连接层</span></span><br><span class="line">        nn.Conv2D(channels=channels, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>, strides=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        nn.Conv2D(channels=channels, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>, strides=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> max_pooling:</span><br><span class="line">        out.add(nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><br>NiN 的卷积层的参数跟Alexnet类似，使用三组不同的设定</p>
<ul>
<li>kernel: $11\times 11$, channels: 96</li>
<li>kernel: $5\times 5$, channels: 256</li>
<li>kernel: $3\times 3$, channels: 384</li>
</ul>
<p>除了使用了$1\times 1$卷积外，NiN在最后不是使用全连接，而是使用通道数为输出类别个数的 <code>mlpconv</code>，外接一个<strong>平均池化层</strong>来将每个通道里的数值平均成一个标量。</p>
<blockquote>
<p><strong>平均池化层</strong>: 将每个通道里的数值平均成一个标量来代替全连接层，大大减少了计算量。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential()</span><br><span class="line"><span class="comment"># add name_scope on the outer most Sequential</span></span><br><span class="line"><span class="keyword">with</span> net.name_scope():</span><br><span class="line">    net.add(</span><br><span class="line">        mlpconv(<span class="number">96</span>, <span class="number">11</span>, <span class="number">0</span>, strides=<span class="number">4</span>),</span><br><span class="line">        mlpconv(<span class="number">256</span>, <span class="number">5</span>, <span class="number">2</span>),</span><br><span class="line">        mlpconv(<span class="number">384</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">        nn.Dropout(<span class="number">.5</span>),</span><br><span class="line">        <span class="comment"># 目标类为10类</span></span><br><span class="line">        mlpconv(<span class="number">10</span>, <span class="number">3</span>, <span class="number">1</span>, max_pooling=<span class="literal">False</span>),</span><br><span class="line">        <span class="comment"># 输入为 batch_size x 10 x 5 x 5, 通过AvgPool2D转成</span></span><br><span class="line">        <span class="comment"># batch_size x 10 x 1 x 1。</span></span><br><span class="line">        nn.AvgPool2D(pool_size=<span class="number">5</span>),</span><br><span class="line">        <span class="comment"># 转成 batch_size x 10</span></span><br><span class="line">        nn.Flatten()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种“一卷卷到底”最后加一个平均池化层的做法也成为了深度卷积神经网络的常用设计。</p>
</blockquote>
<p><strong>关于 1x1 卷积的理解</strong></p>
<p>1x1卷积实际上是对每个像素点，在不同的 channels 上进行线性组合（信息整合），且保留了图片的原有平面结构，调控depth，从而完成升维或降维的功能。如下图所示，左边选择 2 个 filters 的 1x1 卷积，将原来的 depth = 3 降维为 2， 右边使用 4 个 filters 的 1x1 卷积， 将原来的 depth = 3 升维为 4。</p>
<div align="center">
  <img src="/Blog/.io//deep-learning-limu-note03-09.png">
  <p>1x1 卷积理解</p>
</div>

<p>图片来源：<a href="https://zhuanlan.zhihu.com/p/27642620">YJango的卷积神经网络——介绍</a></p>
<p><strong>为什么mlpconv里面要有两个 1×1 卷积？</strong></p>
<p>传统的卷积层可以看做一种广义的线性模型，如果提取到的特征线性可分，则传统的 CNN 对特征的抽象已经很充足了；但是，好的抽象特征一般需要对输入的数据做高低的非线性变换。因此以往的 CNN 有两个做法，一个是在同一层使用多个通道覆盖同一输入块（input data patch）特征的所有 variations (信息冗余，弥补了线性变换的不足)，另外就是多个卷积层的堆叠来获得比前层特征的更高抽象（特征抽象，同时获得更大的感受野）。这种操作会使得参数和计算量增加的太快。</p>
<p>因此，作者利用 1x1 的 kernel 来模拟这种操作，即实现了上述两个目的，又减少了参数的数量和计算量。<br>mlpconv 中第一个 1x1 的卷积层可以看做对前一层的所有 feature map 信息进行线性组合，可以看做一种在 channels 上的全连接层，再使用 Relu 进行非线性变换，就实现了一次特征的整合和非线性抽象。但是这与传统的卷积层没有什么区别，因此作者又加了一个同样的 1x1 卷积层，这样就实现了对输入数据进行高度的非线性变换的目的。</p>
<p>[From <a href="https://discuss.gluon.ai/t/topic/1661">网络中的网络 讨论区</a>]</p>
<h2 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h2><p>在 2014 年的 Imagenet 竞赛里，Google 的研究人员利用一个新的网络结构取得很大的优先。这个叫做 GoogLeNet 的网络虽然在名字上是向LeNet致敬，但网络结构里很难看到 LeNet 的影子。它颠覆的大家对卷积神经网络串联一系列层的固定做法。下图是其<a href="https://arxiv.org/abs/1409.4842">论文</a>对 GoogLeNet 的可视化:</p>
<div align="center">
  <img src="/Blog/.io//deep-learning-limu-note03-10.png">
  <p>GoogLeNet</p>
</div>

<h3 id="Inception"><a href="#Inception" class="headerlink" title="Inception"></a>Inception</h3><p>GoogLeNet 虽然复杂，但却有规可循。可以看到其结构有很多个四个并行卷积层的块，这个块一般叫做 Inception，它基于 NiN 的思想，当做了很大的改进。其结构如下图所示：</p>
<div align="center">
  <img src="/Blog/.io//deep-learning-limu-note03-11.svg">
  <p>Inception</p>
</div>

<p>可以看到 Inception 里有四个并行的线路。</p>
<ol>
<li>单个 $1\times 1$ 卷积。</li>
<li>$1\times 1$ 卷积接上 $3\times 3$ 卷积。通常前者的通道数少于输入通道，这样减少后者的计算量。后者加上了<code>padding=1</code>使得输出的长宽的输入一致</li>
<li>同 2，但换成了 $5 \times 5$ 卷积</li>
<li>和 1 类似，但卷积前用了最大池化层</li>
</ol>
<p>最后将这四个并行线路的结果在通道这个维度上合并在一起。</p>
<p>实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inception</span>(<span class="params">nn.Block</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n1_1, n2_1, n2_3, n3_1, n3_5, n4_1, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Inception, self).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># path 1</span></span><br><span class="line">        self.p1_conv_1 = nn.Conv2D(n1_1, kernel_size=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        <span class="comment"># path 2</span></span><br><span class="line">        self.p2_conv_1 = nn.Conv2D(n2_1, kernel_size=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p2_conv_3 = nn.Conv2D(n2_3, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        <span class="comment"># path 3</span></span><br><span class="line">        self.p3_conv_1 = nn.Conv2D(n3_1, kernel_size=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        self.p3_conv_5 = nn.Conv2D(n3_5, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">        <span class="comment"># path 4</span></span><br><span class="line">        self.p4_pool_3 = nn.MaxPool2D(pool_size=<span class="number">3</span>, padding=<span class="number">1</span>, strides=<span class="number">1</span>)</span><br><span class="line">        self.p4_conv_1 = nn.Conv2D(n4_1, kernel_size=<span class="number">1</span>, activation=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        p1 = self.p1_conv_1(x)</span><br><span class="line">        p2 = self.p2_conv_3(self.p2_conv_1(x))</span><br><span class="line">        p3 = self.p3_conv_5(self.p3_conv_1(x))</span><br><span class="line">        p4 = self.p4_conv_1(self.p4_pool_3(x))</span><br><span class="line">        <span class="keyword">return</span> nd.concat(p1, p2, p3, p4, dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="定义GoogLeNet"><a href="#定义GoogLeNet" class="headerlink" title="定义GoogLeNet"></a>定义GoogLeNet</h3><p>GoogLeNet将数个Inception串联在一起。注意到原论文里使用了多个输出，为了简化我们这里就使用一个输出。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoogLeNet</span>(<span class="params">nn.Block</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_classes, verbose=<span class="literal">False</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(GoogLeNet, self).__init__(**kwargs)</span><br><span class="line">        self.verbose = verbose</span><br><span class="line">        <span class="comment"># add name_scope on the outer most Sequential</span></span><br><span class="line">        <span class="keyword">with</span> self.name_scope():</span><br><span class="line">            <span class="comment"># block 1</span></span><br><span class="line">            b1 = nn.Sequential()</span><br><span class="line">            b1.add(</span><br><span class="line">                nn.Conv2D(<span class="number">64</span>, kernel_size=<span class="number">7</span>, strides=<span class="number">2</span>,</span><br><span class="line">                          padding=<span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">                nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># block 2</span></span><br><span class="line">            b2 = nn.Sequential()</span><br><span class="line">            b2.add(</span><br><span class="line">                nn.Conv2D(<span class="number">64</span>, kernel_size=<span class="number">1</span>),</span><br><span class="line">                nn.Conv2D(<span class="number">192</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">                nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="comment"># block 3</span></span><br><span class="line">            b3 = nn.Sequential()</span><br><span class="line">            b3.add(</span><br><span class="line">                Inception(<span class="number">64</span>, <span class="number">96</span>, <span class="number">128</span>, <span class="number">16</span>,<span class="number">32</span>, <span class="number">32</span>),</span><br><span class="line">                Inception(<span class="number">128</span>, <span class="number">128</span>, <span class="number">192</span>, <span class="number">32</span>, <span class="number">96</span>, <span class="number">64</span>),</span><br><span class="line">                nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="comment"># block 4</span></span><br><span class="line">            b4 = nn.Sequential()</span><br><span class="line">            b4.add(</span><br><span class="line">                Inception(<span class="number">192</span>, <span class="number">96</span>, <span class="number">208</span>, <span class="number">16</span>, <span class="number">48</span>, <span class="number">64</span>),</span><br><span class="line">                Inception(<span class="number">160</span>, <span class="number">112</span>, <span class="number">224</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">64</span>),</span><br><span class="line">                Inception(<span class="number">128</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">64</span>),</span><br><span class="line">                Inception(<span class="number">112</span>, <span class="number">144</span>, <span class="number">288</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">64</span>),</span><br><span class="line">                Inception(<span class="number">256</span>, <span class="number">160</span>, <span class="number">320</span>, <span class="number">32</span>, <span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">                nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="comment"># block 5</span></span><br><span class="line">            b5 = nn.Sequential()</span><br><span class="line">            b5.add(</span><br><span class="line">                Inception(<span class="number">256</span>, <span class="number">160</span>, <span class="number">320</span>, <span class="number">32</span>, <span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">                Inception(<span class="number">384</span>, <span class="number">192</span>, <span class="number">384</span>, <span class="number">48</span>, <span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">                nn.AvgPool2D(pool_size=<span class="number">2</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># block 6</span></span><br><span class="line">            b6 = nn.Sequential()</span><br><span class="line">            b6.add(</span><br><span class="line">                nn.Flatten(),</span><br><span class="line">                nn.Dense(num_classes)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># chain blocks together</span></span><br><span class="line">            self.net = nn.Sequential()</span><br><span class="line">            self.net.add(b1, b2, b3, b4, b5, b6)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = x</span><br><span class="line">        <span class="keyword">for</span> i, b <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.net):</span><br><span class="line">            out = b(out)</span><br><span class="line">            <span class="keyword">if</span> self.verbose:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Block %d output: %s&#x27;</span>%(i+<span class="number">1</span>, out.shape))</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>GoogLeNet 加入了更加结构化的 Inception 块来使得我们可以使用更大的通道，更多的层，同时控制计算量和模型大小在合理范围内。</p>
</blockquote>
<h3 id="其他改进"><a href="#其他改进" class="headerlink" title="其他改进"></a>其他改进</h3><p>GoogLeNet有数个后续版本</p>
<ul>
<li>v1: 本节介绍的是最早版本：<a href="http://arxiv.org/abs/1409.4842">Going Deeper with Convolutions</a></li>
<li>v2: 加入和Batch Normalization：<a href="http://arxiv.org/abs/1502.03167">Accelerating Deep Network Training by Reducing Internal Covariate Shift</a></li>
<li>v3: 对 Inception 做了调整：<a href="http://arxiv.org/abs/1512.00567">Rethinking the Inception Architecture for Computer Vision</a></li>
<li>v4: 基于 ResNe t加入了 Residual Connections：<a href="http://arxiv.org/abs/1602.07261">Inception-ResNet and the Impact of Residual Connections on Learning</a></li>
</ul>
<h2 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h2><p>当大家还在惊叹 GoogLeNet 用结构化的连接纳入了大量卷积层的时候，微软亚洲研究院的研究员已经在设计更深但结构更简单的网络<a href="https://arxiv.org/abs/1512.03385">ResNet</a>。他们凭借这个网络在 2015 年的 Imagenet 竞赛中大获全胜。</p>
<p>ResNet 有效的解决了深度卷积神经网络难训练的问题。这是因为在误差逆向传播的过程中，梯度通常变得越来越小，从而权重的更新量也变小。这个导致远离损失函数的层训练缓慢，随着层数的增加这个现象更加明显。之前有两种常用方案来尝试解决这个问题：</p>
<ol>
<li>按层训练。先训练靠近数据的层，然后慢慢的增加后面的层。但效果不是特别好，而且比较麻烦。</li>
<li>使用更宽的层（增加输出通道）而不是更深来增加模型复杂度。但更宽的模型经常不如更深的效果好。</li>
</ol>
<p>ResNet 通过增加跨层的连接来解决梯度逐层回传时变小的问题。虽然这个想法之前就提出过了，但 ResNet 真正的把效果做好了。</p>
<p>下图演示了一个跨层的连接。</p>
<div align="center">
  <img src="/Blog/.io//deep-learning-limu-note03-12.svg">
  <p> </p>
</div>


<p>最底下那层的输入不仅仅是输出给了中间层，而且其与中间层结果相加进入最上层。这样在梯度逆向传播时，最上层梯度可以直接跳过中间层传到最下层，从而避免最下层梯度过小情况。</p>
<p>为什么叫做残差网络呢？我们可以将上面示意图里的结构拆成两个网络的和，一个一层，一个两层，最下面层是共享的。</p>
<div align="center">
  <img src="/Blog/.io//deep-learning-limu-note03-13.svg">
  <p> </p>
</div>

<p>在训练过程中，左边的网络因为更简单所以更容易训练。这个小网络没有拟合到的部分，或者说残差，则被右边的网络抓取住。所以直观上来说，即使加深网络，跨层连接仍然可以使得底层网络可以充分的训练，从而不会让训练更难。</p>
<h3 id="Residual-块"><a href="#Residual-块" class="headerlink" title="Residual 块"></a>Residual 块</h3><p>ResNet 沿用了 VGG 的那种全用 $3\times 3$ 卷积，但在卷积和池化层之间加入了批量归一层来加速训练。每次跨层连接跨过<strong>两层卷积</strong>。这里我们定义一个这样的残差块。注意到如果输入的通道数和输出不一样时（<code>same_shape=False</code>），我们使用一个额外的 $1\times 1$ 卷积来做通道变化，同时使用<code>strides=2</code>来把长宽减半。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residual</span>(<span class="params">nn.Block</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, channels, same_shape=<span class="literal">True</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Residual, self).__init__(**kwargs)</span><br><span class="line">        self.same_shape = same_shape</span><br><span class="line">        strides = <span class="number">1</span> <span class="keyword">if</span> same_shape <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">        self.conv1 = nn.Conv2D(channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, strides=strides)</span><br><span class="line">        self.bn1 = nn.BatchNorm()</span><br><span class="line">        self.conv2 = nn.Conv2D(channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> same_shape:</span><br><span class="line">            self.conv3 = nn.Conv2D(channels, kernel_size=<span class="number">1</span>, strides=strides)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = nd.relu(self.bn1(self.conv1(x)))</span><br><span class="line">        out = self.bn2(self.conv2(out))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.same_shape:</span><br><span class="line">            x = self.conv3(x)</span><br><span class="line">        <span class="keyword">return</span> nd.relu(out + x)</span><br></pre></td></tr></table></figure></p>
<h3 id="构建ResNet"><a href="#构建ResNet" class="headerlink" title="构建ResNet"></a>构建ResNet</h3><p>类似 GoogLeNet 主体是由 Inception 块串联而成，ResNet 的主体部分串联多个 Residual 块。下面定义 18 层的 ResNet。另外注意到一点是，这里没用池化层来减小数据长宽，而是通过有通道变化的 Residual 块里面的使用<code>strides=2</code>的卷积层。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResNet</span>(<span class="params">nn.Block</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_classes, verbose=<span class="literal">False</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ResNet, self).__init__(**kwargs)</span><br><span class="line">        self.verbose = verbose</span><br><span class="line">        <span class="comment"># add name_scope on the outermost Sequential</span></span><br><span class="line">        <span class="keyword">with</span> self.name_scope():</span><br><span class="line">            <span class="comment"># block 1</span></span><br><span class="line">            b1 = nn.Conv2D(<span class="number">64</span>, kernel_size=<span class="number">7</span>, strides=<span class="number">2</span>)</span><br><span class="line">            <span class="comment"># block 2</span></span><br><span class="line">            b2 = nn.Sequential()</span><br><span class="line">            b2.add(</span><br><span class="line">                nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>),</span><br><span class="line">                Residual(<span class="number">64</span>),</span><br><span class="line">                Residual(<span class="number">64</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># block 3</span></span><br><span class="line">            b3 = nn.Sequential()</span><br><span class="line">            b3.add(</span><br><span class="line">                Residual(<span class="number">128</span>, same_shape=<span class="literal">False</span>),</span><br><span class="line">                Residual(<span class="number">128</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># block 4</span></span><br><span class="line">            b4 = nn.Sequential()</span><br><span class="line">            b4.add(</span><br><span class="line">                Residual(<span class="number">256</span>, same_shape=<span class="literal">False</span>),</span><br><span class="line">                Residual(<span class="number">256</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># block 5</span></span><br><span class="line">            b5 = nn.Sequential()</span><br><span class="line">            b5.add(</span><br><span class="line">                Residual(<span class="number">512</span>, same_shape=<span class="literal">False</span>),</span><br><span class="line">                Residual(<span class="number">512</span>)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># block 6</span></span><br><span class="line">            b6 = nn.Sequential()</span><br><span class="line">            b6.add(</span><br><span class="line">                nn.AvgPool2D(pool_size=<span class="number">3</span>),</span><br><span class="line">                nn.Dense(num_classes)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># chain all blocks together</span></span><br><span class="line">            self.net = nn.Sequential()</span><br><span class="line">            self.net.add(b1, b2, b3, b4, b5, b6)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = x</span><br><span class="line">        <span class="keyword">for</span> i, b <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.net):</span><br><span class="line">            out = b(out)</span><br><span class="line">            <span class="keyword">if</span> self.verbose:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Block %d output: %s&#x27;</span>%(i+<span class="number">1</span>, out.shape))</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>ResNet使用跨层通道使得训练非常深的卷积神经网络成为可能。同样它使用很简单的卷积层配置，使得其拓展更加简单。</p>
</blockquote>
<h2 id="DenseNet"><a href="#DenseNet" class="headerlink" title="DenseNet"></a>DenseNet</h2><p>ResNet的跨层连接思想影响了接下来的众多工作。这里我们介绍其中的一个：<a href="https://arxiv.org/pdf/1608.06993.pdf">DenseNet</a>。下图展示了这两个的主要区别：</p>
<div align="center">
  <img src="/Blog/.io//deep-learning-limu-note03-14.svg">
  <p> </p>
</div>

<p>可以看到 DenseNet 里来自跳层的输出不是通过加法（<code>+</code>）而是拼接（<code>concat</code>）来跟目前层的输出合并。因为是拼接，所以底层的输出会保留的进入上面所有层。这是为什么叫“稠密连接”的原因。</p>
<h3 id="稠密块（Dense-Block）"><a href="#稠密块（Dense-Block）" class="headerlink" title="稠密块（Dense Block）"></a>稠密块（Dense Block）</h3><p>DenseNet的卷积块使用ResNet改进版本的 <code>BN-&gt;Relu-&gt;Conv</code>。每个卷积的输出通道数被称之为 <code>growth_rate</code>，这是因为假设输入为 <code>in_channels</code>，而且有 <code>layers</code> 层，那么输出的通道数就是 <code>in_channels + growth_rate * layers</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_block</span>(<span class="params">channels</span>):</span></span><br><span class="line">    out = nn.Sequential()</span><br><span class="line">    out.add(</span><br><span class="line">        nn.BatchNorm(),</span><br><span class="line">        nn.Activation(<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        nn.Conv2D(channels, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DenseBlock</span>(<span class="params">nn.Block</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, layers, growth_rate, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DenseBlock, self).__init__(**kwargs)</span><br><span class="line">        self.net = nn.Sequential()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(layers):</span><br><span class="line">            self.net.add(conv_block(growth_rate))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.net:</span><br><span class="line">            out = layer(x)</span><br><span class="line">            x = nd.concat(x, out, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h3 id="过渡块（Transition-Block）"><a href="#过渡块（Transition-Block）" class="headerlink" title="过渡块（Transition Block）"></a>过渡块（Transition Block）</h3><p>因为使用拼接的缘故，每经过一次拼接输出通道数可能会激增。为了控制模型复杂度，这里引入一个过渡块，它不仅把输入的长宽减半，同时也使用 $1\times1$ 卷积来改变通道数。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transition_block</span>(<span class="params">channels</span>):</span></span><br><span class="line">    out = nn.Sequential()</span><br><span class="line">    out.add(</span><br><span class="line">        nn.BatchNorm(),</span><br><span class="line">        nn.Activation(<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">        nn.Conv2D(channels, kernel_size=<span class="number">1</span>),</span><br><span class="line">        nn.AvgPool2D(pool_size=<span class="number">2</span>, strides=<span class="number">2</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure></p>
<h3 id="DenseNet-实现"><a href="#DenseNet-实现" class="headerlink" title="DenseNet 实现"></a>DenseNet 实现</h3><p>DenseNet 的主体就是交替串联稠密块和过渡块。它使用全局的 <code>growth_rate</code> 使得配置更加简单。过渡层每次都将通道数减半。下面定义一个 121 层的 DenseNet。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init_channels = <span class="number">64</span></span><br><span class="line">growth_rate = <span class="number">32</span></span><br><span class="line">block_layers = [<span class="number">6</span>, <span class="number">12</span>, <span class="number">24</span>, <span class="number">16</span>]</span><br><span class="line">num_classes = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dense_net</span>():</span></span><br><span class="line">    net = nn.Sequential()</span><br><span class="line">    <span class="comment"># add name_scope on the outermost Sequential</span></span><br><span class="line">    <span class="keyword">with</span> net.name_scope():</span><br><span class="line">        <span class="comment"># first block</span></span><br><span class="line">        net.add(</span><br><span class="line">            nn.Conv2D(init_channels, kernel_size=<span class="number">7</span>, strides=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">            nn.BatchNorm(),</span><br><span class="line">            nn.Activation(<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">            nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># dense blocks</span></span><br><span class="line">        channels = init_channels</span><br><span class="line">        <span class="keyword">for</span> i, layers <span class="keyword">in</span> <span class="built_in">enumerate</span>(block_layers):</span><br><span class="line">            net.add(DenseBlock(layers, growth_rate))</span><br><span class="line">            channels += layers * growth_rate</span><br><span class="line">            <span class="keyword">if</span> i != <span class="built_in">len</span>(block_layers)-<span class="number">1</span>:</span><br><span class="line">                net.add(transition_block(channels//<span class="number">2</span>))</span><br><span class="line">        <span class="comment"># last block</span></span><br><span class="line">        net.add(</span><br><span class="line">            nn.BatchNorm(),</span><br><span class="line">            nn.Activation(<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">            nn.AvgPool2D(pool_size=<span class="number">1</span>),</span><br><span class="line">            nn.Flatten(),</span><br><span class="line">            nn.Dense(num_classes)</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> net</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>MXNet/Gluon 深度学习笔记 (四) —— 优化算法</title>
    <url>/Blog/2018/01/29/deep-learning-limu-note04/</url>
    <content><![CDATA[<p>优化算法对于深度学习十分重要。首先，实际中训练一个复杂的深度学习模型可能需要数小时、数日、甚至数周时间。而优化算法的效率直接影响模型训练效率。其次，深刻理解各种优化算法的原理以及其中各参数的意义将可以有助于我们更有针对性地调参，从而使深度学习模型表现地更好。</p>
<p>本篇博文详细介绍深度学习中一些常用的优化算法。</p>
<p>在一个机器学习的问题中，我们会预先定义一个损失函数，然后用优化算法来最小化这个损失函数。在优化中，这样的损失函数通常被称作优化问题的<strong>目标函数</strong>。依据惯例，优化算法通常只考虑最小化目标函数。任何最大化问题都可以很容易地转化为最小化问题：我们只需把目标函数前面的符号翻转一下。</p>
<p>在机器学习中，优化算法的目标函数通常是一个基于训练数据集的损失函数。因此，优化往往对应降低训练误差。而机器学习的主要目标在于降低<strong>泛化误差</strong>，例如应用一些应对过拟合的技巧。在本文中，我们只关注优化算法在最小化目标函数上的表现。</p>
<span id="more"></span>
<h2 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h2><h3 id="一维梯度下降"><a href="#一维梯度下降" class="headerlink" title="一维梯度下降"></a>一维梯度下降</h3><p>我们先以简单的一维梯度下降为例，解释梯度下降算法可以降低目标函数值的原因。一维梯度是一个标量，也称导数。</p>
<p>假设函数 $f: \mathbb{R} \rightarrow \mathbb{R}$ 的输入和输出都是标量。根据泰勒展开公式，我们得到</p>
<script type="math/tex; mode=display">f(x + \epsilon) \approx f(x) + f'(x) \epsilon</script><p>假设 $\eta$ 是一个常数，将 $\epsilon$ 替换为 $-\eta f’(x)$ 后，我们有</p>
<script type="math/tex; mode=display">f(x - \eta f'(x)) \approx f(x) -  \eta f'(x)^2</script><p>如果 $\eta$ 是一个很小的正数，那么</p>
<script type="math/tex; mode=display">f(x - \eta f'(x)) \leq f(x)</script><p>也就是说，如果当前导数 $f’(x) \neq 0$，按照 $x := x - \eta f’(x)$ 更新 $x$ 可能降低 $f(x)$ 的值。</p>
<p>由于导数 $f’(x)$ 是梯度在一维空间的特殊情况，上述更新 $x$ 的方法也即一维空间的梯度下降。一维空间的梯度下降如下图所示，参数 $x$ 沿着梯度方向不断更新。</p>
<div align="center">
  <img src="/Blog/.io//1.png">
  <p> </p>
</div>



<h3 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h3><p>上述梯度下降算法中的 $\eta$（取正数）叫做学习率或步长。需要注意的是，学习率过大可能会造成 $x$ 迈过（overshoot）最优解，甚至不断发散而无法收敛，如下图所示。</p>
<div align="center">
  <img src="/Blog/.io//2.png">
  <p> </p>
</div>

<p>然而，如果学习率过小，优化算法收敛速度会过慢。实际中，一个合适的学习率通常是需要通过实验调出来的。</p>
<h3 id="多维梯度下降"><a href="#多维梯度下降" class="headerlink" title="多维梯度下降"></a>多维梯度下降</h3><p>现在我们考虑一个更广义的情况：目标函数的输入为向量，输出为标量。</p>
<p>假设目标函数 $f: \mathbb{R}^d \rightarrow \mathbb{R}$ 的输入是一个多维向量 $\mathbf{x} = [x_1, x_2, \ldots, x_d]^\top$。目标函数 $f(\mathbf{x})$ 有关 $\mathbf{x}$ 的梯度是一个由偏导数组成的向量：</p>
<script type="math/tex; mode=display">\nabla_\mathbf{x} f(\mathbf{x}) = \bigg[\frac{\partial f(\mathbf{x})}{\partial x_1}, \frac{\partial f(\mathbf{x})}{\partial x_2}, \ldots, \frac{\partial f(\mathbf{x})}{\partial x_d}\bigg]^\top.</script><p>为表示简洁，我们有时用 $\nabla f(\mathbf{x})$ 代替 $\nabla_\mathbf{x} f(\mathbf{x})$。梯度中每个偏导数元素 $\partial f(\mathbf{x})/\partial x_i$ 代表着$f$在 $\mathbf{x}$ 有关输入 $x_i$ 的变化率。为了测量 $f$ 沿着单位向量 $\mathbf{u}$ 方向上的变化率，在多元微积分中，我们定义 $f$ 在 $\mathbf{x}$ 上沿着 $\mathbf{u}$ 方向的方向导数为</p>
<script type="math/tex; mode=display">D_\mathbf{u} f(\mathbf{x}) = \lim_{h \rightarrow 0}  \frac{f(\mathbf{x} + h \mathbf{u}) - f(\mathbf{x})}{h}</script><p>由链式法则，该方向导数可以改写为</p>
<script type="math/tex; mode=display">D_\mathbf{u} f(\mathbf{x}) = \nabla f(\mathbf{x}) \cdot \mathbf{u}</script><p>方向导数 $D<em>\mathbf{u} f(\mathbf{x})$ 给出了 $f$ 在 $\mathbf{x}$ 上沿着所有可能方向的变化率。为了最小化 $f$，我们希望找到 $f$ 能被降低最快的方向。因此，我们可以通过 $\mathbf{u}$ 来最小化方向导数 $D</em>\mathbf{u} f(\mathbf{x})$。</p>
<p>由于 $D<em>\mathbf{u} f(\mathbf{x}) = |\nabla f(\mathbf{x})| \cdot |\mathbf{u}|  \cdot \text{cos} (\theta) = |\nabla f(\mathbf{x})|  \cdot \text{cos} (\theta)$，其中 $\theta$ 为 $\nabla f(\mathbf{x})$ 和 $\mathbf{u}$ 之间的夹角，当 $\theta = \pi$，$\text{cos}(\theta)$ 取得最小值-1。因此，当 $\mathbf{u}$ 在梯度方向 $\nabla f(\mathbf{x})$ 的相反方向时，方向导数 $D</em>\mathbf{u} f(\mathbf{x})$ 被最小化。所以，我们可能通过下面的<strong>梯度下降算法</strong>来不断降低目标函数 $f$ 的值：</p>
<script type="math/tex; mode=display">\mathbf{x} := \mathbf{x} - \eta \nabla f(\mathbf{x})</script><p>相同地，其中 $\eta$（取正数）称作学习率或步长。</p>
<h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><p>然而，当训练数据集很大时，梯度下降算法可能会难以使用。为了解释这个问题，考虑目标函数</p>
<script type="math/tex; mode=display">f(\mathbf{x}) = \frac{1}{n} \sum_{i = 1}^n f_i(\mathbf{x}),</script><p>其中 $f_i(\mathbf{x})$ 是有关索引为 $i$ 的训练数据点的损失函数。需要强调的是，梯度下降每次迭代的计算开销随着 $n$ 线性增长。因此，当 $n$ 很大时，每次迭代的计算开销很高。</p>
<p>这时我们需要<strong>随机梯度下降</strong>算法。在每次迭代时，该算法随机均匀采样 $i$ 并计算 $\nabla f_i(\mathbf{x})$。事实上，随机梯度 $\nabla f_i(\mathbf{x})$ 是对梯度 $\nabla f(\mathbf{x})$ 的无偏估计：</p>
<script type="math/tex; mode=display">\mathbb{E}_i \nabla f_i(\mathbf{x}) = \frac{1}{n} \sum_{i = 1}^n \nabla f_i(\mathbf{x}) = \nabla f(\mathbf{x})</script><h3 id="小批量随机梯度下降"><a href="#小批量随机梯度下降" class="headerlink" title="小批量随机梯度下降"></a>小批量随机梯度下降</h3><p>广义上，每次迭代可以随机均匀采样一个由训练数据点索引所组成的小批量 $\mathcal{B}$ 。类似地，我们可以使用</p>
<script type="math/tex; mode=display">\nabla f_\mathcal{B}(\mathbf{x}) = \frac{1}{|\mathcal{B}|} \sum_{i \in \mathcal{B}}\nabla f_i(\mathbf{x})</script><p>来更新 $\mathbf{x}$：</p>
<script type="math/tex; mode=display">\mathbf{x} := \mathbf{x} - \eta \nabla f_\mathcal{B}(\mathbf{x}),</script><p>其中 $|\mathcal{B}|$ 代表批量中索引数量，$\eta$（取正数）称作学习率或步长。同样，小批量随机梯度 $\nabla f_\mathcal{B}(\mathbf{x})$ 也是对梯度 $\nabla f(\mathbf{x})$ 的无偏估计:</p>
<script type="math/tex; mode=display">\mathbb{E}_\mathcal{B} \nabla f_\mathcal{B}(\mathbf{x}) = \nabla f(\mathbf{x}).</script><p>这个算法叫做<strong>小批量随机梯度下降</strong>。该算法每次迭代的计算开销为 $\mathcal{O}(|\mathcal{B}|)$。因此，当批量较小时，每次迭代的计算开销也较小。</p>
<h3 id="SGD-的算法实现"><a href="#SGD-的算法实现" class="headerlink" title="SGD 的算法实现"></a>SGD 的算法实现</h3><p>这里只需要实现小批量随机梯度下降。当批量大小等于训练集大小时，该算法即为梯度下降；批量大小为1即为随机梯度下降。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 小批量随机梯度下降</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sgd</span>(<span class="params">params, lr, batch_size</span>):</span></span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param[:] = param - lr * param.grad / batch_size</span><br></pre></td></tr></table></figure></p>
<h2 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h2><p>在梯度下降算法中，每次迭代时，该算法沿着目标函数下降最<strong>快</strong>的方向更新参数。因此，梯度下降有时也叫做最陡下降（steepest descent）。在梯度下降中，每次更新参数的方向仅仅取决当前位置，这可能会带来一些问题。</p>
<p>考虑一个输入为二维向量 $\mathbf{x} = [x_1, x_2]^\top$，输出为标量的目标函数 $f: \mathbb{R}^2 \rightarrow \mathbb{R}$ 。下面为该函数的等高线示意图（每条等高线表示相同函数值的点：越靠近中间函数值越小）。</p>
<div align="center">
  <img src="/Blog/.io//3.png">
  <p> </p>
</div>

<p>上图中，红色三角形代表参数 $\mathbf{x}$ 的初始值。带箭头的线段表示每次迭代时参数的更新。由于目标函数在竖直方向（ $x_2$ 轴方向）上比在水平方向（ $x_1$ 轴方向）弯曲得更厉害，梯度下降迭代参数时会使参数在竖直方向比在水平方向移动更猛烈。因此，我们需要一个较小的学习率从而避免参数在竖直方向上 overshoot。这就造成了上图中参数向最优解移动速度的缓慢。</p>
<h3 id="动量法"><a href="#动量法" class="headerlink" title="动量法"></a>动量法</h3><p>动量法的提出是为了应对梯度下降的上述问题。广义上，以小批量随机梯度下降为例，我们对小批量随机梯度算法做如下修改：</p>
<script type="math/tex; mode=display">
\begin{align\*}
\mathbf{v} &:= \gamma \mathbf{v} + \eta \nabla f_\mathcal{B}(\mathbf{x}),\\
\mathbf{x} &:= \mathbf{x} - \mathbf{v},
\end{align\*}</script><p>其中 $\mathbf{v}$ 是当前速度，$\gamma$ 是动量参数。其余符号如学习率 $\eta$、有关小批量 $\mathcal{B}$ 的随机梯度 $\nabla f_\mathcal{B}(\mathbf{x})$ 和上一节定义一样。</p>
<p>当前速度 $\mathbf{v}$ 的更新可以理解为对 $[\eta / (1 - \gamma)] \nabla f_\mathcal{B}(\mathbf{x})$ 做<strong>指数加权移动平均</strong>。因此，动量法的每次迭代中，参数在各个方向上移动幅度不仅取决当前梯度，还取决过去各个梯度在各个方向上是否一致。当过去的所有梯度都在同一方向，例如都是水平向右，那么参数在水平向右的移动幅度最大。如果过去的梯度中在竖直方向上时上时下，那么参数在竖直方向的移动幅度将变小。这样，我们就可以使用较大的学习率，从而如下图收敛更快。</p>
<div align="center">
  <img src="/Blog/.io//4.png">
  <p> </p>
</div>


<h3 id="动量参数"><a href="#动量参数" class="headerlink" title="动量参数"></a>动量参数</h3><p>为了有助于理解动量参数 $\gamma$，考虑一个简单的问题：每次迭代的小批量随机梯度 $\nabla f_\mathcal{B}(\mathbf{x})$ 都等于 $\mathbf{g}$ 。由于所有小批量随机梯度都在同一方向，动量法在该方向使参数移动加速：</p>
<script type="math/tex; mode=display">
\begin{align\*}
\mathbf{v}_1 &:= \eta\mathbf{g},\\
\mathbf{v}_2 &:= \gamma \mathbf{v}_1 + \eta\mathbf{g} = \eta\mathbf{g} (\gamma + 1),\\
\mathbf{v}_3 &:= \gamma \mathbf{v}_2 + \eta\mathbf{g} = \eta\mathbf{g} (\gamma^2 + \gamma + 1),\\
&\ldots\\
\mathbf{v}_{\inf} &:= \frac{\eta\mathbf{g}}{1 - \gamma}.
\end{align\*}</script><p>例如，当 $\gamma = 0.99$ , 最终的速度将是学习率乘以相应小批量随机梯度 $\eta\mathbf{g}$ 的100倍大。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>动量法的实现也很简单，在小批量随机梯度下降的基础上添加速度项<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 动量法。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sgd_momentum</span>(<span class="params">params, vs, lr, mom, batch_size</span>):</span></span><br><span class="line">    <span class="keyword">for</span> param, v <span class="keyword">in</span> <span class="built_in">zip</span>(params, vs):</span><br><span class="line">        v[:] = mom * v + lr * param.grad / batch_size</span><br><span class="line">        param[:] -= v</span><br></pre></td></tr></table></figure></p>
<h2 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h2><p>在我们之前的优化算法中，无论是梯度下降、随机梯度下降、小批量随机梯度下降还是使用动量法，模型参数中的每一个元素在相同时刻都使用同一个学习率来自我迭代。</p>
<p>举个例子，当一个模型的损失函数为 $L$ ，参数为一个多维向量 $[x_1, x_2]^\top$ 时，该向量中每一个元素在更新时都使用相同的学习率，例如在学习率为 $\eta$ 的梯度下降中：</p>
<script type="math/tex; mode=display">
x_1 := x_1 - \eta \frac{\partial{L}}{\partial{x_1}} \\
x_2 := x_2 - \eta \frac{\partial{L}}{\partial{x_2}}</script><p>其中元素 $x_1$ 和 $x_2$ 都使用相同的学习率 $\eta$ 来自我迭代。如果让 $x_1$ 和 $x_2$ 使用不同的学习率自我迭代呢？</p>
<p>Adagrad 就是一个在迭代过程中不断自我调整学习率，并让模型参数中每个元素都使用不同学习率的优化算法。</p>
<h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><p>Adagrad 算法会使用一个梯度按元素平方的累加变量 $\mathbf{s}$，并将其中每个元素初始化为 0 。在每次迭代中，首先计算小批量梯度 $\mathbf{g}$ ，然后将该梯度按元素平方后累加到变量 $\mathbf{s}$：</p>
<script type="math/tex; mode=display">\mathbf{s} := \mathbf{s} + \mathbf{g} \odot \mathbf{g}</script><p>然后将模型参数中每个元素的学习率通过按元素操作重新调整一下：</p>
<script type="math/tex; mode=display">\mathbf{g}^\prime := \frac{\eta}{\sqrt{\mathbf{s} + \epsilon}} \odot \mathbf{g}</script><p>其中 $\eta$ 是初始学习率，$\epsilon$ 是为了维持数值稳定性而添加的常数，例如 $10^{-7}$。注意其中按元素开方、除法和乘法的操作，<strong>这些按元素操作使得模型参数中每个元素都分别拥有自己的学习率。</strong></p>
<p>需要强调的是，由于梯度按元素平方的累加变量 $\mathbf{s}$ 出现在分母，Adagrad 的核心思想是：如果模型损失函数有关一个参数元素的偏导数一直都较大，那么就让它的学习率下降快一点；反之，如果模型损失函数有关一个参数元素的偏导数一直都较小，那么就让它的学习率下降慢一点。然而，由于 $\mathbf{s}$ 一直在累加按元素平方的梯度，每个元素的学习率在迭代过程中一直在降低或不变。所以在有些问题中，当学习率在迭代早期降得较快时且当前解依然不理想时，Adagrad 在迭代后期可能较难找到一个有用的解。</p>
<p>最后的参数迭代步骤与小批量随机梯度下降类似。只是这里梯度前的学习率已经被调整过了：</p>
<script type="math/tex; mode=display">\mathbf{x} := \mathbf{x} - \mathbf{g}^\prime</script><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Adagrad算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adagrad</span>(<span class="params">params, sqrs, lr, batch_size</span>):</span></span><br><span class="line">    eps_stable = <span class="number">1e-7</span></span><br><span class="line">    <span class="keyword">for</span> param, sqr <span class="keyword">in</span> <span class="built_in">zip</span>(params, sqrs):</span><br><span class="line">        g = param.grad / batch_size</span><br><span class="line">        sqr[:] += nd.square(g)</span><br><span class="line">        div = lr * g / nd.sqrt(sqr + eps_stable)</span><br><span class="line">        param[:] -= div</span><br></pre></td></tr></table></figure>
<h2 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h2><p>在 Adagrad 算法中，由于学习率分母上的变量 $\mathbf{s}$ 一直在累加按元素平方的梯度，每个元素的学习率在迭代过程中一直在降低或不变。所以在有些问题下，当学习率在迭代早期降得较快时且当前解依然不理想时，Adagrad 在迭代后期可能较难找到一个有用的解。</p>
<p>为了应对这一问题，RMSProp 算法对 Adagrad 做了一点小小的修改。</p>
<h3 id="算法详情"><a href="#算法详情" class="headerlink" title="算法详情"></a>算法详情</h3><p>RMSProp 算法会使用一个梯度按元素平方的指数加权移动平均变量 $\mathbf{s}$，并将其中每个元素初始化为 0 。在每次迭代中，首先计算小批量梯度 $\mathbf{g}$，然后对该梯度按元素平方后做指数加权移动平均并计算 $\mathbf{s}$：</p>
<script type="math/tex; mode=display">\mathbf{s} := \gamma \mathbf{s} + (1 - \gamma) \mathbf{g} \odot \mathbf{g}</script><p>然后将模型参数中每个元素的学习率通过按元素操作重新调整一下：</p>
<script type="math/tex; mode=display">\mathbf{g}^\prime := \frac{\eta}{\sqrt{\mathbf{s} + \epsilon}} \odot \mathbf{g}</script><p>其中 $\eta$ 是初始学习率，$\epsilon$ 是为了维持数值稳定性而添加的常数，例如 $10^{-8}$ 。和 Adagrad 一样，模型参数中每个元素都分别拥有自己的学习率。</p>
<p>同样地，最后的参数迭代步骤与小批量随机梯度下降类似，只是这里梯度前的学习率已经被调整过了：</p>
<script type="math/tex; mode=display">\mathbf{x} := \mathbf{x} - \mathbf{g}^\prime</script><blockquote>
<p>RMSProp 只在 Adagrad 的基础上修改了变量 $\mathbf{s}$ 的更新方法：把累加改成了<strong>指数加权移动平均</strong>。因此，每个元素的学习率在迭代过程中既可能降低又可能升高。</p>
</blockquote>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RMSProp</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rmsprop</span>(<span class="params">params, sqrs, lr, gamma, batch_size</span>):</span></span><br><span class="line">    eps_stable = <span class="number">1e-8</span></span><br><span class="line">    <span class="keyword">for</span> param, sqr <span class="keyword">in</span> <span class="built_in">zip</span>(params, sqrs):</span><br><span class="line">        g = param.grad / batch_size</span><br><span class="line">        sqr[:] = gamma * sqr + (<span class="number">1.</span> - gamma) * nd.square(g)</span><br><span class="line">        div = lr * g / nd.sqrt(sqr + eps_stable)</span><br><span class="line">        param[:] -= div</span><br></pre></td></tr></table></figure>
<h2 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h2><p>Adadelta 和 RMSProp 类似，也是针对当学习率在迭代早期降得较快时且当前解依然不理想时 Adagrad 在迭代后期可能较难找到一个有用的解的解决方案，和 RMSProp 不同的是，Adadelta 没有学习率参数。</p>
<p>Adadelta 算法也像 RMSProp 一样使用了一个梯度按元素平方的指数加权移动平均变量 $\mathbf{s}$，并将其中每个元素初始化为 0 。在每次迭代中，首先计算小批量梯度 $\mathbf{g}$，然后对该梯度按元素平方后做指数加权移动平均并计算 $\mathbf{s}$：</p>
<script type="math/tex; mode=display">\mathbf{s} := \rho \mathbf{s} + (1 - \rho) \mathbf{g} \odot \mathbf{g}</script><p>然后我们计算当前需要更新的参数的变化量：</p>
<script type="math/tex; mode=display">\mathbf{g}^\prime = \frac{\sqrt{\Delta\mathbf{x} + \epsilon}}{\sqrt{\mathbf{s} + \epsilon}}   \odot \mathbf{g}</script><p>其中 $\epsilon$ 是为了维持数值稳定性而添加的常数，例如 $10^{-5}$。和 Adagrad 一样，模型参数中每个元素都分别拥有自己的学习率。其中 $\Delta\mathbf{x}$ 初始化为零张量，并做如下 $\mathbf{g}^\prime$ 按元素平方的指数加权移动平均：</p>
<script type="math/tex; mode=display">\Delta\mathbf{x} := \rho \Delta\mathbf{x} + (1 - \rho) \mathbf{g}^\prime \odot \mathbf{g}^\prime</script><p>同样地，最后的参数迭代步骤与小批量随机梯度下降类似。只是这里梯度前的学习率已经被调整过了：</p>
<script type="math/tex; mode=display">\mathbf{x} := \mathbf{x} - \mathbf{g}^\prime</script><p>代码实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Adadalta</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adadelta</span>(<span class="params">params, sqrs, deltas, rho, batch_size</span>):</span></span><br><span class="line">    eps_stable = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">for</span> param, sqr, delta <span class="keyword">in</span> <span class="built_in">zip</span>(params, sqrs, deltas):</span><br><span class="line">        g = param.grad / batch_size</span><br><span class="line">        sqr[:] = rho * sqr + (<span class="number">1.</span> - rho) * nd.square(g)</span><br><span class="line">        cur_delta = nd.sqrt(delta + eps_stable) / nd.sqrt(sqr + eps_stable) * g</span><br><span class="line">        delta[:] = rho * delta + (<span class="number">1.</span> - rho) * cur_delta * cur_delta</span><br><span class="line">        param[:] -= cur_delta</span><br></pre></td></tr></table></figure></p>
<h2 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h2><p>Adam 是一个组合了动量法和 RMSProp 的优化算法。</p>
<p>Adam 算法会使用一个动量变量 $\mathbf{v}$ 和一个 RMSProp 中梯度按元素平方的指数加权移动平均变量 $\mathbf{s}$，并将它们中每个元素初始化为 0。在每次迭代中，首先计算小批量梯度 $\mathbf{g}$，并递增迭代次数</p>
<script type="math/tex; mode=display">t := t + 1</script><p>然后对梯度做指数加权移动平均并计算动量变量 $\mathbf{v}$:</p>
<script type="math/tex; mode=display">\mathbf{v} := \beta_1 \mathbf{v} + (1 - \beta_1) \mathbf{g}</script><p>该梯度按元素平方后做指数加权移动平均并计算 $\mathbf{s}$：</p>
<script type="math/tex; mode=display">\mathbf{s} := \beta_2 \mathbf{s} + (1 - \beta_2) \mathbf{g} \odot \mathbf{g}</script><p>在 Adam 算法里，为了减轻 $\mathbf{v}$ 和 $\mathbf{s}$ 被初始化为0在迭代初期对计算指数加权移动平均的影响（冷启动现象），算法做了如下的偏差修正：</p>
<script type="math/tex; mode=display">\hat{\mathbf{v}} := \frac{\mathbf{v}}{1 - \beta_1^t}</script><p>和</p>
<script type="math/tex; mode=display">\hat{\mathbf{s}} := \frac{\mathbf{s}}{1 - \beta_2^t}</script><p>可以看到，当 $0 \leq \beta_1, \beta_2 &lt; 1$ 时（算法作者建议分别设为 0.9 和 0.999 ），当迭代后期$t$较大时，偏差修正几乎就不再有影响。我们使用以上偏差修正后的动量变量和 RMSProp 中梯度按元素平方的指数加权移动平均变量，将模型参数中每个元素的学习率通过按元素操作重新调整一下：</p>
<script type="math/tex; mode=display">\mathbf{g}^\prime := \frac{\eta \hat{\mathbf{v}}}{\sqrt{\hat{\mathbf{s}} + \epsilon}}</script><p>其中 $\eta$ 是初始学习率，$\epsilon$ 是为了维持数值稳定性而添加的常数，例如 $10^{-8}$。和 Adagrad 一样，模型参数中每个元素都分别拥有自己的学习率。</p>
<p>同样地，最后的参数迭代步骤与小批量随机梯度下降类似。只是这里梯度前的学习率已经被调整过了：</p>
<script type="math/tex; mode=display">\mathbf{x} := \mathbf{x} - \mathbf{g}^\prime</script><p>代码实现如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Adam</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adam</span>(<span class="params">params, vs, sqrs, lr, batch_size, t</span>):</span></span><br><span class="line">    beta1 = <span class="number">0.9</span></span><br><span class="line">    beta2 = <span class="number">0.999</span></span><br><span class="line">    eps_stable = <span class="number">1e-8</span></span><br><span class="line">    <span class="keyword">for</span> param, v, sqr <span class="keyword">in</span> <span class="built_in">zip</span>(params, vs, sqrs):</span><br><span class="line">        g = param.grad / batch_size</span><br><span class="line">        v[:] = beta1 * v + (<span class="number">1.</span> - beta1) * g</span><br><span class="line">        sqr[:] = beta2 * sqr + (<span class="number">1.</span> - beta2) * nd.square(g)</span><br><span class="line">        v_bias_corr = v / (<span class="number">1.</span> - beta1 ** t)</span><br><span class="line">        sqr_bias_corr = sqr / (<span class="number">1.</span> - beta2 ** t)</span><br><span class="line">        div = lr * v_bias_corr / (nd.sqrt(sqr_bias_corr) + eps_stable)</span><br><span class="line">        param[:] = param - div</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后以一首打油诗总结：</p>
<p>  梯度下降可沉甸，  随机降低方差难。</p>
<p>  引入动量别弯慢，  Adagrad梯方贪。</p>
<p>  Adadelta学率换， RMSProp梯方权。</p>
<p>  Adam动量RMS伴，  优化还需己调参。</p>
<p>注释：</p>
<ul>
<li>梯方：梯度按元素平方</li>
<li>贪：因贪婪故而不断累加</li>
<li>学率：学习率</li>
<li>换：这个参数被换成别的了</li>
<li>权：指数加权移动平均</li>
</ul>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>MXNet/Gluon 深度学习笔记 (五) —— 图像增强与迁移学习</title>
    <url>/Blog/2018/01/30/deep-learning-limu-note05/</url>
    <content><![CDATA[<h2 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h2><p>图像增强是通过一系列的随机变化生成大量“新”样本，从而减低过拟合的可能的技术。现在在深度神经网络中，特别是当训练数据量不充足时，图像增强是必不可少的一部分。</p>
<p>常用的图像增强方法有以下几种：</p>
<ul>
<li><strong>变形</strong>：水平方向翻转图片是最早也是最广泛使用的一种增广</li>
<li><strong>随机裁剪</strong>：卷积层对目标位置敏感</li>
<li><strong>颜色变化</strong>：一般有改变亮度，调整色调等</li>
</ul>
<blockquote>
<p>随机截取一般会缩小输入的形状，如果原始输入图片过小，导致没有太多空间进行随机裁剪，通常做法是先将其放大的足够大的尺寸。所以如果你的原始图片足够大，建议不要事先将它们裁到网络需要的大小。</p>
</blockquote>
<p>实验时通常会将数个增强方法一起用，图像增强通常只增对训练数据，对于测试数据则用得较小。后者常用的是做5次随机剪裁，然后将5张图片的预测结果做均值。<br><span id="more"></span><br>用 gluon 做数据增强, 可以先定义一个辅助函数:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_aug_list</span>(<span class="params">img, augs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> augs:</span><br><span class="line">        img = f(img)</span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure><br>然后该定义图像增强内容:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_augs = [</span><br><span class="line">    image.HorizontalFlipAug(flip_prob),</span><br><span class="line">    image.RandomCropAug((height,width))</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">test_augs = [</span><br><span class="line">    image.CenterCropAug((height,width))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>最后应用到图像:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## apply to each sample one-by-one and then stack</span></span><br><span class="line">data = nd.stack(*[apply_aug_list(d, augs) <span class="keyword">for</span> d <span class="keyword">in</span> data])</span><br></pre></td></tr></table></figure></p>
<h2 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h2><p>总所周知,训练神经网络需要庞大的数据集, 而数据集的制作绝非易事. 对于我们大多数人而言, 需要在自己的数据集上训练数据集, 而通常我们所能获得的只是相对而言中等规模的数据, 几百张图片很正常，找到几千张图片也有可能，但很难同 Imagenet 一样获得上百万张图片。</p>
<p>于是一个很自然的问题就是, 如何使用在百万张图片上训练出来的强大的模型来帮助提升在小数据集上的精度呢？这种在源数据上训练，然后将学到的知识应用到目标数据集上的技术通常被叫做<strong>迁移学习</strong>。</p>
<p>对于深度神经网络来首，最为流行的一个方法叫做微调（fine-tuning）。它的想法很简单但有效：</p>
<ul>
<li>在源数据 $S$ 上训练一个神经网络。</li>
<li>砍掉它的头，将它的输出层改成适合目标数据 $S$ 的大小</li>
<li>将输出层的权重初始化成随机值，但其它层保持跟原先训练好的权重一致</li>
<li>然后开始在目标数据集开始训练</li>
</ul>
<p>该过程如下图所示:</p>
<div align="center">
  <img src="/Blog/.io//fine-tuning.svg">
  <p>fine-tuning</p>
</div>

<p>在 gluon 中, 使用迁移学习也很简单.首先, 我们从模型库中获取改良过的 ResNet, 使用 <code>pretrained = True</code> 将会自动下载并加载从 ImageNet 数据集上训练而来的权重。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon.model_zoo <span class="keyword">import</span> vision <span class="keyword">as</span> models</span><br><span class="line"></span><br><span class="line">pretrained_net = models.resnet18_v2(pretrained=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>通常预训练好的模型由两块构成，一是 <code>features</code>，二是 <code>output</code>。后者主要包括最后一层全连接层，前者包含从输入开始的大部分层。这样的划分的一个主要目的是为了更方便做微调。<br>output 的内容如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pretrained_net.output</span><br><span class="line">&gt;&gt; Dense(<span class="number">512</span> -&gt; <span class="number">1000</span>, linear)</span><br></pre></td></tr></table></figure><br>卷积层的部分权重可以通过如下方式查看:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pretrained_net.features[<span class="number">1</span>].weight.data()[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>微调时, 一般新建一个网络，它的定义跟之前训练好的网络一样，除了最后的输出数等于当前数据的类别数。新网络的 <code>features</code> 被初始化前面训练好网络的权重，而 <code>output</code> 则是从头开始训练。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> init</span><br><span class="line"></span><br><span class="line">finetune_net = models.resnet18_v2(classes=<span class="number">2</span>)</span><br><span class="line">finetune_net.features = pretrained_net.features</span><br><span class="line">finetune_net.output.initialize(init.Xavier())</span><br></pre></td></tr></table></figure>
<p>通过一个预先训练好的模型，我们可以在即使较小的数据集上训练得到很好的分类器, 这是因为这两个任务里面的数据表示有很多<strong>共通性</strong>，例如都需要如何识别纹理、形状、边等等, 而这些特征通常能被靠近数据的层有效的捕捉。因此，如果我们有一个相对较小的数据，而且担心它可能不够训练出很好的模型，那么我们可以寻找与我们数据类似的大数据集来先预先训练网络模型，然后再使用小数据集进行微调。</p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>MXNet/Gluon 深度学习笔记 (六) —— 物体检测总结</title>
    <url>/Blog/2018/02/03/deep-learning-limu-note06/</url>
    <content><![CDATA[<p>目前深度学习中关于物体识别的问题总共有四大类，从最简单的 <strong>图像分类</strong> (Image classification) 到 <strong>物体定位</strong> (Object Localization)，再到 <strong>语义分割</strong> (Semantic Segmentation)，最后到难度最高的 <strong>实例分割</strong> (Instance Segmentation)。在这四大类问题中，Object Detection 一般指第二类，也即是物体定位问题。物体定位问题在整个物体识别技术线中处于承前启后的地位，它的难度要比单纯的图片分类问题复杂许多，而其运用却是最广泛的。目前领域内的研究者在 Object Detection 问题上进行了很多探索，也取得了许多阶段性的成果。 (Object Detection 相关研究的整理详见这篇 <a href="https://handong1587.github.io/deep_learning/2015/10/09/object-detection.html"><strong>博文</strong></a>，作者整理的很详细)。本篇博文按时间顺序，介绍了 Object Detection 的几篇有代表性的论文，重点介绍论文的思路与方法。</p>
<p><img src="http://static.zybuluo.com/guoxs/uu2v6jtf728ebyt2puax90g6/1405.jpg" alt="Object Detection"></p>
<p>上图清楚说明了image classification, object detection, semantic segmentation, instance segmentation之间的关系. 摘自　<a href="https://arxiv.org/pdf/1405.0312.pdf">COCO dataset</a><br><span id="more"></span><br>Object Detection 需要在图片中精确找出物体所在的位置 (一般以矩形框出)，并标注物体的类别。由于物体的尺寸变化范围很大，摆放物体的角度、姿势等也不确定，并且物体间也会有重叠，这等等问题使得物体定位问题不是那么容易解决。Object Detection 的技术演进大致如下：</p>
<blockquote>
<p>R-CNN —&gt; SPP-Net —&gt; Fast-RCNN —&gt; Faster-RCNN</p>
</blockquote>
<p>而后的研究也都是基于 Faster-RCNN 进行改进。</p>
<h2 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h2><p>论文链接：<a href="https://arxiv.org/pdf/1311.2524.pdf">Rich feature hierarchies for accurate object detection and semantic segmentation</a><br>GitHub：<a href="https://github.com/rbgirshick/rcnn">https://github.com/rbgirshick/rcnn</a></p>
<p>RCNN (Region-CNN) 可以说是 <strong>利用深度学习进行目标检测的开山之作</strong>。该论文解决了目标检测中的两个关键问题，一个是 <strong>速度</strong>（用 region proposals 代替 滑动窗口），一个是 <strong>训练集</strong>。 论文利用训练的神经网络进行图片的特征提取 (传统方法需要人工设计特征)，使用两个数据库：</p>
<ul>
<li>一个较大的 <strong>识别库</strong> (ImageNet ILSVC 2012，一千万图像，1000类) 标定每张图片中物体的类别；</li>
<li>一个较小的 <strong>检测库</strong>（PASCAL VOC 2007，一万图像，20类）来标定物体的类别和位置。</li>
</ul>
<p>论文使用识别库进行预训练，而后用检测库调优参数，最后在检测库上评测。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>RCNN 的算法流程如下图所示：</p>
<p><img src="http://static.zybuluo.com/guoxs/22tav9iv3t2332w4x3byv1ge/1.png" alt="RCNN"></p>
<p>算法主要分为四个步骤：</p>
<ul>
<li>对每张输入图片使用一个基于规则的 “选择性搜索” 算法，生成 1K~2K 个<strong>候选区域</strong>（Region proposals）；</li>
<li>对每个候选区域，使用训练的神经网络进行<strong>特征提取</strong>；</li>
<li>将网络提取的特征送入每一类的 SVM 分类器进行判别</li>
<li>使用回归器<strong>精细修正</strong>候选框位置</li>
</ul>
<p>每一步骤的细节如下：</p>
<h4 id="Step-1-候选框提取（selective-search）"><a href="#Step-1-候选框提取（selective-search）" class="headerlink" title="Step 1: 候选框提取（selective search）"></a><strong>Step 1:</strong> 候选框提取（selective search）</h4><p>给定一张图片，使用 <a href="https://ivi.fnwi.uva.nl/isis/publications/2013/UijlingsIJCV2013/UijlingsIJCV2013.pdf">Selective Search</a> 方法从图片中生成约 2000~3000 个候选区域。</p>
<p>生成候选区域过程包含以下两个基本步骤：</p>
<ul>
<li>使用过分割手段，将图像分割成许多小区域</li>
<li>查看现有的小区域，合并 <strong>可能性最高</strong> 的两个区域，重复直到整张图像合并成一个区域位置</li>
<li>输出所有曾经存在过的区域，即为候选区域</li>
</ul>
<p><strong>合并规则：</strong></p>
<ul>
<li>颜色（颜色直方图）相近的</li>
<li>纹理（梯度直方图）相近的</li>
<li>合并后总面积小</li>
<li>合并后总面积在 $B_{box}$ 中占的比例大</li>
</ul>
<p>其中第三条保证合并操作的尺度较为均匀，避免一个大区域陆续“吃掉”其他小区域；</p>
<blockquote>
<p>例：设有区域a-b-c-d-e-f-g-h。较好的合并方式是：ab-cd-ef-gh -&gt; abcd-efgh -&gt; abcdefgh。<br>不好的合并方法是：ab-c-d-e-f-g-h -&gt;abcd-e-f-g-h -&gt;abcdef-gh -&gt; abcdefgh。</p>
</blockquote>
<p>而第四条保证了合并后形状规则。</p>
<blockquote>
<p>例：左图适于合并，右图不适于合并。<br><img src="http://static.zybuluo.com/guoxs/xbzmn9wtj0ubr8tvz0aeowdi/20160405212106908" alt="example"></p>
</blockquote>
<p>以上四条规则只涉及到区域的颜色直方图、纹理直方图、面积和位置，合并后的区域特征可以直接由子区域特征计算而来，故速度较快。</p>
<blockquote>
<p>为了尽量不遗漏候选区域，以上操作还可以多个颜色空间同时进行（RGB、HSV、Lab等），在一个颜色空间中，使用上述四条规则的不同组合进行合并。所有颜色空间与所有规则的全部结果，再去除重复后，都作为候选区域输出。</p>
</blockquote>
<p><a href="https://www.koen.me/research/selectivesearch/">Selective Search 算法源码链接</a></p>
<h4 id="Step-2-特征提取"><a href="#Step-2-特征提取" class="headerlink" title="Step 2 : 特征提取"></a><strong>Step 2 :</strong> 特征提取</h4><p>由于候选框大小不一，而后续的 CNN 要求输入大小统一，故需要将 2000 个候选框全部 resize 到 227x227 分辨率，同时为了避免图像扭曲严重，中间还可采取一些技巧减少图片扭曲，例如直接外扩成 227x227，外扩对框外区域可以直接截取或者补灰。论文采用的网络基本借鉴Hinton 2012年在Image Net上的分类网络，如下图所示：</p>
<p><img src="http://static.zybuluo.com/guoxs/lih88fm7564tp9x2bvmmh4mv/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84" alt="network"></p>
<p>使用 ILVCR 2012 的全部数据进行训练，输入一张图片，输出 1000 维的类别标号。训练CNN模型时，对训练数据标定要求比较宽松，即 Selective Search 方法提取的 proposal 只包含部分目标区域时，也将该 proposal 标定为特定物体类别。</p>
<blockquote>
<p>当且仅当一个候选框完全包含 ground truth 区域且不属于 ground truth 部分不超过候选框区域的 5% 时认为该候选框标定结果为目标，否则位背景。</p>
</blockquote>
<p>在调优阶段，同样使用上述网络，只是最后一层换成了 4096 —&gt; 21 的全连接网络。使用 PASCAL VOC 2007 的训练集，输出 21 维的类别标号，表示 20类 + 背景。考察一个候选框和当前图像上所有标定框重叠面积最大的一个。如果重叠比例大于0.5，则认为此候选框为此标定的类别；否则认为此候选框为背景。</p>
<h4 id="Step-3-类别判断"><a href="#Step-3-类别判断" class="headerlink" title="Step 3 : 类别判断"></a><strong>Step 3 :</strong> 类别判断</h4><p>对每一类目标，使用一个线性 SVM 二分类器进行判别，输入为深度网络输出的4096维特征，输出是否属于此类。 由于负样本很多，训练过程中需要使用 <a href="http://blog.csdn.net/u011534057/article/details/51222112">Hard negative mining</a> 方法。</p>
<p><strong>正样本：</strong> 本类的真值标定框；<br><strong>负样本：</strong> 考察每一个候选框，如果和本类所有标定框的重叠（IoU）都小于 0.3，则认定为负样本。</p>
<h4 id="Step-4：-位置精修"><a href="#Step-4：-位置精修" class="headerlink" title="Step 4： 位置精修"></a><strong>Step 4：</strong> 位置精修</h4><p><strong>目标检测问题的衡量标准是重叠面积</strong>：许多看似准确的检测结果，往往因为候选框不够准确，重叠面积很小。故需要一个位置精修步骤。</p>
<p><strong>回归器：</strong> 对每一类目标，使用一个线性脊回归器进行精修。正则项 λ=10000。 输入为深度网络 pool5 层的 4096 维特征，输出为 xy 方向的缩放和平移。</p>
<p><strong>训练样本：</strong> 判定为本类的候选框中，和真值重叠面积大于0.6的候选框。</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>论文深度学习引入检测领域，一举将 PASCAL VOC 上的检测率从 <strong>35.1%</strong> 提升到 <strong>53.7%</strong>。</p>
<p>算法前两个步骤（候选区域提取+特征提取）与待检测类别无关，可以在不同类之间共用。这两步在 GPU 上约需 13 秒。</p>
<p>同时检测多类时，需要倍增的只有后两步骤（判别+精修），都是简单的线性运算，速度很快。这两步对于 1000 类别只需 10 秒。</p>
<p><strong>不足：</strong> RCNN 需要对 SS 算法提取的每个 proposal 进行一次前向 CNN 实现特征提取，因此计算量很大，无法实时。此外，由于全连接层的存在，需要严格保证输入的 proposal 最终 resize 到相同的尺度大小，这在一定层度上造成了图像畸变，影响最终结果。另外，特征提取 CNN 的训练和 SVMs 分类器的训练在时间上是先后顺序，两者的训练方式独立，因此 SVMs 的训练 Loss 无法更新 SPP-Layer 之前的卷积层参数，因此即使采用更深的 CNN 网络进行特征提取，也无法保证 SVMs 分类器的准确率一定能够提升。</p>
<h2 id="SPP-Net"><a href="#SPP-Net" class="headerlink" title="SPP-Net"></a>SPP-Net</h2><p>　　论文链接：<a href="https://arxiv.org/pdf/1406.4729.pdf">Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition</a></p>
<p>　　RCNN 后面的进化中借鉴了许多 SPP Net 的思想，因此在介绍 Fast RCNN 与 Faster RCNN 之前，有必要先了解一下 SPP Net。</p>
<p><img src="http://static.zybuluo.com/guoxs/lxnbgcrp73kwe7l2za7hy4e3/5.png" alt="SPP-net VS traditional CNN"></p>
<h3 id="SPP-Layer"><a href="#SPP-Layer" class="headerlink" title="SPP Layer"></a>SPP Layer</h3><p>SPP 即<strong>图像金字塔池化</strong>，SPP-Net 区别于传统 CNN 网络的特点之一就是将金字塔思想加入到 CNN 中，<strong>实现了数据的多尺度输入，网络对输入图像大小不做特别要求</strong>。</p>
<p>传统的 CNN 中，卷积层对输入图像的大小并不做特别要求，对图像尺寸有要求的是全连接层。因此，在 RCNN 中，对于用 SS 方法提取的不同大小的 proposal 需要先通过 <strong>裁剪</strong> 或者 <strong>扩充</strong> 操作来讲 proposal 区域裁剪为统一大小，然后再利用 CNN 提取特征。SPP-Net 中，为了实现多尺度输入，作者在卷积层与全连接层之间加入了 SPP Layer，如下图所示，从而不必让每个 proposal 大小统一。</p>
<p><img src="http://static.zybuluo.com/guoxs/5ykm2xgihotfz0esgwmt1lhi/3.png" alt="SPP Layer"></p>
<p>SPP Layer 是怎么实现多尺度输入呢？其实想法很简单，把最后一层的 Pooling 层 改为 SPP-Pooling 层，也就是说，使用不同的池化步长对特征图进行多次池化，使得池化层输出的尺寸固定。</p>
<blockquote>
<p>假设原图输入为 224x224，对于 conv5 出来的输出是 13x13x256，可以理解为 256 个这样的 filter，每个 filter 对应于一张 13x13 的 response map。如果想上图那样将 response map 分为 1x1（金字塔底座），2x2（金字塔中间），4x4（金字塔顶座）三张子图，分别做 max pooling 后，出来的特征就是 （16+4+1）x 256 维度，这样不管输入图像尺寸如何，该池化层的输出永远是 （16+4+1）x 256 维度。</p>
</blockquote>
<h3 id="一次卷积"><a href="#一次卷积" class="headerlink" title="一次卷积"></a>一次卷积</h3><p><img src="http://static.zybuluo.com/guoxs/6u32kk61jpltyzpm6oszdqcm/4.png" alt="一次卷积"></p>
<p>在 RCNN 中，每一个候选框需要先 resize 到统一大小，然后分别作为 CNN 的输入，这样是十分低效的。SPP-Net 就是根据这个缺点做了优化，<strong>只对原图做一次卷积操作</strong> 得到整张图的 feature map，然后找到每个候选框在特征图上的映射区域，将此区域作为每个候选框的卷积特征输入到 SPP Layer 和之后的层（<a href="https://zhuanlan.zhihu.com/p/24780433">将原图 ROI 映射到 Feature map 上机制</a>）。这一过程相对于 RCNN 节省了大量的计算时间，从而使得 SPP-Net 比 RCNN 有一百多倍的提速。</p>
<p>SPP-Net 的整体流程还是 <code>Selective Search得到候选区域 --&gt; CNN提取ROI特征 --&gt; 类别判断 --&gt; 位置精修</code>，但是由于所有 ROI 的特征直接在 feature map 上提取，大大减少了卷积操作，提高了效率。<br><strong>不足：</strong> SPP-Net 的不足之处主要是训练是一个多阶段（multi-stage）的过程，实现多次较复杂。和 RCNN 一样，SPP-Net 首先选用 Selective Search 方法提取 proposals，然后用 CNN 实现特征提取，最后基于 SVMs 算法训练分类器，在此基础上还可以进一步学习检测目标的 boulding box。SPP-Net 的时间成本和空间代价较高，用于训练 SVMs 分类器的特征需要提前保存在磁盘，造成空间代价较高。SPP-Net 训练和测试还是较慢，无法达到实时性要求。</p>
<h2 id="Fast-RCNN"><a href="#Fast-RCNN" class="headerlink" title="Fast RCNN"></a>Fast RCNN</h2><p>论文链接：<a href="https://arxiv.org/pdf/1504.08083.pdf">Fast R-CNN</a><br>Github：<a href="https://github.com/rbgirshick/fast-rcnn">https://github.com/rbgirshick/fast-rcnn</a></p>
<p>RCNN 使用 SS 算法提取潜在的 bounding box 作为输入，有严重的速度瓶颈，这是因为计算机对所有 region 进行特征提取是会有重复计算。基于 R-CNN 和 SPP-Net 思想，RBG 提出了 Fast-RCNN 算法。 Fast RCNN 就是在 RCNN 的基础上采纳了 SPP Net 方法，对 RCNN 做了改进，使得性能进一步提高。同样使用最大规模的网络，Fast RCNN和RCNN相比，训练时间从84小时减少为9.5小时，<strong>测试时间从47秒减少为0.32秒</strong>。在PASCAL VOC 2007上的准确率相差无几，约在66%-67%之间.</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>具体而言，Fast RCNN 方法解决了 RCNN 方法的三个问题：</p>
<p><strong>1. 测试时速度慢</strong><br>RCNN 测试一张图片时需要提取很多候选框，而候选框之间有大量重叠，提取特征操作冗余。而 Fast RCNN 中将整张图片归一化后直接送入神经网络，在邻接时，才加入候选框信息，在末尾的少数几层处理每个候选框。</p>
<p><strong>2. 训练时速度慢</strong><br>原因同上。 而 Fast RCNN 在训练时，先将一张图像送入网络，紧接着送入从这幅图像上提取出的候选区域。这些候选区域的前几层特征不需要再重复计算。</p>
<p><strong>3. 训练时所需空间大</strong><br>CNN中独立的分类器和回归器需要大量特征作为训练样本。 Fast RCNN 把类别判断和位置精调统一用深度网络实现，不再需要额外存储。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="http://static.zybuluo.com/guoxs/epzx9t31ix6kqmmb75oh067r/6.png" alt="Fast-RCNN"></p>
<p>Fast-RCNN 的架构如上图所示。网络的初始输入是一张图像，通过一系列卷积层和Pooling层生成 feature map；在第五阶段结尾，输入由 Selective Search 方法生成的 P 个候选区域（图像序号×1+几何位置×4，序号用于训练），然后用 <strong>ROI</strong>（region of ineterst）层处理 <strong>最后一个卷积层</strong> 得到的 feature map，为每一个 proposal 生成一个 <strong>定长的特征向量 roi_pool5</strong>。ROI 层的输出 roi_pool5 接着输入到全连接层产生最终用于多任务学习的特征并用于计算多任务 Loss。</p>
<p><img src="http://static.zybuluo.com/guoxs/i439nsl3txml8ipuy0gwfhg6/7" alt="网络架构图"><br><img src="http://static.zybuluo.com/guoxs/w0aq7xupwubp0bvuvkxtfgo8/8" alt="网络架构图"></p>
<p>全连接输出包括两个分支：<br><strong>1.SoftMax Loss:</strong> 计算 K+1 类的分类 Loss 函数（其中K表示K个目标类别，1表示背景）；<br><strong>2.Regression Loss:</strong> 即 K+1 的分类结果相应的 Proposal 的 Bounding Box 四个角点坐标值。最终将所有结果通过<strong>非极大抑制</strong>处理产生最终的目标检测和识别结果。</p>
<p><strong>ROI Pooling Layer</strong><br>事实上，ROI Pooling Layer 是 SPP-Layer 的简化形式。SPP-Layer 是空间金字塔 Pooling 层，包括不同的尺度；ROI Layer 只包含一种尺度，如论文中所述 $7 \times 7$。这样对于 ROI Layer 的输入（r,c,h,w），ROI Layer 首先产生 $7 \times 7$ 个 $r \times c \times (h/7)\times(w/7)$ 的 Block(块)，然后用 Max-Pool 方式求出每一个 Block 的最大值，这样 ROI Layer 的输出是 $r\times c \times 7 \times 7$。</p>
<blockquote>
<p>roi_pool 层将每个候选区域均匀分成 M×N 块，对每块进行 max pooling。将特征图上大小不一的候选区域转变为大小统一的数据，送入下一层。</p>
</blockquote>
<p><strong>将所有模型整合到一个网络</strong><br>Fast R-CNN 的另一个创新点是在一个模型中联合训练卷积神经网络、分类器和边界框回归模型。在 R-CNN 中，我们使用了卷积神经网络来提取图像特征，用支持向量机来分类对象和用了回归模型来缩小边界框，但是Fast R-CNN使用单个网络模型来实现以上三个功能。</p>
<p>Fast-RCNN 在网络训练阶段采用了一些 trick，每个 mini-batch 由 N 个图片（N=2）中的 R 个 Proposal（R=128）组成。这种方式比从 128 张不同图片中提取 1 个 Proposal 的方式块 64 倍。当然，这种方式在一定程度会造成收敛速度变慢。</p>
<blockquote>
<p>注意：从 2 张图中选取 128 个 proposals 时，需要保证至少 25% 的 proposals 与 ground truth 的 IoU 超过 0.5，剩下的全部作为背景类。不需要其它任何数据扩增操作。</p>
</blockquote>
<p>另外，Fast-RCNN 无需 SVM 分类器，而是通过 Softmax Classifer 和 Bounding-Box Regressors 联合训练的方式更新所有参数。</p>
<blockquote>
<p>在检测阶段，作者使用 truncated SVD 优化较大的 FC 层，这样 ROI 数目较大时检测端速度会得到的加速。</p>
</blockquote>
<p>这样，整个模型的输入和输出分别为：</p>
<ul>
<li>输入：带多个区域建议的图像</li>
<li>输出：具有更紧密边界框的每个区域的对象类别</li>
</ul>
<h3 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h3><ol>
<li><p>多任务 Loss 学习方式可以提高算法准确率</p>
</li>
<li><p>多尺度图像训练 Fast-RCNN 与单尺度图像训练相比只能提升微小的 mAP，但是时间成本却增加了很多。因此，综合考虑训练时间和 mAP，作者建议<strong>直接用一种尺度的图像训练 Fast-R-CNN</strong></p>
</li>
<li><p>论文的结果表明 SoftmaxLoss 的方式比 SVMs 分类器的结果略好一点点，虽然这不能绝对性说明 SoftmaxLoss 好到哪儿去，但是至少不用再那么麻烦的去分步训练一个检测和识别网络了。</p>
</li>
<li><p>不是说 Proposal 提取的越多效果会越好，提的太多反而会导致 mAP 下降</p>
</li>
</ol>
<blockquote>
<p>Fast-RCNN 很重要的一个贡献是成功的让人们看到了 <strong>Region Proposal+CNN</strong> 这一框架实时检测的希望，原来多类检测真的可以在保证准确率的同时提升处理速度，也为后来的 Faster-RCNN 做下了铺垫。</p>
</blockquote>
<p><strong>不足</strong>：Fast RCNN 的不足之处主要在于 SS 方法是极耗时的，是测试时的计算瓶颈。</p>
<h2 id="Faster-RCNN"><a href="#Faster-RCNN" class="headerlink" title="Faster RCNN"></a>Faster RCNN</h2><p>论文链接：<a href="https://arxiv.org/pdf/1506.01497.pdf">Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks</a><br>Github：<a href="https://github.com/rbgirshick/py-faster-rcnn">https://github.com/rbgirshick/py-faster-rcnn</a></p>
<p>在 Fast RCNN 中，第一步需要先使用 Selective Search 方法提取图像中的 proposals。基于 CPU 实现的 Selective Search 提取一幅图像的所有 Proposals 需要约 <strong>2s</strong> 的时间。在不计入 proposal 提取情况下，Fast RCNN 基本可以实时进行目标检测。但是，如果从端到端的角度考虑，显然 proposal 提取成为影响端到端算法性能的瓶颈。目前最新的 EdgeBoxes 算法虽然在一定程度提高了候选框提取的准确率和效率，但是处理一幅图像仍然需要 <strong>0.2s</strong>。</p>
<p>因此，在 2015 年中期，由任少卿，何恺明，Ross Girshick 和孙剑组成的一个微软研究院团队提出新的 Faster RCNN 算法，该算法引入了 <strong>RPN 网络</strong>（Region Proposal Network）提取 proposals。RPN 网络是一个全卷积神经网络，通过共享卷积层特征可以实现 proposal 的提取，RPN 提取一幅像的 proposal 只需要 <strong>10ms</strong>。</p>
<p>Faster RCNN 算法由两大模块组成：</p>
<ul>
<li>PRN 候选框提取模块</li>
<li>Fast R-CNN 检测模块</li>
</ul>
<p>其中，RPN 是全卷积神经网络，用于提取候选框；Fast R-CNN 基于 RPN 提取的 proposal 检测并识别 proposal 中的目标。</p>
<p>faster-rcnn网络结构图：<br><img src="http://static.zybuluo.com/guoxs/x60zyw03d5kt2p3qo1kpdth4/9.png" alt="faster-rcnn网络结构"></p>
<h3 id="RPN-结构"><a href="#RPN-结构" class="headerlink" title="RPN 结构"></a>RPN 结构</h3><p><img src="http://static.zybuluo.com/guoxs/m6j9qna59j4xc9yxwy0lgpwe/10.png" alt="RPN"></p>
<p>RPN 是作者重点介绍的一种网络，如上图所示。在最后一层卷积层生成的 feature map 上用一个 $n \times n$ 的滑窗（论文中 n = 3）生成一个长度为 256（ZF 网络）维长度的全连接特征，提取 256 维的特征后产生两个分支：<br>1、<strong>reg layer</strong>，用来预测 proposal 的中心锚点对应的 proposal 的坐标 $x,y$ 和宽高 $w,h$；<br>2、<strong>cls layer</strong>，用来判定该 proposal 是前景还是背景。</p>
<p>滑动窗口的处理方式保证 reg layer 和 cls layer 关联了 feature map 的全部特征空间。</p>
<p>在RPN网络中，需要重点理解其中的 <strong>anchors 概念</strong>，Loss fucntions 计算方式和 <strong>RPN 层训练数据生成的具体细节</strong> 。</p>
<h3 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h3><p>Anchors 字面上可以理解为锚点，位于之前提到的 $n \times n$ 的 sliding window 的中心处。在 feature map 上的每个特征点预测多个 region proposals。具体作法是：<strong>把每个特征点映射回原图的感受野的中心点当成一个基准点</strong>，然后围绕这个基准点选取 k 个不同 scale、aspect ratio（纵横比） 的 anchor。论文中 3 个 scale（三种面积 ${ 128^2, 256^2, 521^2 }$），3 个 aspect ratio ( ${1:1,1:2,2:1}$ )</p>
<p><img src="http://static.zybuluo.com/guoxs/6kiu95c4r33u7mixnc5c5q5n/11.jpg" alt="Anchors"></p>
<p>因此，一个 anchor 可以理解为一个 anchor box 或一个 reference box，论文中定义 k = 9，即 3 种 scales 和 3 种 aspect_ratio 确定出当前 sliding window 位置处对应的 9 个 reference boxes， $4 \times k$ 个 reg layer 的输出和 $2 \times k$ 个 cls layer 的 score 输出。对于一幅 $W \times H$ 的 feature map，对应 $W \times H \times k$ 个锚点。所有的锚点都具有<strong>尺度不变性</strong>。</p>
<h3 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h3><p>在计算 Loss 值之前，作者设置了 anchors 的标定方法。<br><strong>正样本标定：</strong></p>
<ol>
<li>对每个标定的 ground true box 区域，与其重叠比例最大的 anchor 记为正样本 (保证每个 ground true 至少对应一个正样本 anchor )</li>
<li>对 1 中剩余的 anchor，如果其与某个标定区域重叠比例 (IoU) 大于 <strong>0.7</strong>，记为正样本（每个 ground true box 可能会对应多个正样本 anchor。但每个正样本 anchor 只可能对应一个grand true box）；如果其与任意一个标定的重叠比例都小于 <strong>0.3</strong>，记为负样本。</li>
<li>对 1、2 剩余的 anchor，弃去不用。</li>
<li>跨越图像边界的anchor弃去不用。</li>
</ol>
<p><strong>定义损失函数：</strong> 对于每个 anchor，首先后面接着一个二分类 softmax，有 2 个 score 输出用以表示其是一个物体的概率与不是一个物体的概率 $p_i$，然后再接上一个 bounding box 的 regressor 输出代表这个 anchor的 4 个坐标位置 $t_i$，因此 RPN 的总体 Loss 函数可以定义为 ：</p>
<script type="math/tex; mode=display">
L(\{p_i\}\{t_i\}) = \frac{1}{N_{cls}}\sum_iL_{cls}(p_i,p^\*\_i) + \lambda \frac{1}{N_{reg}}\sum_i p_i^\* L_{reg}(t_i,t^\*\_i)</script><p>$i$ 表示第 $i$ 个 anchor，当 anchor 是正样本时 $p_i^* =1$ ，是负样本则为 0 。  $t_i^*$ 表示 一个与正样本 anchor 相关的 ground true box 坐标 。</p>
<p>$x,y,w,h$ 分别表示 box 的中心坐标和宽高，$x,x_a,x^*$ 分别表示 predicted box, anchor box, and ground truth box （$y,w,h$ 同理）$t_i$ 表示 predict box 相对于 anchor box 的偏移，$t_i^*$ 表示 ground true box相对于anchor box 的偏移，学习目标自然就是让前者接近后者的值。</p>
<p><img src="http://static.zybuluo.com/guoxs/2hubieeboju17q4g7mwsh4u4/12.png" alt="t_i"></p>
<script type="math/tex; mode=display">
t_x = (x - x_a)/\omega_a, t_y = (y-y_a)/h_a,\\
t_w = log(w/w_a),t_h = log(h/h_a),\\
t_x^\* = (x^\* - x_a)/\omega_a, t_y^\* = (y^\*-y_a)/h_a,\\
t_w^\* = log(w^\*/w_a),t_h = log(h^\*/h_a)</script><p>其中 $L_{reg}$ 是：</p>
<script type="math/tex; mode=display">
 smooth_{L_1}(x) =
\begin{cases}
 0.5x^2 & |x| \leq 1 \\
|x|-0.5  & \text{otherwise}
\end{cases}</script><p>而总的网络有四个损失函数：</p>
<ul>
<li>RPN classification(anchor good/bad)</li>
<li>RPN regression(anchor —&gt; proposal)</li>
<li>Fast R-CNN classification(over classes)</li>
<li>Fast R-CNN regression(proposal —&gt; box)</li>
</ul>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>在训练 RPN 时，一个 Mini-batch 是由一幅图像中任意选取的 256 个 proposal 组成的，其中正负样本的比例为 1：1。如果正样本不足 128，则多用一些负样本以满足有 256 个 proposal 可以用于训练，反之亦然。训练 RPN 时，与 VGG 共有的层参数可以直接拷贝经 ImageNet 训练得到的模型中的参数；剩下没有的层参数用标准差为 0.01 的高斯分布初始化。</p>
<p><strong>RPN 与 Fast R-CNN 特征共享</strong><br>RPN　在提取得到　proposals　后，作者选择使用　Fast　R-CNN　实现最终目标的检测和识别。RPN　和　Fast　R-CNN　共用了　13　个　VGG　的卷积层，显然将这两个网络完全孤立训练不是明智的选择，论文作者作者采用交替训练阶段卷积层特征共享：</p>
<p><strong>第一步：</strong> 用 ImageNet 模型初始化，独立训练一个 RPN 网络；<br><strong>第二步：</strong> 仍然用 ImageNet 模型初始化，但是使用上一步 RPN 网络产生的 proposal 作为输入，训练一个 Fast-RCNN 网络，至此，两个网络每一层的参数完全不共享；<br><strong>第三步：</strong> 使用第二步的 Fast-RCNN 网络参数初始化一个新的 RPN 网络，<strong>但是把 RPN、Fast-RCNN 共享的那些卷积层的learning rate设置为0</strong>，也就是不更新，仅仅更新 RPN 特有的那些网络层，重新训练，此时，两个网络已经共享了所有公共的卷积层；<br><strong>第四步：</strong> 仍然固定共享的那些网络层，把 Fast-RCNN 特有的网络层也加入进来，形成一个 <strong>unified network</strong>，继续训练，fine tune Fast-RCNN 特有的网络层，此时，该网络已经实现我们设想的目标，即网络内部预测 proposal 并实现检测的功能。</p>
<p>整个过程图示如下：<br><img src="http://static.zybuluo.com/guoxs/vs5fus7yrfw51vwt7xnqma95/13.png" alt="-Step Alternating Training"></p>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>以下列出 R-CNN、Fast R-CNN 与 Faster R-CNN 的速度对比：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Time &amp; mAP</th>
<th style="text-align:center">R-CNN</th>
<th style="text-align:center">Fast R-CNN</th>
<th style="text-align:center">Faster R-CNN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Test time per image (with proposals)</td>
<td style="text-align:center">50s</td>
<td style="text-align:center">2s</td>
<td style="text-align:center">0.2s</td>
</tr>
<tr>
<td style="text-align:center">Speedup</td>
<td style="text-align:center">1x</td>
<td style="text-align:center">25x</td>
<td style="text-align:center">250x</td>
</tr>
<tr>
<td style="text-align:center">mAP(VOC 2007)</td>
<td style="text-align:center">66.0</td>
<td style="text-align:center">66.9</td>
<td style="text-align:center">66.9</td>
</tr>
</tbody>
</table>
</div>
<p>Faster R-CNN的主要贡献是设计了提取候选区域的网络RPN，代替了费时的选择性搜索，使得检测速度大幅提高。</p>
<p>最后，总结以下这三大算法的步骤：</p>
<blockquote>
<p><strong>RCNN</strong><br>　　1.    在图像中确定约 1000-2000 个候选框 (使用选择性搜索)<br>　　2. 每个候选框内图像块缩放至相同大小，并输入到 CNN 内进行特征提取<br>　　3.    对候选框中提取出的特征，使用分类器判别是否属于一个特定类<br>　　4.    对于属于某一特征的候选框，用回归器进一步调整其位置</p>
<p><strong>Fast RCNN</strong><br>　　1.    在图像中确定约 1000-2000 个候选框 (使用选择性搜索)<br>　　2.    对整张图片输进 CNN ，得到 feature map<br>　　3.    将每个候选框在 feature map 上的映射 patch 作为每个候选框的卷积特征输入到 SPP layer 和之后的层<br>　　4.    对候选框中提取出的特征，使用分类器判别是否属于一个特定类<br>　　5.    对于属于某一特征的候选框，用回归器进一步调整其位置</p>
<p><strong>Faster RCNN</strong><br>　　1.    对整张图片输进 CNN，得到 feature map<br>　　2.    卷积特征输入到 RPN，得到候选框的特征信息<br>　　3.    对候选框中提取出的特征，使用分类器判别是否属于一个特定类<br>　　4.    对于属于某一特征的候选框，用回归器进一步调整其位置</p>
</blockquote>
<h2 id="YOLO"><a href="#YOLO" class="headerlink" title="YOLO"></a>YOLO</h2><p>论文链接：<a href="https://arxiv.org/pdf/1506.02640.pdf">You Only Look Once: Unified, Real-Time Object Detection</a><br>GitHub：<a href="https://github.com/pjreddie/darknet">https://github.com/pjreddie/darknet</a></p>
<h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><p>从 R-CNN 到 Fast R-CNN 再到 Faster RCNN 一直采用的思路是 proposal + 分类，精度已经很高，但是速度还不行。 YOLO 提供了另一种更为直接的思路： 直接在输出层回归 bounding box 的位置和 bounding box 所属的类别(整张图作为网络的输入，把 Object Detection 的问题转化成一个 Regression 问题)。</p>
<p>YOLO的主要特点：</p>
<ul>
<li>速度快，能够达到实时的要求。在 Titan X 的 GPU 上 能够达到 45 帧每秒，基本达到实时要求。</li>
<li>使用全图作为 Context 信息，背景错误（把背景错认为物体）比较少。</li>
<li>泛化能力强。</li>
</ul>
<h3 id="YOLO的实现方法"><a href="#YOLO的实现方法" class="headerlink" title="YOLO的实现方法"></a>YOLO的实现方法</h3><p><img src="http://static.zybuluo.com/guoxs/lisbjatk5vqkawhjqco8iyfz/14.png" alt="YOLO 的实现流程"></p>
<p>YOLO 的实现流程：</p>
<ul>
<li>将一幅图像分成 SxS 个网格 (grid cell)，<strong>如果某个 object 的中心 落在这个网格中，则这个网格就负责预测这个object</strong></li>
<li>每个网格要预测 B 个 bounding box，每个 bounding box 除了要回归自身的位置之外，还要附带预测一个 confidence 值。<br>这个 confidence 代表了所预测的 box 中含有 object 的<strong>置信度</strong>和这个 box 预测的<strong>有多准</strong>两重信息，其值是这样计算的：$Pr(Object) \times IoU^{truth}_{pred}$<br>其中如果有 object 落在一个 grid cell 里，第一项取 1，否则取 0。 第二项是预测的 bounding box 和实际的 groundtruth 之间的 IoU 值。</li>
<li>每个 bounding box 要预测 $(x, y, w, h)$ 和 confidence 共 5 个值，每个网格还要预测一个类别信息，记为 C 类。则 $S \times S$ 个网格，每个网格要预测 B 个 bounding box还要预测 C 个 categories。输出就是 $S \times S \times (5 \times B + C)$ 的一个tensor。</li>
</ul>
<blockquote>
<p>class 信息是针对每个网格的，confidence 信息是针对每个 bounding box 的。</p>
</blockquote>
<ul>
<li>举例说明: 在 PASCAL VOC 中，图像输入为 448x448，取 S=7，B=2，一共有 20 个类别(C=20)。则输出就是 7x7x30 的一个tensor。<br>网络结构借鉴了 GoogLeNet 。24个卷积层，2个全链接层。整个网络结构如下图：</li>
</ul>
<p><img src="http://static.zybuluo.com/guoxs/59m2b9ocmiw29o4s5o3bx87m/15.png" alt="网络结构图"></p>
<ul>
<li><p>在 test 的时候，每个网格预测的 class 信息和 bounding box 预测的 confidence 信息相乘，就得到每个 bounding box 的 class-specific confidence score:<br>$Pr(Class<em>i|Object)*Pr(Object)*IOU^{truth}</em>{pred} = Pr(Class<em>i)*IOU^{truth}</em>{pred}$</p>
<p>等式左边第一项就是每个网格预测的类别信息，第二三项就是每个 bounding box 预测的 confidence。这个乘积即 encode 了预测的 box 属于某一类的概率，也有该 box 准确度的信息。</p>
</li>
<li><p>得到每个 box 的 class-specific confidence score 以后，设置阈值，滤掉得分低的 boxes，对保留的 boxes 进行 NMS（非极大值抑制）处理，就得到最终的检测结果。</p>
</li>
</ul>
<h3 id="损失函数设计"><a href="#损失函数设计" class="headerlink" title="损失函数设计"></a>损失函数设计</h3><p><img src="http://static.zybuluo.com/guoxs/h70xkvhtzazf3ufi69n1vqer/loss" alt="loss"></p>
<p>损失函数的设计目标就是让坐标 $(x,y,w,h), confidence，classification$  这个三个方面达到很好的平衡。简单的全部采用了 sum-squared error loss 来做这件事会有以下不足：</p>
<blockquote>
<p>a) 8维的 localization error 和 20 维的 classification error 同等重要显然是不合理的；</p>
<p>b)如果一个网格中没有object（一幅图中这种网格很多），那么就会将这些网格中的box的confidence push到0，相比于较少的有object的网格，这种做法是overpowering的，这会导致网络不稳定甚至发散。</p>
</blockquote>
<p><strong>解决方案如下：</strong></p>
<ol>
<li>更重视 8 维的坐标预测，给这些损失前面赋予更大的 loss weight, 记为 $\lambda_{coord}$ ,在 pascal VOC 训练中取 5。（上图第一部分）</li>
<li>对没有 object 的 bbox 的 confidence loss，赋予小的 loss weight，记为 $\lambda_{noobj}$ ，在 pascal VOC 训练中取 0.5。（上图第三部分）</li>
<li>有 object 的 bbox 的 confidence loss (上图第二部分) 和类别的 loss （上图第四部分）的 loss weight 正常取 1。</li>
<li>对不同大小的 bbox 预测中，相比于大 bbox预测偏一点，小 box 预测偏一点更不能忍受。而 sum-square error loss 中对同样的偏移 loss 是一样。 为了缓和这个问题，作者用了一个比较取巧的办法，就是将 box 的 width 和 height 取平方根代替原本的 height 和 width。</li>
<li>一个网格预测多个 bounding box，在训练时我们希望每个 object（ground true box）只有一个 bounding box 专门负责（一个object 一个bbox）。具体做法是<strong>与ground true box（object）的 IOU 最大的 bounding box 负责该 ground true box(object) 的预测</strong>。这种做法称作 <strong>bounding box predictor 的 specialization (专职化)</strong>。每个预测器会对特定（sizes,aspect ratio or classed of object）的 ground true box 预测的越来越好。</li>
</ol>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul>
<li><p>YOLO对相互靠的很近的物体（挨在一起且中点都落在同一个格子上的情况），还有很小的群体 检测效果不好，这是因为一个网格中只预测了两个框，并且只属于一类。</p>
</li>
<li><p>测试图像中，当同一类物体出现的不常见的长宽比和其他情况时<strong>泛化能力偏弱</strong>。</p>
</li>
<li><p>由于损失函数的问题，定位误差是影响检测效果的主要原因，尤其是大小物体的处理上，还有待加强。</p>
</li>
</ul>
<h2 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h2><p>论文链接：<a href="https://arxiv.org/pdf/1512.02325.pdf">SSD: Single Shot MultiBox Detector</a><br>GitHub：<a href="https://github.com/weiliu89/caffe/tree/ssd">https://github.com/weiliu89/caffe/tree/ssd</a></p>
<p>基于“Proposal + Classification” 的 Object Detection 的方法，R-CNN 系列（R-CNN、SPPnet、Fast R-CNN 以及 Faster R-CNN），取得了非常好的结果，但是在速度方面离实时效果还比较远在提高 mAP 的同时兼顾速度，逐渐成为 Object Detection 未来的趋势。 YOLO 虽然能够达到实时的效果，但是其 mAP 与刚面提到的 state of art 的结果有很大的差距。 YOLO 有一些缺陷：每个网格只预测一个物体，容易造成漏检；对于物体的尺度相对比较敏感，对于尺度变化较大的物体泛化能力较差。针对 YOLO 中的这些不足，该论文提出的方法 SSD 在这两方面都有所改进，同时兼顾了 mAP 和实时性的要求。在满足实时性的条件下，接近 state of art 的结果。对于输入图像大小为 300*300 在 VOC2007 test 上能够达到 58 帧每秒( Titan X 的 GPU )，72.1% 的 mAP。输入图像大小为 500 x 500 , mAP 能够达到 75.1%。</p>
<p>作者的思路就是Faster R-CNN+YOLO，利用 YOLO 的思路和 Faster R-CNN 的 anchor box 的思想。</p>
<p>论文采用 VGG16 为基础网络结构，使用前面的前 5 层，然后利用 astrous 算法将 fc6 和 fc7 层转化成两个卷积层。再额外增加了 3 个卷积层，和一个 average pool 层。 <strong>不同层次的 feature map 分别用于 default box 的偏移以及不同类别得分的预测</strong>，最后通过 nms得到最终的检测结果。</p>
<p><img src="http://static.zybuluo.com/guoxs/wk33gcqhji7g25vx25o9vw7y/17.png" alt="SSD net"></p>
<p>这些增加的卷积层的 feature map 的大小变化比较大，允许能够检测出不同尺度下的物体。SSD去掉了全连接层，每一个输出只会感受到目标周围的信息，包括上下文。这样来做就增加了合理性。并且不同的feature map，预测不同宽高比的图像，这样比YOLO增加了预测更多的比例的box。</p>
<p><img src="http://static.zybuluo.com/guoxs/3rwb6wm3hxeq7xrs1cc8a66u/1.png" alt="SSD net"></p>
<p><strong>多尺度feature map得到 default boxs及其 4个位置偏移和21个类别置信度</strong><br>对于不同尺度 feature map（ 上图中 38x38x512，19x19x512, 10x10x512, 5x5x512, 3x3x512, 1x1x256） 的上的所有特征点： 以 5x5x256 为例 它的 defalut_boxes = 6，其 Detector &amp; classifier 4 展开结构如下：</p>
<p><img src="http://static.zybuluo.com/guoxs/620dyv9vpyfr2tfxsyyliti2/ssd1.jpg" alt="ssd"></p>
<p>首先按照不同的 scale 和 ratio 生成 k 个 default boxes。</p>
<h2 id="YOLOv2"><a href="#YOLOv2" class="headerlink" title="YOLOv2"></a>YOLOv2</h2><p>论文链接：<a href="https://arxiv.org/abs/1612.08242">YOLO9000: Better, Faster, Stronger</a><br>GitHub：<a href="https://github.com/pjreddie/darknet">https://github.com/pjreddie/darknet</a><br>     or <a href="https://github.com/philipperemy/yolo-9000">https://github.com/philipperemy/yolo-9000</a></p>
<p>不管是 Faster R-CNN 还是 SSD，它们生成的锚框仍然有大量是相互重叠的，从而导致仍然有大量的区域被重复计算了。YOLO 试图来解决这个问题。它将图片特征均匀的切成 $S \times S $ 块，每一块当做一个锚框。每个锚框预测 B 个边框，以及这个锚框主要包含哪个物体。整体架构如下图所示：</p>
<div align="center">
  <img src="/Blog/.io//yolo.svg">
  <p> </p>
</div>

<p>这是 YOLO 的解决方案， 而 YOLO v2 在原来的基础上对 YOLO 进行一些地方的改进，其主要包括：</p>
<ol>
<li>使用更好的卷积神经网络来做特征提取，使用更大输入图片$448\times 448$使得特征输出大小增大到$13\times 13$</li>
<li>不再使用均匀切来的锚框，而是对训练数据里的真实锚框做聚类，然后使用聚类中心作为锚框。相对于SSD和Faster R-CNN来说可以大幅降低锚框的个数。</li>
<li>不再使用YOLO的全连接层来预测，而是同SSD一样使用卷积。例如假设使用5个锚框（聚类为5类），那么物体分类使用通道数是<code>5*(1+num_classes)</code>的$1\times 1$卷积，边框回归使用通道数<code>4*5</code>.</li>
</ol>
<h2 id="mask-RCNN"><a href="#mask-RCNN" class="headerlink" title="mask-RCNN"></a>mask-RCNN</h2><p>论文链接：<a href="https://arxiv.org/abs/1703.06870">Mask R-CNN</a><br>GitHub：<a href="https://github.com/matterport/Mask_RCNN">https://github.com/matterport/Mask_RCNN</a><br>     or <a href="https://github.com/CharlesShang/FastMaskRCNN">https://github.com/CharlesShang/FastMaskRCNN</a></p>
<p>Mask R-CNN 在 Faster R-CNN 上加入了一个新的像素级别的预测层，它不仅对一个锚框预测它对应的类和真实的边框，而且它会判断这个锚框类每个像素对应的哪个物体还是只是背景。后者是语义分割要解决的问题。Mask R-CNN 使用了 <a href="https://arxiv.org/abs/1411.4038">全连接网络（FCN）</a> 来完成这个预测。当然这也意味这训练数据必须有像素级别的标注，而不是简单的边框。</p>
<div align="center">
  <img src="/Blog/.io//mask-rcnn.svg">
  <p> </p>
</div>

<p>因为 FCN 会精确预测每个像素的类别，就是输入图片中的每个像素都会在标注中对应一个类别。对于输入图片中的一个锚框，我们可以精确的匹配到像素标注中对应的区域。但是 PoI 池化是作用在卷积之后的特征上，其默认是将锚框做了定点化。例如假设选择的锚框是 $(x,y,w,h)$，且特征抽取将图片变小了 16 倍，就是如果原始图片是 $256\times 256$，那么特征大小就是 $16\times 16$ 。这时候在特征上对应的锚框就是变成了 $(\lfloor x/16 \rfloor, \lfloor y/16 \rfloor, \lfloor w/16 \rfloor, \lfloor h/16 \rfloor)$。如果 $x,y,w,h$ 中有任何一个不被 16 整除，那么就可能发生错位。同样道理，在上面的样例中我们看到，如果锚框的长宽不被池化大小整除，那么同样会定点化，从而带来错位。</p>
<p>通常这样的错位只是在几个像素之间，对于分类和边框预测影响不大。但对于像素级别的预测，这样的错位可能会带来大问题。Mask R-CNN 提出一个 RoI Align 层，它类似于 RoI 池化层，但是去除掉了定点化步骤，就是移除了所有 $\lfloor \cdot \rfloor$。如果计算得到的表框不是刚好在像素之间，那么我们就用四周的像素来线性插值得到这个点上的值。</p>
<p>对于一维情况，假设我们要计算 $x$ 点的值 $f(x)$，那么我们可以用 $x$ 左右的整点的值来插值：</p>
<script type="math/tex; mode=display">f(x) = (\lfloor x \rfloor + 1-x)f(\lfloor x \rfloor) + (x-\lfloor x \rfloor)f(\lfloor x \rfloor + 1)</script><p>我们实际要使用的是二维差值来估计 $f(x,y)$，我们首先在 $x$ 轴上差值得到 $f(x,\lfloor y \rfloor)$ 和 $f(x,\lfloor y \rfloor+1)$ ，然后根据这两个值来差值得到 $f(x, y)$ .</p>
<p>本博文参考：</p>
<p><a href="http://blog.csdn.net/shenxiaolu1984/article/details/51066975">【目标检测】RCNN算法详解</a><br><a href="http://blog.csdn.net/zhang_shuai12/article/details/52554604">object detection（物体检测）系列论文梳理</a><br><a href="https://zhuanlan.zhihu.com/p/24774302?refer=xiaoleimlnote">SPPNet-引入空间金字塔池化改进RCNN</a><br><a href="http://blog.csdn.net/shenxiaolu1984/article/details/51036677">【目标检测】Fast RCNN算法详解</a><br><a href="https://zhuanlan.zhihu.com/p/26655034">CNN图像分割进化史：三年从R-CNN到Mask R-CNN</a><br><a href="http://blog.csdn.net/shenxiaolu1984/article/details/51152614">【目标检测】Faster RCNN算法详解</a><br><a href="https://zhuanlan.zhihu.com/p/24916624">Faster R-CNN</a><br><a href="http://blog.csdn.net/u010167269/article/details/52563573">论文阅读：SSD: Single Shot MultiBox Detector</a><br><a href="https://zhuanlan.zhihu.com/p/24954433?refer=xiaoleimlnote">SSD</a></p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>MXNet/Gluon 深度学习笔记 (七) —— 样式迁移</title>
    <url>/Blog/2018/02/06/deep-learning-limu-note07/</url>
    <content><![CDATA[<p>今天我们要讲的是利用神经网络来“修图”，即我们通过神经网络，将特定的照片风格从一张图片移植到另一张图片，这个过程我们叫做<strong>样式迁移</strong>。如下图所示：<br><img src="/Blog/.io//neural-style.svg" alt="neural-style"><br><span id="more"></span></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>神经网络的这一应用最先由 <a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Gatys_Image_Style_Transfer_CVPR_2016_paper.pdf">Gatys等人</a> 开创，思路是通过匹配卷积神经网络的中间层输出来训练出合成图片，流程如下所示：</p>
<p><img src="/Blog/.io//neural-style2.svg" alt="neural-style2"></p>
<ul>
<li>首先挑选一个卷积神经网络来提取特征，选择它的特定层来匹配样式，特定层来匹配内容。示意图中假设选择层 1,2,4 作为样式层，层 3 作为内容层；</li>
<li>输入样式图片并保存样式层输出，记第 $i$ 层输出为 $s_i$</li>
<li>输入内容图片并保存内容层输出，记第 $i$ 层输出为 $c_i$</li>
<li><p>初始化合成图片 $x$ 为随机值或者其他更好的初始值。然后进行迭代使得用 $x$ 抽取的特征能够匹配上 $s_i$ 和 $c_i$。迭代如下步骤直至收敛：</p>
<ul>
<li>输入 $x$ 计算样式层和内容层输出，记第 $i$ 层输出为 $y_i$</li>
<li>使用样式损失函数来计算 $y_i$ 和 $s_i$ 的差异</li>
<li>使用内容损失函数来计算 $y_i$ 和 $c_i$ 的差异</li>
<li>对损失求和并对输入 $x$ 求导，记导数为 $g$</li>
<li>更新 $x$， 例如 $x = x - \eta g$</li>
</ul>
<p>内容损失函数通常使用回归中用到的均方误差。对于样式，我们可以将它看成是像素点在每个通道的<strong>统计分布</strong>。例如要匹配两张图片的颜色，我们的一个做法是匹配这两张图片在 RGB 这三个通道上的直方图。更一般的，假设卷积层的输出格式是 $c \times h \times w$，既 <code>channels x height x width</code>。那么我们可以把它变形成 $c \times hw$ 的 2D 数组，并将它看成是一个维度为 $c$ 的随机变量采样到的 $hw$ 个点。所谓的样式匹配就是使得两个 $c$ 维随机变量统计分布一致。</p>
<p>匹配统计分布常用的做法是<strong>冲量匹配</strong>，就是说使得他们有一样的均值，协方差，和其他高维的冲量（三阶矩等）。为了计算简单起见，这里假设卷积输出已经是均值为 0 了，而且我们只匹配协方差。也就是说，样式损失函数就是对 $s_i$ 和 $y_i$ 计算 Gram 矩阵然后应用均方误差</p>
<script type="math/tex; mode=display">\textrm{styleloss}(s_i, y_i) = \frac{1}{c^2hw} \| s_i s_i^T - y_i y_i^T \|\_F</script><p>这里假设 $s_i$ 和 $y_i$ 已经变形成 $c \times hw$ 的 2D 矩阵。</p>
<p>接下来我们使用 gluon 来实现简单的“样式迁移”。</p>
</li>
</ul>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>我们使用如下的水墨风格的橡树图作为样式图片，实拍的松树图作为内容图片，我们最终要的效果是得到一张水墨风格的松树图片。<br>样式图片：<br><img src="/Blog/.io//autumn_oak.jpg" alt="autumn_oak"></p>
<p>内容图片：<br><img src="/Blog/.io//pine-tree.jpg" alt="pine-tree"><br>我们事先定义图像预处理函数与后处理函数，预处理函数将原始图像进行归一化并转换成神经网络接受的输入格式，后处理函数将网络的输出还原成图片格式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"></span><br><span class="line">rgb_mean = nd.array([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>])</span><br><span class="line">rgb_std = nd.array([<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess</span>(<span class="params">img, image_shape</span>):</span></span><br><span class="line">    img = image.imresize(img, *image_shape)</span><br><span class="line">    img = (img.astype(<span class="string">&#x27;float32&#x27;</span>)/<span class="number">255</span> - rgb_mean) / rgb_std</span><br><span class="line">    <span class="keyword">return</span> img.transpose((<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>)).expand_dims(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postprocess</span>(<span class="params">img</span>):</span></span><br><span class="line">    img = img[<span class="number">0</span>].as_in_context(rgb_std.context)</span><br><span class="line">    <span class="keyword">return</span> (img.transpose((<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>))*rgb_std + rgb_mean).clip(<span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>rgb_std</code> 和 <code>rgb_mean</code> 的数值是由 ImageNet 数据库 统计而得，用这两个数据归一化图片更具有普适性。</p>
</blockquote>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>我们使用原论文使用的VGG 19模型。并下载在Imagenet上训练好的权重。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon.model_zoo <span class="keyword">import</span> vision <span class="keyword">as</span> models</span><br><span class="line"></span><br><span class="line">pretrained_net = models.vgg19(pretrained=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>该网络的结构如下图所示：<br><img src="/Blog/.io//VGG19.png" alt="VGG19"><br>上图中，每两个卷积层加 relu 层构成一个卷积块，卷积块与卷积块之间使用 MaxPool2D 层进行分割。</p>
<p>我们有很多种选择来决定使用那些层作为样式层，哪些层作为内容匹配层。通常越靠近输入层越容易匹配内容和样式的细节信息，越靠近输出则越倾向于匹配语义的内容和全局的样式。这里我们按照原论文中使用每个卷积块的第一个卷积层输出来匹配样式，第四个块中的最后一个卷积层来匹配内容，即有如下数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">style_layers = [<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">19</span>,<span class="number">28</span>]</span><br><span class="line">content_layers = [<span class="number">25</span>]</span><br></pre></td></tr></table></figure>
<p>使用我们需要的 VGG 中间层来构建一个新的网络：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_net</span>(<span class="params">pretrained_net, content_layers, style_layers</span>):</span></span><br><span class="line">    net = nn.Sequential()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>(content_layers+style_layers)+<span class="number">1</span>):</span><br><span class="line">        net.add(pretrained_net.features[i])</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line">net = get_net(pretrained_net, content_layers, style_layers)</span><br></pre></td></tr></table></figure><br>给定输入 x，使用 net(x) 只能拿到最后的输出，但是由上分析可知我们还需要net的中间层输出，因此我们逐层计算，并保留需要的输出：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_features</span>(<span class="params">x, content_layers, style_layers</span>):</span></span><br><span class="line">    contents = []</span><br><span class="line">    styles = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(net)):</span><br><span class="line">        x = net[i](x)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> style_layers:</span><br><span class="line">            styles.append(x)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> content_layers:</span><br><span class="line">            contents.append(x)</span><br><span class="line">    <span class="keyword">return</span> contents, styles</span><br></pre></td></tr></table></figure></p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>由上分析可知损失函数由两部分组成，一部分是内容匹配的损失，这是一个经典的回归问题，因此我们使用均方误差来计算内容匹配的损失：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">content_loss</span>(<span class="params">yhat, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (yhat-y).square().mean()</span><br></pre></td></tr></table></figure><br>另一部分为样式匹配损失，我们通过 Gram 矩阵来计算它：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gram</span>(<span class="params">x</span>):</span></span><br><span class="line">    c = x.shape[<span class="number">1</span>]</span><br><span class="line">    n = x.size / x.shape[<span class="number">1</span>]</span><br><span class="line">    y = x.reshape((c, <span class="built_in">int</span>(n)))</span><br><span class="line">    <span class="keyword">return</span> nd.dot(y, y.T) / n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">style_loss</span>(<span class="params">yhat, gram_y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (gram(yhat) - gram_y).square().mean()</span><br></pre></td></tr></table></figure></p>
<p>然而在实际实验中，当使用靠近输出层的高层输出来拟合时，经常可以观察到学到的图片里面有大量高频噪音。这个有点类似老式天线电视机经常遇到的白噪音。有多种方法来降噪，例如可以加入模糊滤镜，或者使用<a href="https://en.wikipedia.org/wiki/Total_variation_denoising">总变差降噪（Total Variation Denoising）</a>。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/en/e/e8/ROF_Denoising_Example.png" alt></p>
<p>假设 $x_{i,j}$ 表示像素 $(i,j)$，那么我们加入下面的损失函数，它使得邻近的像素值相似：</p>
<script type="math/tex; mode=display">
\sum_{i,j} |x_{i,j} - x_{i+1,j}| + |x_{i,j} - x_{i,j+1}|</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tv_loss</span>(<span class="params">yhat</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span>*((yhat[:,:,<span class="number">1</span>:,:] - yhat[:,:,:-<span class="number">1</span>,:]).<span class="built_in">abs</span>().mean() +</span><br><span class="line">                (yhat[:,:,:,<span class="number">1</span>:] - yhat[:,:,:,:-<span class="number">1</span>]).<span class="built_in">abs</span>().mean())</span><br></pre></td></tr></table></figure>
<p>因此，总损失函数应该是上诉三种损失的加权和。通过调整权重值我们可以控制学到的图片是否保留更多样式，更多内容，还是更加干净。注意到样式匹配中我们使用了5个层的输出，这里我们对靠近输入的层给予比较大的权重。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channels = [net[l].weight.shape[<span class="number">0</span>] <span class="keyword">for</span> l <span class="keyword">in</span> style_layers]</span><br><span class="line">style_weights = [<span class="number">1e4</span>/n**<span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> channels]</span><br><span class="line">content_weights = [<span class="number">1</span>]</span><br><span class="line">tv_weight = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_loss</span>(<span class="params">loss, preds, truths, weights</span>):</span></span><br><span class="line">    <span class="keyword">return</span> nd.add_n(*[w*loss(yhat, y) <span class="keyword">for</span> w, yhat, y <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">        weights, preds, truths)])</span><br></pre></td></tr></table></figure></p>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>首先我们定义两个函数，他们分别对源内容图片和源样式图片提取特征。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_contents</span>(<span class="params">image_shape</span>):</span></span><br><span class="line">    content_x = preprocess(content_img, image_shape).copyto(ctx)</span><br><span class="line">    content_y, _ = extract_features(content_x, content_layers, style_layers)</span><br><span class="line">    <span class="keyword">return</span> content_x, content_y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_styles</span>(<span class="params">image_shape</span>):</span></span><br><span class="line">    style_x = preprocess(style_img, image_shape).copyto(ctx)</span><br><span class="line">    _, style_y = extract_features(style_x, content_layers, style_layers)</span><br><span class="line">    style_y = [gram(y) <span class="keyword">for</span> y <span class="keyword">in</span> style_y]</span><br><span class="line">    <span class="keyword">return</span> style_x, style_y</span><br></pre></td></tr></table></figure><br>训练过程跟传统的神经网络训练的主要的主要不同在于</p>
<ul>
<li>损失函数更加复杂。</li>
<li>我们只对输入进行更新，这个意味着我们需要对输入 <code>x</code> 预先分配了梯度。</li>
<li>我们可能会替换匹配内容和样式的层，和调整他们之间的权重，来得到不同风格的输出。这里我们对梯度做了一般化，使得不同参数下的学习率不需要太大变化。</li>
<li>仍然使用简单的梯度下降，但每 <em>n</em> 次迭代我们会减小一次学习率</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">x, max_epochs, lr, lr_decay_epoch=<span class="number">200</span></span>):</span></span><br><span class="line">    tic = time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_epochs):</span><br><span class="line">        <span class="keyword">with</span> autograd.record():</span><br><span class="line">            content_py, style_py = extract_features(</span><br><span class="line">                x, content_layers, style_layers)</span><br><span class="line">            content_L  = sum_loss(</span><br><span class="line">                content_loss, content_py, content_y, content_weights)</span><br><span class="line">            style_L = sum_loss(</span><br><span class="line">                style_loss, style_py, style_y, style_weights)</span><br><span class="line">            tv_L = tv_weight * tv_loss(x)</span><br><span class="line">            loss = style_L + content_L + tv_L</span><br><span class="line"></span><br><span class="line">        loss.backward()</span><br><span class="line">        x.grad[:] /= x.grad.<span class="built_in">abs</span>().mean()+<span class="number">1e-8</span></span><br><span class="line">        x[:] -= lr * x.grad</span><br><span class="line">        <span class="comment"># add sync to avoid large mem usage</span></span><br><span class="line">        nd.waitall()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">and</span> i % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;batch %3d, content %.2f, style %.2f, &#x27;</span></span><br><span class="line">                  <span class="string">&#x27;TV %.2f, time %.1f sec&#x27;</span> % (</span><br><span class="line">                i, content_L.asscalar(), style_L.asscalar(),</span><br><span class="line">                tv_L.asscalar(), time()-tic))</span><br><span class="line">            tic = time()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">and</span> i % lr_decay_epoch == <span class="number">0</span>:</span><br><span class="line">            lr *= <span class="number">0.1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;change lr to &#x27;</span>, lr)</span><br><span class="line"></span><br><span class="line">    plt.imshow(postprocess(x).asnumpy())</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>下面开始训练：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;..&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> utils</span><br><span class="line"></span><br><span class="line">image_shape = (<span class="number">1200</span>,<span class="number">800</span>)</span><br><span class="line"></span><br><span class="line">ctx = utils.try_gpu()</span><br><span class="line">net.collect_params().reset_ctx(ctx)</span><br><span class="line"></span><br><span class="line">content_x, content_y = get_contents(image_shape)</span><br><span class="line">style_x, style_y = get_styles(image_shape)</span><br><span class="line"></span><br><span class="line">x = content_x.copyto(ctx)</span><br><span class="line">x.attach_grad()</span><br><span class="line"></span><br><span class="line">y = train(x, <span class="number">500</span>, <span class="number">0.1</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure><br>最后得到的合成图片如下图所示：<br><img src="/Blog/.io//result.png" alt="result"></p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>MXNet/Gluon 深度学习笔记 (八) —— 语义分割总结</title>
    <url>/Blog/2018/02/06/deep-learning-limu-note08/</url>
    <content><![CDATA[<p>语义分割一直是计算机视觉领域非常重要的研究方向，随着深度学习的发展，语义分割任务也得到了十足的进步, 本文从论文出发综述语义分割方法.</p>
<p>语义分割是指像素级的图像理解，即对图像中的每个像素标注所属的类别。示例图如下所示：</p>
<p><img src="/Blog/.io//seg_pic.jpg" alt="seg_pic"></p>
<p>左图：输入图像；右图：图像的语义分割结果（源于：<a href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/segexamples/index.html">PASCAL VOC2011 Example SegmentationsPASCAL VOC2011 Example Segmentations</a>）</p>
<p>除了识别图中的摩托车和车手外，我们还要标注每个目标的边界。因此，不同于图像分割，语义分割需要模型能够进行密集的像素级分类。</p>
<p>其中，<a href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/">VOC2012</a> 和 <a href="http://cocodataset.org/">MSCOCO</a> 是语义分割领域重要的数据集。</p>
<span id="more"></span>
<h2 id="语义分割方法"><a href="#语义分割方法" class="headerlink" title="语义分割方法"></a>语义分割方法</h2><p>在深度学习广泛应用于计算机视觉领域之前，人们一般使用 <a href="http://mi.eng.cam.ac.uk/~cipolla/publications/inproceedings/2008-CVPR-semantic-texton-forests.pdf">TextonForest</a> 和 <a href="http://www.cse.chalmers.se/edu/year/2011/course/TDA361/Advanced%20Computer%20Graphics/BodyPartRecognition.pdf">Random Forest based classifiers</a> 的方法进行语义分割。CNN（Convolutional Neural Network，卷积神经网络）不仅有助于图像识别，在图像的语义分割问题中同样取得了成功。</p>
<p>深度学习方法中常见的一种语义分割方法是 <a href="http://people.idsia.ch/~juergen/nips2012.pdf">图像块分类（patch classification）</a>，即利用像素周围的图像块对每一个像素进行分类。的原因是网络模型通常包含全连接层（fully connect layer），而且要求固定大小的图像输入。</p>
<p>2014 年，加州大学伯克利分校的 Long 等人提出 <a href="https://arxiv.org/abs/1411.4038">全卷积网络（Fully Convolutional Networks，FCN）</a>，使得卷积神经网络不需要全连接层就可以实现密集的像素级分类，从而成为当前非常流行的像素级分类 CNN 架构。由于不需要全连接层，所以可以对任意大小的图像进行语义分割，而且比传统方法要快上很多。之后，语义分割领域几乎所有的先进方法都是基于该模型进行扩展的。</p>
<p>除了全连接层，池化层（pooling layer）是 CNN 语义分割中的另一个主要问题。CNN 中池化层能够扩大感受野，丢弃位置信息（where information）从而聚合上下文信息。但是语义分割要求类别图完全贴合（exact alignment），因此需要保留位置信息。本文将介绍两种不同的分类架构解决这个问题。</p>
<p>一种是 <strong>编码器-解码器（encoder-decoder）</strong> 架构。编码器通过池化层逐渐减少空间维度，解码器则逐渐恢复物体的细节和空间维度。编码器到解码器之间通常存在快捷连接（shortcut connections），从而更好地恢复物体的细节信息。<a href="https://arxiv.org/pdf/1505.04597.pdf">U-Net</a> 是这类架构中最常用的模型之一。</p>
<p>U-Net: 编码器-解码器架构<br><img src="/Blog/.io//Unet.png" alt="Unet"></p>
<p>第二种这类架构使用 <a href="https://arxiv.org/pdf/1511.07122.pdf">空洞/带孔卷积（dilated/atrous convolutions）</a> 结构，从而去除池化层。</p>
<p><img src="/Blog/.io//Atrous_conv.png" alt="Atrous_conv"><br>Dilated/atrous卷积结构, 当rate=1时退化为普通的卷积结构.</p>
<p><a href="https://arxiv.org/pdf/1210.5644.pdf">条件随机场（Conditional Random Field，CRF）</a> 后处理操作通常用于进一步改善分割的效果。CRFs 是一种基于底层图像的像素强度进行“平滑”分割（‘smooth’ segmentation）的图模型，其工作原理是相似强度的像素更可能标记为同一类别。CRFs 一般能够提升 1-2% 的精度。</p>
<p><img src="/Blog/.io//CRF.png" alt="CRF"><br>CRF示意图。（b）一元分类结合CRF;（c, d, e）是CRF的变体，其中(e)是广泛使用的一种CRF。</p>
<p>接下来本文将概述从 FCN 以来一些具有代表性的图像语义分割的论文及其对应的架构，这些架构使用 <a href="http://host.robots.ox.ac.uk:8080/leaderboard/displaylb.php">VOC2012 评估服务器</a> 进行基准测试。</p>
<h2 id="FCN"><a href="#FCN" class="headerlink" title="FCN"></a>FCN</h2><blockquote>
<p>Fully Convolutional Networks for Semantic Segmentation</p>
<p>Submitted on 14 Nov 2014</p>
<p><a href="https://arxiv.org/abs/1411.4038">Arxiv Link</a></p>
</blockquote>
<p>这篇论文的主要思路是把 CNN 改成 FCN, 输入一幅图像后直接在输出端得到 dense prediction，也就是每个像素所属的 class，从而得到一个端到端的方法来实现图像的语义分割。</p>
<p>假设我们已经有了一个 CNN 模型, 首先要把 CNN 的全连接层看成是卷积层，卷积模板大小就是输入的特征 map 的大小，也就是说把全连接网络看成是对整张输入 map 做卷积。全连接层分别有 4096 个 6<em>6 的卷积核，4096 个 1</em>1 的卷积核，1000个1*1 的卷积核，如下图：</p>
<p><img src="/Blog/.io//FCN-1.png" alt="FCN-1"></p>
<p>接下来就要对这 1000 个 1<em>1 的输出，做 upsampling，得到 1000 个原图大小（如 32</em>32 ）的输出，这些输出合并后，得到上图所示的 heatmap 。</p>
<blockquote>
<p>这样做的好处是，能够很好的利用已经训练好的网络，不用像已有的方法那样，从头到尾训练，只需要微调即可，训练高效。</p>
</blockquote>
<h3 id="反卷积"><a href="#反卷积" class="headerlink" title="反卷积"></a>反卷积</h3><p>论文通过 upsampling 得到 dense prediction，文中提及到　3　种方案：</p>
<ul>
<li>shift-and-stitch: 设原图与 FCN 所得输出图之间的降采样因子是 f，那么对于原图的每个 f<em>f 的区域（不重叠）, 把这个 f</em>f 区域对应的 output 作为此时<strong>区域中心点像素</strong>对应的 output，这样就对每个 f*f 的区域得到了 $f^2$ 个 output，也就是每个像素都能对应一个 output，所以成为了 dense prediction;</li>
<li>filter rarefaction：就是放大 CNN 网络中的 subsampling 层的 filter 的尺寸，得到新的 filter. 公式如下, 其中 s 是 subsampling 的滑动步长，这个新 filter 的滑动步长要设为 1，这样的话，subsampling 就没有缩小图像尺寸，最后可以得到 dense prediction;<script type="math/tex; mode=display">
f'_{ij} =
\begin{cases}
f_{i/s, j/s},  & \text{if $s$ divides both $i$ and $j$} \\
0, & \text{otherwise}
\end{cases}</script></li>
<li>upsampling 的操作可以看成是反卷积(deconvolutional), 卷积运算的参数和CNN的参数一样是在训练FCN模型的过程中通过bp算法学习得到.</li>
</ul>
<blockquote>
<p>作者没有采用前两种方法, 而使用了最后一种反卷积的方法. 对于第一种方法, 虽然 receptive fileds 没有变小，但是由于原图被划分成 f*f 的区域输入网络，使得 filters 无法感受更精细的信息; 对于第二种方法, 下采样的功能被减弱，使得更细节的信息能被 filter 看到，但是 receptive fileds 会相对变小，可能会损失全局信息，且会对卷积层引入更多运算。</p>
</blockquote>
<p>反卷积示意图: 蓝色是反卷积层的input，绿色是反卷积层的output</p>
<p>kernel size = 3, stride = 1 的反卷积，input 是 2×2, output 是 4×4:</p>
<p><img src="/Blog/.io//deconv01.gif" alt="deconv01"></p>
<p>kernel size = 3, stride = 2 的反卷积，input 是 3×3, output 是 5×5：</p>
<p><img src="/Blog/.io//deconv02.gif" alt="deconv02"></p>
<blockquote>
<p>解卷积层也被称作：上卷积（upconvolution），完全卷积（full convolution），转置卷积（transposed convolution）或者微步卷积（fractionally-strided convolution）</p>
</blockquote>
<h3 id="fusion-prediction"><a href="#fusion-prediction" class="headerlink" title="fusion prediction"></a>fusion prediction</h3><p>由于池化操作造成的信息损失，上采样（即使采用解卷积操作）只能生成粗略的分割结果图。因此，论文从高分辨率的特征图中引入跳跃连接（shortcut/skip connection）操作改善上采样的精细程度：</p>
<p><img src="/Blog/.io//FCN-2.png" alt="FCN-2"></p>
<p>实验表明，这样的分割结果更细致更准确。在逐层fusion的过程中，做到第三行再往下，结果又会变差，所以作者做到这里就停了。可以看到如上三行的对应的结果：</p>
<p><img src="/Blog/.io//FCN-3.png" alt="FCN-3"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>推广端到端卷积网络在语义分割领域中的应用</li>
<li>修改ImageNet预训练模型并应用于图像语义分割</li>
<li>采用解卷积层（deconvolutional layer）实现上采样</li>
<li>引入跳跃连接（skip connections）改善上采样的粒度（coarseness）</li>
</ul>
<blockquote>
<p>FCN 对于语义分割领域来说贡献巨大，但是它容易丢失较小的目标, 当前的方法已经取得了很大的提升。</p>
</blockquote>
<h2 id="SegNet"><a href="#SegNet" class="headerlink" title="SegNet"></a>SegNet</h2><blockquote>
<p>SegNet: A Deep Convolutional Encoder-Decoder Architecture for Image Segmentation</p>
<p>Submitted on 2 Nov 2015</p>
<p><a href="https://arxiv.org/abs/1511.00561">Arxiv Link</a></p>
</blockquote>
<p>尽管 FCN 网络中使用了解卷积层和少量跳跃连接，但输出的分割图比较粗略，因此本文引入更多的跳跃连接。但是，SegNet 并没有复制 FCN 中的编码器特征，取而代之的是复制最大池化索引。因此，SegNet 相对于 FCN 来说更节省内存。</p>
<p>SegNet 网络架构如下图所示:<br><img src="/Blog/.io//SegNet01.png" alt="SegNet"><br>SegNet 有三个部分构成：一个 encoder network，一个对应的 decoder network，最后一个像素级别的分类层.</p>
<p>编码器部分使用的是 VGG16 的前 13 层卷积网络，可以尝试使用 Imagenet 上的预训练. 还可以丢弃完全连接的层，有利于在最深的编码器输出处保留较高分辨率的特征图, 与其他最近的架构 FCN 和 DeconvNet 相比，这也减少了SegNet编码器网络中的参数数量. 每个编码器由卷积层、批归一化层、RELU 组成，之后，执行具有 2×2 窗口和步幅 2（非重叠窗口）的最大池化，输出结果相当于系数为 2 的下采样.最大池化用于实现输入图像中小空间位移的平移不变性，子采样导致特征图中每个像素的大输入图像上下文（空间窗口）. 由于最大池化和子采样的叠加，导致边界细节损失增大，因此必须在编码特征图中在 sub-sampling 之前捕获和储存边界信息. 为了高效，论文只储存了<strong>最大池化索引</strong>(max-pooling indices). 对于每个 2×2 池化窗口，这可以使用 2 位来完成，因此与浮动精度的记忆特征图相比，存储效率更高.</p>
<p>解码器网络中的解码器使用来自对应的编码器特征图存储的<strong>最大池化索引</strong>来上采样至其输入特征图. 此步骤产生稀疏特征图, 然后将这些特征图与可训练的解码器滤波器组卷积以产生密集的特征图. 注意，最后一个解码器产生一个多通道的特征图，而不是3通道的(RGB). 之后特征图输入给一个 softmax 分类器. 这个 softmax 独立地分类每个像素. softmax 分类器的输出是 K 通道图像的概率，其中 K 是类的数量, 预测的分割对应于在每个像素处具有最大概率的类.</p>
<p>使用<strong>最大池化索引</strong>的解码器示意图:<br><img src="/Blog/.io//SegNet02.png" alt="max-pooling indices"></p>
<p>SegNet 部分分割结果如下:<br><img src="/Blog/.io//SegNet03.png" alt="result"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>FNC 和 SegNet 都是最早提出编码器-解码器结构的网络</li>
<li>分割的精度略好于 FCN, 总体效率也比 FCN 略高</li>
<li>SegNet 架构的基准测试分数一般，不建议继续使用</li>
</ul>
<h2 id="Dilated-Convolutions"><a href="#Dilated-Convolutions" class="headerlink" title="Dilated Convolutions"></a>Dilated Convolutions</h2><blockquote>
<p>Multi-Scale Context Aggregation by Dilated Convolutions</p>
<p>Submitted on 23 Nov 2015</p>
<p><a href="https://arxiv.org/abs/1511.07122">Arxiv Link</a></p>
</blockquote>
<p>在基于 FCN 思想的语义分割问题中，输出图像的 size 要和输入图像的 size 一致。但是 FCN 中由于有若干 stride&gt;1 的池化层，所以越到较高的网络层，单位像素中包含的原始图像的信息就越多，也就是感受野越大，但这是以通过池化降低分辨率、损失原始图像中的信息作为代价而得来的。由于 pooling 层的存在，后面层的 feature map 的 size 会越来越小，但由于需要计算 loss 等原因，最后输出图像的 size 要和输入图像的 size 保持一致，所以在 FCN 中的后段网络层中，必须对 feature map 进行<strong>上采样</strong>操作，将缩小的 feature map 再还原到原始尺寸，在这个过程中，不可能将在池化过程中丢失的信息完全还原回来，这样就造成了信息的丢失、语义分割的精度降低。</p>
<p>若不加 pooling 层，在较小的卷积核尺寸的前提下，感受野会很小；但如果为了增大感受野，在中段的网络层中使用 size 较大的卷积核，计算量又会暴增，内存扛不住, 因为中段的 channel 一般会非常大，比如 1024、2018，跟最开始 rgb 图像的 3 个 channel 比起来，增大了几百倍。</p>
<p>这种情况下， 作者提出空洞卷积层，其工作原理如下：</p>
<p><img src="/Blog/.io//dilatedConv.gif" alt="dilated conv"></p>
<p>Dilated Convolution 想法很粗暴，既然池化的下采样操作会带来信息损失，那么就把池化层去掉。但是池化层去掉随之带来的是网络各层的感受野变小，这样会降低整个模型的预测精度。Dilated convolution 的主要贡献就是，如何在去掉池化下采样操作的同时，而不降低网络的感受野。</p>
<h3 id="Dilated-Convolution"><a href="#Dilated-Convolution" class="headerlink" title="Dilated Convolution"></a>Dilated Convolution</h3><p>定义离散函数：$\mathbf{F}: \mathbb{Z}^2 \rightarrow \mathbb{R}$， 假设 $\Omega_r = [−r,r]^2 \bigcap \mathbb{Z}^2，k: \Omega_r \rightarrow \mathbb{R}$ 是大小为 $(2r+1)^2$ 的离散 filter. 则离散卷积操作 ∗ 的定义为：</p>
<script type="math/tex; mode=display">(F∗k)(p)=\sum_{s+t=p}F(s)k(t)</script><p>其一般化形式为：</p>
<script type="math/tex; mode=display">(F∗_{l}k)(p)=\sum_{s+lt=p}F(s)k(t)</script><p>其中 $l$ 为 dilation 因子，$∗_l$ 为 dilation convolution. 当 $l=1$ 时，即为普通的离散卷积操作 ∗.</p>
<p>基于 Dilation Convolution 的网络支持接受野的指数增长，不丢失分辨率信息.</p>
<p>记 $F<em>0,F_1,…,F</em>{n−1}: \mathbb{Z}^2 \rightarrow \mathbb{R}$ 为离散函数， $k<em>0,k_1,…, k</em>{n−2}: \Omega_1 \rightarrow \mathbb{R}$ 是离散的 3×3 fliters， 采用指数增长 dilation 的 filters后，</p>
<script type="math/tex; mode=display">F_{i+1} = F_i∗_{2^i}k_i \text{ , for } i=0,1,...,n−2</script><p>定义 $F<em>{i+1}$ 中的元素 p 的接受野为：$F_0$ 中可以改变 $F</em>{i+1}(p)$ 值的元素集. $F_{i+1}$ 中 p 的接受野的大小即为这些元素集的数目.</p>
<p>显而易见，$F_{i+1}$ 中各元素的接受野大小为 $(2^{i+2}−1)×(2^{i+2}−1)$. 接受野是指数增长大小的平方.</p>
<p>如下图.</p>
<p><img src="/Blog/.io//dilatedConv01.png" alt="dilated02"></p>
<p>以 $3 \times 3$ 的卷积核为例，传统卷积核在做卷积操作时，是将卷积核与输入张量中“连续”的 $3 \times 3$ 的 patch 逐点相乘再求和（如上图 a，红色圆点为卷积核对应的输入“像素”，绿色为其在原输入中的感知野）。而 dilated convolution 中的卷积核则是将输入张量的 $3\times 3$ patch 隔一定的像素进行卷积运算。如上图 b 所示，在去掉一层池化层后，需要在去掉的池化层后将传统卷积层换做一个 “dilation=2” 的 dilated convolution 层，此时卷积核将输入张量每隔一个“像素”的位置作为输入 patch 进行卷积计算，可以发现这时对应到原输入的感知野已经扩大（dilate）为 $7 \times 7$；同理，如果再去掉一个池化层，就要将其之后的卷积层换成 “dilation=4” 的 dilated convolution 层，如上图 c 所示。这样一来，即使去掉池化层也能保证网络的感受野，从而确保图像语义分割的精度。</p>
<blockquote>
<p>Dilated Convolution 能够不减少空间维度的前提下，使感受野呈现指数级增长。</p>
</blockquote>
<h3 id="Multi-scale-Context-Aggreation"><a href="#Multi-scale-Context-Aggreation" class="headerlink" title="Multi-scale Context Aggreation"></a>Multi-scale Context Aggreation</h3><p>上述模块在论文中称作前端模块（frontend module），使用上述模块之后，无需增加参数即可实现密集的像素级类别预测。另一个模块在论文中称作上下文模块（context module），使用前端模块的输出作为输入单独训练。该模块由多个不同扩张程度（dilation）的 dilated convolution 级联而成，因此能够聚合不同尺度的上下文信息，从而改善前端模块输出的预测结果。</p>
<p>context module 的结构如下：</p>
<p><img src="/Blog/.io//dilatedConv02.png" alt="dilated03"></p>
<p>context 模块的基本形式中，各层具有 C 个 channels. 尽管特征图没有归一化，模块内也没有定义 loss，但各层的表示是相同的，可以直接用于获得 dense per-class prediction. 直观上是可以增加特征图的准确度的.</p>
<p>基本的 context 模块有 7 层，各层采用具有不同的 dilation 因子的 3×3 卷积. 各卷积操作后跟着一个逐元素截断 (pointwise truncation) 操作：max(⋅,0). 最终的输出是采用 1×1×C 的卷积操作得到的.</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>采用空洞卷积（dilated convolution）作为能够实现像素级预测的卷积层</li>
<li>提出“背景模块”（context module），用于空洞卷积的多尺度聚合</li>
<li>预测分割图的大小是原始图大小的 1/8，几乎所有的方法都是这样，一般通过插值得到最终的分割结果</li>
</ul>
<h2 id="DeepLab-（v1-amp-v2）"><a href="#DeepLab-（v1-amp-v2）" class="headerlink" title="DeepLab （v1 &amp; v2）"></a>DeepLab （v1 &amp; v2）</h2><blockquote>
<p>Semantic Image Segmentation with Deep Convolutional Nets and Fully Connected CRFs</p>
<p>Submitted on 22 Dec 2014</p>
<p><a href="https://arxiv.org/abs/1412.7062">Arxiv Link</a></p>
<p>DeepLab: Semantic Image Segmentation with Deep Convolutional Nets, Atrous Convolution, and Fully Connected CRFs</p>
<p>Submitted on 2 Jun 2016</p>
<p><a href="https://arxiv.org/abs/1606.00915">Arxiv Link</a></p>
</blockquote>
<p>论文认为之前基于 FCN 的语义分割方法有如下几个问题：</p>
<ol>
<li>池化层和下采样使特征图的分辨率降低</li>
<li>多尺度物体检测</li>
<li>深度卷积神经网络的不变性造成的定位精度减少</li>
</ol>
<p>针对以上三个问题， DeepLab 分别提出了三个解决方案。</p>
<ol>
<li>针对分辨率降低的问题，DeepLab 提出使用 Atrous convolution, 这其实和上一个 dilated convolution 一样</li>
<li>传统方法是把 image 强行转成相同尺寸，这样会导致某些特征扭曲或者消失。作者的想法是借用<strong>空间金字塔池化</strong> (spatial pyramid pooling）的思想，使用了 ASPP (atrous SPP) 来解决这个问题</li>
<li>解决 DCNN invariance 可以选择挑过一些层，不过这里作者选择了全连接的 CRF 改善定位精度</li>
</ol>
<p>所以论文解决方案的整体流程如下：</p>
<p><img src="/Blog/.io//DeepLab01.png" alt="Deeplab 流程"></p>
<h3 id="用于稠密特征提取和视野增大的多孔卷积"><a href="#用于稠密特征提取和视野增大的多孔卷积" class="headerlink" title="用于稠密特征提取和视野增大的多孔卷积"></a>用于稠密特征提取和视野增大的多孔卷积</h3><p>对于重复使用卷积和池化操作导致特征图分辨率丢失的问题，作者采用了一个叫做 atrous convolution 的卷积操作，这和 dilated convolution 思想是一样的，这里不再做详细介绍。</p>
<p>Atrous convolution 结合了传统的 downsampling，convolution 和 upsampling，得到的图像大小相同，但是特征明显清晰了很多, 如下图所示：</p>
<p><img src="/Blog/.io//DeepLab02.png" alt="Atrous convolution"></p>
<p>上图展示了 2D 算法操作的一个简单例子。上排：低分辨率输入特征地图的标准卷积稀疏特征提取；下排：高分辨率输入特征地图多孔卷积比例 r=2 的稠密特征提取。</p>
<h3 id="用多孔空间金字塔池化的多尺度图像表示"><a href="#用多孔空间金字塔池化的多尺度图像表示" class="headerlink" title="用多孔空间金字塔池化的多尺度图像表示"></a>用多孔空间金字塔池化的多尺度图像表示</h3><p>对于第二个问题， 受 R-CNN 空间金字塔池化方法成功的启发，任意一个尺度上的区域都可以用单一尺度上重采样卷积特征进行精确有效地分类。论文使用多个不同采样率上的多个并行多孔卷积层，在每个采样率上提取特征然后再用单独的分支处理，融合生成最后的结果。如下图所示</p>
<p><img src="/Blog/.io//DeepLab03.png" alt="ASPP"></p>
<p>“多孔空间金字塔池化”（DeepLab-ASPP）方法可以泛化了 DeepLab-LargeFOV，如下图所示</p>
<p><img src="/Blog/.io//DeepLab06.png" alt="LargeFOV"></p>
<h3 id="用于精确边界恢复的全连接的条件随机场"><a href="#用于精确边界恢复的全连接的条件随机场" class="headerlink" title="用于精确边界恢复的全连接的条件随机场"></a>用于精确边界恢复的全连接的条件随机场</h3><p>精确定位和分类性能在神经网络中往往需要权衡：带有最大池化层的更深的模型在分类任务上非常成功，但不变性增加，顶层结点的大感受野只能产生平滑响应，这就使得深度卷积神经网络得分地图可以预测是否有物体，以及物体出现的大致位置，但不能真正描绘它们的边界。</p>
<p>论文将深度卷积神经网络的识别能力和全连接条件随机场优化的定位精度耦合在一起，非常成功地处理定位挑战问题，生成了精确的语义分割结果。</p>
<p>传统方法中，条件随机场用于平滑带噪声的分割图。这些模型将邻近结点耦合，有利于将相同标记分配给空间上接近的像素，这些短程条件随机场主函数会清除构建在局部手动特征上层弱分类器的错误预测。与这些弱分类器相比，现代深度卷积神经网络架构生成的得分地图通常非常平滑，在这种情形下，用短程条件随机场结果可能不理想。我们的目标是要恢复详细的局部结构而不是平滑它，用局部条件随机场关联中的反差灵敏势，可以增强定位，但还是会漏掉细小结构，通常都需要处理离散优化问题。为了克服短程条件随机场的局限，论文使用了全连接随机场模型。</p>
<p>使用 CRF 结果如下：</p>
<p><img src="/Blog/.io//DeepLab04.png" alt="CRF"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>论文部分结果展示：</p>
<p><img src="/Blog/.io//DeepLab05.png" alt="result"></p>
<p>主要贡献：</p>
<ul>
<li>采用了带孔/空洞卷积（atrous/dilated convolution）</li>
<li>提出了金字塔型的空洞池化（atrous spatial pyramid pooling，ASPP）</li>
<li>采用全连接的 CRF</li>
</ul>
<h2 id="RefineNet"><a href="#RefineNet" class="headerlink" title="RefineNet"></a>RefineNet</h2><blockquote>
<p>RefineNet: Multi-Path Refinement Networks for High-Resolution Semantic Segmentation</p>
<p>Submitted on 20 Nov 2016</p>
<p><a href="https://arxiv.org/abs/1611.06612">Arxiv Link</a></p>
</blockquote>
<p>采用空洞/带孔卷积的方法也存在缺点。空洞卷积需要大量的高分辨率特征图，因此对计算量和内存的消耗都很大，这也限制方法无法应用于高分辨率的精细预测。例如 DeepLab 中分割结果图采用原始输入图像的 1/8 大小。</p>
<p>因此，论文提出一种编码器-解码器的架构。编码器是 ResNet-101 模块，解码器则是 RefineNet 模块，其连接/融合编码器的高分辨率特征和先前 RefineNet 块中的低分辨率特征。从网络结构来看，该工作是 U-Net 的一个变种，文章的主要贡献和创新在于 U-Net 折返向上的通路之中。</p>
<p>论文提出的网络模型可以分为两段对应于 U-Net 中向下（特征逐步降采样同时提取语义特征）和向上（逐步上采样特征恢复细节信息）两段通路。其中向下的通路以 ResNet 为基础。向上的通路使用了新提出的 RefineNet 作为基础，并作为本通路特征与 ResNet 中低层特征的融合器。一个基本的框架如下图 (c) 所示：</p>
<p><img src="/Blog/.io//RefineNet.png" alt="RefineNet"></p>
<p>图a）代表的是标准的CNN结构<br>图b）代表的是带孔卷积dilated convolutions<br>图c）代表的是 RefineNet 的思路, 每一个小模块是一个 RefineNet, 融合了不同尺度下的 RefineNet 结果, 最终 upsample 到原图的 1/4 大小</p>
<h3 id="RefineNet-细节"><a href="#RefineNet-细节" class="headerlink" title="RefineNet 细节"></a>RefineNet 细节</h3><p>RefineNet 可以分为三个主要部分：</p>
<ol>
<li>不同尺度（也可能只有一个输入尺度）的特征输入首先经过两个 Residual 模块的处理；</li>
<li>之后是不同尺寸的特征进行融合。当然如果只有一个输入尺度，该模块则可以省去。所有特征上采样至最大的输入尺寸，然后进行加和。上采样之前的卷积模块是为了调整不同特征的数值尺度；</li>
<li>最后是一个链式的 pooling 模块。其设计本意是使用侧支上一系列的 pooling 来获取背景信息（通常尺寸较大）。直连通路上的 ReLU 可以在不显著影响梯度流通的情况下提高后续 pooling 的性能，同时不让网络的训练对学习率很敏感。<br>最后再经过一个 Residual 模块即得 RefineNet 的输出。</li>
</ol>
<p>如下图所示：<br><img src="/Blog/.io//RefineNet02.png" alt="RefineNet"></p>
<blockquote>
<p>RefineNet 的一个特点是使用了较多的 residual connection。这样的好处不仅在于在 RefineNet 内部形成了 short-range 的连接，对训练有益。此外还与 ResNet 形成了 long-range 的连接，让梯度能够有效传送到整个网络中。作者认为这一点对于网络是很有好处的。</p>
</blockquote>
<h3 id="几种不同的-RefineNet-设计"><a href="#几种不同的-RefineNet-设计" class="headerlink" title="几种不同的 RefineNet 设计"></a>几种不同的 RefineNet 设计</h3><p><img src="/Blog/.io//RefineNet03.png" alt="RefineNet"></p>
<h3 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h3><ul>
<li>编码器-解码器架构拥有精心设计的解码器模块</li>
<li>所有组件采用残差连接（residual connection）的设计</li>
</ul>
<h2 id="PSPNet"><a href="#PSPNet" class="headerlink" title="PSPNet"></a>PSPNet</h2><blockquote>
<p>Pyramid Scene Parsing Network</p>
<p>Submitted on 4 Dec 2016</p>
<p><a href="https://arxiv.org/abs/1612.01105">Arxiv Link</a></p>
</blockquote>
<h2 id="Large-Kernel-Matters"><a href="#Large-Kernel-Matters" class="headerlink" title="Large Kernel Matters"></a>Large Kernel Matters</h2><blockquote>
<p>Large Kernel Matters — Improve Semantic Segmentation by Global Convolutional Network</p>
<p>Submitted on 8 Mar 2017</p>
<p><a href="https://arxiv.org/abs/1703.02719">Arxiv Link</a></p>
</blockquote>
<h2 id="DeepLab-v3"><a href="#DeepLab-v3" class="headerlink" title="DeepLab v3"></a>DeepLab v3</h2><blockquote>
<p>Rethinking Atrous Convolution for Semantic Image Segmentation</p>
<p>Submitted on 17 Jun 2017</p>
<p><a href="https://arxiv.org/abs/1706.05587">Arxiv Link</a></p>
</blockquote>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.qure.ai/notes/semantic-segmentation-deep-learning-review">A 2017 Guide to Semantic Segmentation with Deep Learning</a><br><a href="http://blog.csdn.net/u010025211/article/details/51209504">深度学习之图像分割-FCN</a><br><a href="http://blog.csdn.net/zziahgf/article/details/77947565">论文阅读理解 - Dilated Convolution</a><br><a href="http://blog.csdn.net/tonyyang1995/article/details/51915968">DeepLab: Semantic Image Segmentation</a><br><a href="https://zhuanlan.zhihu.com/p/22308032">【总结】图像语义分割之FCN和CRF</a><br><a href="http://blog.csdn.net/u010158659/article/details/72352833">RefineNet: Multi-Path Refinement Networks for High-Resolution Semantic</a></p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>MXNet/Gluon 深度学习笔记 (九) —— 循环神经网络</title>
    <url>/Blog/2018/02/16/deep-learning-limu-note09/</url>
    <content><![CDATA[<p>传统的前馈神经网络的输入是时间无关的，它可以很方便地提取图像的特征，但是却无法处理时间序列数据，因为它无法捕捉前一个输入与后一个输入之间的联系，而这种联系在时间序列数据中至关重要. 为了处理序列数据，循环神经网络 (RNN) 应运而生．RNN 于 1980 年诞生, 我们知道，一个三层的前馈神经网络可以学到任何的函数，而RNN则是 “turing-complete” 的，它可以逼近任何算法. RNN 每一层不仅输出给下一层，同时还输出一个隐含状态，给当前层在处理下一个样本时使用, 理论上，RNNs能够对任何长度的序列数据进行处理. 下图展示了前馈神经网络与循环神经网络的区别.</p>
<p><img src="/Blog/.io//rnn_1.png" alt="rnn_1"></p>
<span id="more"></span>
<h2 id="循环神经网络-RNN"><a href="#循环神经网络-RNN" class="headerlink" title="循环神经网络 (RNN)"></a>循环神经网络 (RNN)</h2><p>首先回忆一下单隐含层的前馈神经网络的定义，例如<strong>多层感知机</strong>。假设隐含层的激活函数是 $\phi$，对于一个样本数为 $n$ 特征向量维度为 $x$ 的批量数据 $\mathbf{X} \in \mathbb{R}^{n \times x}$（ $\mathbf{X}$ 是一个 $n$ 行 $x$ 列的实数矩阵）来说，那么这个隐含层的输出就是</p>
<script type="math/tex; mode=display">\mathbf{H} = \phi(\mathbf{X} \mathbf{W}_{xh} + \mathbf{b}_h)</script><p>假定隐含层长度为 $h$，其中的 $\mathbf{W}<em>{xh} \in \mathbb{R}^{x \times h}$ 是权重参数。偏移参数 $\mathbf{b}_h \in \mathbb{R}^{1 \times h}$ 在与前一项 $\mathbf{X} \mathbf{W}</em>{xh} \in \mathbb{R}^{n \times h}$ 相加时使用了广播。这个隐含层的输出的尺寸为 $\mathbf{H} \in \mathbb{R}^{n \times h}$。</p>
<p>把隐含层的输出 $\mathbf{H}$ 作为输出层的输入，最终的输出</p>
<script type="math/tex; mode=display">\hat{\mathbf{Y}} = \text{softmax}(\mathbf{H} \mathbf{W}_{hy} + \mathbf{b}_y)</script><p>假定每个样本对应的输出向量维度为 $y$，其中 $\hat{\mathbf{Y}} \in \mathbb{R}^{n \times y}, \mathbf{W}_{hy} \in \mathbb{R}^{h \times y}, \mathbf{b}_y \in \mathbb{R}^{1 \times y}$ 且两项相加使用了广播。</p>
<p>将上面网络改成循环神经网络，首先对输入输出加上时间戳 $t$ 。假设 $\mathbf{X}<em>t \in \mathbb{R}^{n \times x}$ 是序列中的第 $t$ 个批量输入（样本数为 $n$，每个样本的特征向量维度为 $x$），对应的隐含层输出是隐含状态 $\mathbf{H}_t  \in \mathbb{R}^{n \times h}$（隐含层长度为 $h$ ），而对应的最终输出是 $\hat{\mathbf{Y}}_t \in \mathbb{R}^{n \times y}$（每个样本对应的输出向量维度为 $y$ ）。在计算隐含层的输出的时候，循环神经网络只需要在前馈神经网络基础上加上跟前一时间 $t-1$ 输入隐含层 $\mathbf{H}</em>{t-1} \in \mathbb{R}^{n \times h}$ 的加权和。为此，我们引入一个新的可学习的权重 $\mathbf{W}_{hh} \in \mathbb{R}^{h \times h}$：</p>
<script type="math/tex; mode=display">\mathbf{H}_t = \phi(\mathbf{X}_t \mathbf{W}_{xh} + \mathbf{H}_{t-1} \mathbf{W}_{hh}  + \mathbf{b}_h)</script><p>输出的计算跟前面一致：</p>
<script type="math/tex; mode=display">\hat{\mathbf{Y}}_t = \text{softmax}(\mathbf{H}_t \mathbf{W}_{hy}  + \mathbf{b}_y)</script><p>隐含状态可以认为是这个网络的记忆。该网络中，时刻 $t$ 的隐含状态就是该时刻的隐含层变量 $\mathbf{H}_t$, 它存储前面时间里面的信息, 我们的输出是只基于这个状态, 最开始的隐含状态里的元素通常会被初始化为 0。</p>
<h2 id="通过时间的反向传播"><a href="#通过时间的反向传播" class="headerlink" title="通过时间的反向传播"></a>通过时间的反向传播</h2><p>在循环神经网络的训练中，当每个时序训练数据样本的时序长度 <code>num_steps</code> 较大或者时刻$t$较小，目标函数有关 $t$ 时刻的隐含层变量梯度较容易出现衰减（valishing）或爆炸（explosion）.</p>
<p>为了应对梯度爆炸，一个常用的做法是如果梯度特别大，那么就投影到一个比较小的尺度上。假设我们把所有梯度接成一个向量 $\boldsymbol{g}$，假设剪裁的阈值是 $\theta$，那么我们这样剪裁使得 $|\boldsymbol{g}|$不会超过$\theta$：</p>
<script type="math/tex; mode=display">\boldsymbol{g} = \min\left(\frac{\theta}{\|\boldsymbol{g}\|}, 1\right)\boldsymbol{g}</script><p>梯度衰减（valishing）或爆炸（explosion）产生的原因可以由通过时间的反向传播解释.</p>
<h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><p>给定一个输入为 $\mathbf{x}_t \in \mathbb{R}^x$（每个样本输入向量长度为 $x$ ）和对应真实值为 $y_t \in \mathbb{R}$ 的时序数据训练样本（ $t = 1, 2, \ldots, T$ 为时刻），不考虑偏差项，我们可以得到隐含层变量的表达式</p>
<script type="math/tex; mode=display">\mathbf{h}_t = \phi(\mathbf{W}_{hx} \mathbf{x}_t + \mathbf{W}_{hh} \mathbf{h}_{t-1})</script><p>其中 $\mathbf{h}<em>t \in \mathbb{R}^h$ 是向量长度为 $h$ 的隐含层变量，$\mathbf{W}</em>{hx} \in \mathbb{R}^{h \times x}$ 和 $\mathbf{W}<em>{hh} \in \mathbb{R}^{h \times h}$ 是隐含层模型参数。使用隐含层变量和输出层模型参数 $\mathbf{W}</em>{yh} \in \mathbb{R}^{y \times h}$，我们可以得到相应时刻的输出层变量 $\mathbf{o}_t \in \mathbb{R}^y$。不考虑偏差项，</p>
<script type="math/tex; mode=display">\mathbf{o}_t = \mathbf{W}_{yh} \mathbf{h}_{t}</script><p>给定每个时刻损失函数计算公式 $\ell$，长度为$T$的整个时序数据的损失函数 $L$ 定义为</p>
<script type="math/tex; mode=display">L = \frac{1}{T} \sum_{t=1}^T \ell (\mathbf{o}_t, y_t)</script><p>这也是模型最终需要被优化的目标函数。</p>
<h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p>为了可视化模型变量和参数之间在计算中的依赖关系，我们可以绘制计算图。我们以时序长度 T=3 为例。</p>
<p><img src="/Blog/.io//rnn-bptt.svg" alt="rnn-bptt"></p>
<h3 id="梯度的计算与存储"><a href="#梯度的计算与存储" class="headerlink" title="梯度的计算与存储"></a>梯度的计算与存储</h3><p>在上图中，模型的参数是 $\mathbf{W}<em>{hx}$、$\mathbf{W}</em>{hh}$ 和 $\mathbf{W}_{yh}$。为了在模型训练中学习这三个参数，以随机梯度下降为例，假设学习率为 $\eta$，我们可以通过</p>
<script type="math/tex; mode=display">\mathbf{W}_{hx} = \mathbf{W}_{hx} - \eta \frac{\partial L}{\partial \mathbf{W}_{hx}}</script><script type="math/tex; mode=display">\mathbf{W}_{hh} = \mathbf{W}_{hh} - \eta \frac{\partial L}{\partial \mathbf{W}_{hh}}</script><script type="math/tex; mode=display">\mathbf{W}_{yh} = \mathbf{W}_{yh} - \eta \frac{\partial L}{\partial \mathbf{W}_{yh}}</script><p>来不断迭代模型参数的值。因此我们需要模型参数梯度 $\partial L/\partial \mathbf{W}<em>{hx}$、$\partial L/\partial \mathbf{W}</em>{hh}$ 和 $\partial L/\partial \mathbf{W}_{yh}$。为此，我们可以按照反向传播的次序依次计算并存储梯度。</p>
<p>为了表述方便，对输入输出 $\mathsf{X}, \mathsf{Y}, \mathsf{Z}$ 为任意形状张量的函数 $\mathsf{Y}=f(\mathsf{X})$ 和 $\mathsf{Z}=g(\mathsf{Y})$，我们使用</p>
<script type="math/tex; mode=display">\frac{\partial \mathsf{Z}}{\partial \mathsf{X}} = \text{prod}(\frac{\partial \mathsf{Z}}{\partial \mathsf{Y}}, \frac{\partial \mathsf{Y}}{\partial \mathsf{X}})</script><p>来表达链式法则, 以下依次计算得到的梯度将依次被存储。</p>
<p>首先，目标函数有关各时刻输出层变量的梯度 $\partial L/\partial \mathbf{o}_t \in \mathbb{R}^y$ 可以很容易地计算</p>
<script type="math/tex; mode=display">\frac{\partial L}{\partial \mathbf{o}_t} =  \frac{\partial \ell (\mathbf{o}_t, y_t)}{T \cdot \partial \mathbf{o}_t}</script><p>事实上，这时我们已经可以计算目标函数有关模型参数 $\mathbf{W}<em>{yh}$ 的梯度 $\partial L/\partial \mathbf{W}</em>{yh} \in \mathbb{R}^{y \times h}$。需要注意的是，在计算图中，$\mathbf{W}_{yh}$ 可以经过 $\mathbf{o}_1, \ldots, \mathbf{o}_T$ 通向 $L$，依据链式法则，</p>
<script type="math/tex; mode=display">\frac{\partial L}{\partial \mathbf{W}_{yh}}
= \sum_{t=1}^T \text{prod}(\frac{\partial L}{\partial \mathbf{o}_t}, \frac{\partial \mathbf{o}_t}{\partial \mathbf{W}_{yh}})
= \sum_{t=1}^T \frac{\partial L}{\partial \mathbf{o}_t} \mathbf{h}_t^\top</script><p>其次，我们注意到隐含层变量之间也有依赖关系, 对于最终时刻 $T$，在计算图中，隐含层变量 $\mathbf{h}_T$ 只经过 $\mathbf{o}_T$ 通向 $L$。因此我们先计算目标函数有关最终时刻隐含层变量的梯度 $\partial L/\partial \mathbf{h}_T \in \mathbb{R}^h$。依据链式法则，我们得到</p>
<script type="math/tex; mode=display">\frac{\partial L}{\partial \mathbf{h}_T} = \text{prod}(\frac{\partial L}{\partial \mathbf{o}_T}, \frac{\partial \mathbf{o}_T}{\partial \mathbf{h}_T} ) = \mathbf{W}_{yh}^\top \frac{\partial L}{\partial \mathbf{o}_T}</script><p>为了简化计算，我们假设激活函数 $\phi(x) = x$ 。接下来，对于时刻 $t &lt; T$，在计算图中，由于 $\mathbf{h}<em>t$ 可以经过 $\mathbf{h}</em>{t+1}$ 和 $\mathbf{o}_t$ 通向 $L$ ，依据链式法则，目标函数有关隐含层变量的梯度 $\partial L/\partial \mathbf{h}_t \in \mathbb{R}^h$ 需要按照时刻从晚到早依次计算：</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial \mathbf{h}_t}
= \text{prod}(\frac{\partial L}{\partial \mathbf{h}_{t+1}}, \frac{\partial \mathbf{h}_{t+1}}{\partial \mathbf{h}_t}) + \text{prod}(\frac{\partial L}{\partial \mathbf{o}_t}, \frac{\partial \mathbf{o}_t}{\partial \mathbf{h}_t} )
= \mathbf{W}_{hh}^\top \frac{\partial L}{\partial \mathbf{h}_{t+1}} + \mathbf{W}_{yh}^\top \frac{\partial L}{\partial \mathbf{o}_t}</script><p>将递归公式展开，对任意 $1 \leq t \leq T$，我们可以得到目标函数有关隐含层变量梯度的通项公式</p>
<script type="math/tex; mode=display">\frac{\partial L}{\partial \mathbf{h}_t}
= \sum_{i=t}^T {(\mathbf{W}_{hh}^\top)}^{T-i} \mathbf{W}_{yh}^\top \frac{\partial L}{\partial \mathbf{o}_{T+t-i}}</script><p>由此可见，当每个时序训练数据样本的时序长度$T$较大或者时刻 $t$ 较小，目标函数有关隐含层变量梯度较容易出现<strong>衰减</strong>（valishing）和<strong>爆炸</strong>（explosion）。想象一下 $2^{30}$ 和 $0.5^{30}$ 会有多大。</p>
<p>有了各时刻隐含层变量的梯度之后，我们可以计算隐含层中模型参数的梯度 $\partial L/\partial \mathbf{W}<em>{hx} \in \mathbb{R}^{h \times x}$ 和 $\partial L/\partial \mathbf{W}</em>{hh} \in \mathbb{R}^{h \times h}$ 。在计算图中，它们都可以经过 $\mathbf{h}_1, \ldots, \mathbf{h}_T$ 通向 $L$ 。依据链式法则，我们有</p>
<script type="math/tex; mode=display">\frac{\partial L}{\partial \mathbf{W}_{hx}}
= \sum_{t=1}^T \text{prod}(\frac{\partial L}{\partial \mathbf{h}_t}, \frac{\partial \mathbf{h}_t}{\partial \mathbf{W}_{hx}})
= \sum_{t=1}^T \frac{\partial L}{\partial \mathbf{h}_t} \mathbf{x}_t^\top</script><script type="math/tex; mode=display">\frac{\partial L}{\partial \mathbf{W}_{hh}}
= \sum_{t=1}^T \text{prod}(\frac{\partial L}{\partial \mathbf{h}_t}, \frac{\partial \mathbf{h}_t}{\partial \mathbf{W}_{hh}})
= \sum_{t=1}^T \frac{\partial L}{\partial \mathbf{h}_t} \mathbf{h}_{t-1}^\top</script><p>在每次迭代中，上述各个依次计算出的梯度会被依次存储或更新, 这是为了避免重复计算。例如，由于输出层变量梯度 $\partial L/\partial \mathbf{h}<em>t$ 被计算存储，反向传播稍后的参数梯度 $\partial L/\partial  \mathbf{W}</em>{hx}$ 和隐含层变量梯度 $\partial L/\partial \mathbf{W}_{hh}$ 的计算可以直接读取输出层变量梯度的值，而无需重复计算。</p>
<p>还有需要注意的是，反向传播对于各层中变量和参数的梯度计算可能会依赖通过正向传播计算出的各层变量和参数的当前值。举例来说，参数梯度 $\partial L/\partial \mathbf{W}_{hh}$ 的计算需要依赖隐含层变量在时刻 $t = 1, \ldots, T-1$ 的当前值 $\mathbf{h}_t$（$\mathbf{h}_0$ 是初始化得到的）。这个当前值是通过从输入层到输出层的正向传播计算并存储得到的。</p>
<blockquote>
<ul>
<li>所谓通过时间反向传播只是反向传播在循环神经网络的具体应用。</li>
<li>当每个时序训练数据样本的时序长度$T$较大或者时刻$t$较小，目标函数有关隐含层变量梯度较容易出现衰减和爆炸。</li>
</ul>
</blockquote>
<h2 id="长短期记忆-LSTM"><a href="#长短期记忆-LSTM" class="headerlink" title="长短期记忆 (LSTM)"></a>长短期记忆 (LSTM)</h2><p>长短期记忆（Long Short-Term Memory, LSTM）是一种时间递归神经网络，适合于处理和预测时间序列中间隔和延迟相对较长的事件，LSTM 区别于传统前馈神经网络的地方在于网络内部有机制可以实现保留对输入的记忆，并且还通过加入遗忘机制和保留机制等以非常精确的方式改变记忆，应用专门的学习机制来记住、更新、聚焦于信息。这有助于实现更长时间内的信息跟踪，并且也可以有效处理循环神经网络中梯度消失的问题。</p>
<p>LSTM 网络结构图如下图所示:</p>
<p><img src="/Blog/.io//RNN-unrolled.png" alt="RNN-unrolled"></p>
<p>其大体结构是基于循环神经网络，加入了一个判断信息是否有用的 “处理器”，这个处理器作用的结构被称为元胞（cell）, 即图中的 A，A 的详细结构如下图所示:</p>
<p><img src="/Blog/.io//LSTM3-chain.png" alt="LSTM3-chain"></p>
<p>一个 cell 中被放置了三扇门，分别叫做输入门、遗忘门和输出门。一个信息进入 LSTM 的网络当中，可以根据规则来判断是否有用。只有符合算法认证的信息才会留下，不符的信息则通过遗忘门被遗忘。</p>
<p>LSTM 第一步是决定我们将要从元胞状态中扔掉哪些信息。该决定由<strong>遗忘门（Forget  Gate）</strong>的 Sigmoid 层控制，遗忘门观察上一个隐藏状态 $h<em>{t-1}$ 和当前输入 $x_t$, 对于上一个元胞状态 $C</em>{t-1}$ 中的每一个元素，输出 $f_t$ 中相应的元素为 0~1 之间的数，表示对信息的保留程度。</p>
<p><img src="/Blog/.io//LSTM3-focus-f.png" alt="LSTM3-focus-f"></p>
<p>下一步决定我们会把哪些新信息存储到元胞状态中，这分为两部分。首先，<strong>输入门（Input Gate）</strong> 的 Sigmoid 层决定我们要更新哪些信息; 接下来，一个 $tanh$ 层创造了一个元胞状态新的候选值 $\tilde{C}_t$, 该值可能被加到元胞状态中。</p>
<p><img src="/Blog/.io//LSTM3-focus-i.png" alt="LSTM3-focus-i"></p>
<p>下一步就是更新旧元胞状态 $C<em>{t-1}$ 到新状态 $C_t$ 了。我们把 $C</em>{t-1}$ 乘以 $f_t$，忘掉没用的信息，然后再加上 $i_t \times \tilde{C}_t$，这个值是侯选值 $\tilde{C}_t$ 乘以侯选值的每一个状态的更新权重 $i_t$ 构成，决定元胞中当前输入的影响。</p>
<p><img src="/Blog/.io//LSTM3-focus-C.png" alt="LSTM3-focus-C"></p>
<p>最后，最终的输出状态将基于目前的元胞状态，并且会加入一些过滤。首先建立一个 Sigmoid 层的输出门（Output Gate）来决定我们将输出元胞的哪些部分，然后我们将元胞状态通过 $tanh$ 函数后使输出值在 -1~1 之间，之后与输出门相乘，得到最终的输出。</p>
<p><img src="/Blog/.io//LSTM3-focus-o.png" alt="LSTM3-focus-o"></p>
<p>LSTM 模型代码实现如下:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lstm_rnn</span>(<span class="params">inputs, state_h, state_c, *params</span>):</span></span><br><span class="line">    <span class="comment"># inputs: num_steps 个尺寸为 batch_size * vocab_size 矩阵</span></span><br><span class="line">    <span class="comment"># H: 尺寸为 batch_size * hidden_dim 矩阵</span></span><br><span class="line">    <span class="comment"># outputs: num_steps 个尺寸为 batch_size * vocab_size 矩阵</span></span><br><span class="line">    [W_xi, W_hi, b_i, W_xf, W_hf, b_f, W_xo, W_ho, b_o, W_xc, W_hc, b_c,</span><br><span class="line">     W_hy, b_y] = params</span><br><span class="line"></span><br><span class="line">    H = state_h</span><br><span class="line">    C = state_c</span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        I = nd.sigmoid(nd.dot(X, W_xi) + nd.dot(H, W_hi) + b_i)</span><br><span class="line">        F = nd.sigmoid(nd.dot(X, W_xf) + nd.dot(H, W_hf) + b_f)</span><br><span class="line">        O = nd.sigmoid(nd.dot(X, W_xo) + nd.dot(H, W_ho) + b_o)</span><br><span class="line">        C_tilda = nd.tanh(nd.dot(X, W_xc) + nd.dot(H, W_hc) + b_c)</span><br><span class="line">        C = F * C + I * C_tilda</span><br><span class="line">        H = O * nd.tanh(C)</span><br><span class="line">        Y = nd.dot(H, W_hy) + b_y</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="keyword">return</span> (outputs, H, C)</span><br></pre></td></tr></table></figure></p>
<h3 id="LSTM-的变体"><a href="#LSTM-的变体" class="headerlink" title="LSTM 的变体"></a>LSTM 的变体</h3><p>以上介绍的是正常的 LSTM, 当并不是所有的 LSTM 都长这样. 事实上, 几乎所有包含 LSTM 的论文都采用了微小的变体。差异非常小，但是也值得拿出来讲一下。<br>其中一个流形的 LSTM 变体，就是由 <a href="ftp://ftp.idsia.ch/pub/juergen/TimeCount-IJCNN2000.pdf">Gers &amp; Schmidhuber (2000)</a> 提出的，增加了 “peephole connection”, 让门层也会接受细胞状态的输入。</p>
<p><img src="/Blog/.io//LSTM3-var-peepholes.png" alt="LSTM3-var-peepholes"></p>
<p>上面的图例增加了 peephole 到每个门上，但是许多论文会加入部分的 peephole 而非所有都加。</p>
<p>另一个变体是通过使用 coupled 忘记和输入门。不同于之前的分开确定忘记什么和添加什么新的信息，这里是一同做出决定。变体仅仅在将要输入时选择遗忘, 仅仅当忘记旧值后才会输入新值.</p>
<p><img src="/Blog/.io//LSTM3-var-tied.png" alt="LSTM3-var-tied"></p>
<p>另一个改动较大的变体是 Gated Recurrent Unit (GRU)，这是由 <a href="https://arxiv.org/pdf/1406.1078v3.pdf">Cho, et al. (2014)</a> 提出。它将忘记门和输入门合成了一个单一的 更新门。同时还混合了细胞状态和隐藏状态，和其他一些改动。最终的模型比标准的 LSTM 模型要简单，也是非常流行的变体。</p>
<p><img src="/Blog/.io//LSTM3-var-GRU.png" alt="LSTM3-var-GRU"></p>
<p>这里只是部分流行的 LSTM 变体。当然还有很多其他的，如 <a href="https://arxiv.org/pdf/1503.04069.pdf">Yao, et al. (2015)</a> 提出的 Depth Gated RNN。还有用一些完全不同的观点来解决长期依赖的问题，如 <a href="https://arxiv.org/pdf/1402.3511v1.pdf">Koutnik, et al. (2014)</a> 提出的 Clockwork RNN。</p>
<p>本博文参考：<br><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a></p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>MXNet/Gluon 深度学习笔记 (十) —— 词向量与语言模型</title>
    <url>/Blog/2018/02/26/deep-learning-limu-note10/</url>
    <content><![CDATA[<p>自然语言是一套用来表达含义的复杂系统. 在这套系统中，词是表义的基本单元. 在机器学习中，使用词向量来表示词. 顾名思义，词向量是用来表示词的向量，通常也被认为是词的特征向量. 近年来，词向量已逐渐成为自然语言处理的基础知识.</p>
<p><img src="/Blog/.io//wordscatter.png" alt="word_scatter"></p>
<p>一个很自然的想法就是使用 one-hot 向量表示词, 假设词典中不同词的数量为 $N$ ，每个词可以和从 0 到 $N-1$ 的连续整数一一对应。假设一个词的相应整数表示为 $i$ ，为了得到该词的 one-hot 向量表示，我们创建一个全 0 的长为 $N$ 的向量，并将其第 $i$ 位设成 1 。然而，使用 one-hot 词向量并不是一个好选择。一个主要的原因是，one-hot 词向量无法表达不同词之间的相似度。例如，任何一对词的 one-hot 向量的余弦相似度都为 0 。<br><span id="more"></span></p>
<h2 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h2><p>2013年，Google团队发表了 <a href="https://code.google.com/archive/p/word2vec/">word2vec</a> 工具。word2vec 工具主要包含两个模型：跳字模型（skip-gram）和连续词袋模型（continuous bag of words，简称 CBOW ），以及两种高效训练的方法：负采样（negative sampling）和层序 softmax（hierarchical softmax）。值得一提的是，word2vec 词向量可以较好地表达不同词之间的相似和类比关系。</p>
<p>word2vec 自提出后被广泛应用在自然语言处理任务中。它的模型和训练方法也启发了很多后续的词向量模型。本节将重点介绍 word2vec 的模型和训练方法。</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="跳字模型-skip-gram"><a href="#跳字模型-skip-gram" class="headerlink" title="跳字模型 (skip-gram)"></a>跳字模型 (skip-gram)</h4><p>在跳字模型中，我们用一个词来预测它在文本序列周围的词。例如，给定文本序列 “the”, “man”, “hit”, “his”, 和 “son”，跳字模型所关心的是，给定 “hit”，生成它邻近词 “the”, “man”, “his”, 和 “son” 的概率。在这个例子中，”hit” 叫中心词，“the”, “man”, “his”, 和 “son” 叫背景词。由于 “hit” 只生成与它距离不超过 2 的背景词，该时间窗口的大小为 2。</p>
<p>我们来描述一下跳字模型。</p>
<p>假设词典大小为 $|\mathcal{V}|$ ，我们将词典中的每个词与从 0 到 $|\mathcal{V}|-1$ 的整数一一对应：词典索引集 $\mathcal{V} = {0, 1, \ldots, |\mathcal{V}|-1}$ 。一个词在该词典中所对应的整数称为词的索引。给定一个长度为 $T$ 的文本序列中，$t$ 时刻的词为 $w^{(t)}$ 。当时间窗口大小为 $m$ 时，跳字模型需要最大化给定任一中心词生成背景词的概率：</p>
<script type="math/tex; mode=display">\prod_{t=1}^T \prod_{-m \leq j \leq m, j \neq 0} \mathbb{P}(w^{(t+j)} \mid w^{(t)})</script><p>上式的最大似然估计与最小化以下损失函数等价</p>
<script type="math/tex; mode=display">-\frac{1}{T} \sum_{t=1}^T \sum_{-m \leq j \leq m, j \neq 0} \text{log} \mathbb{P}(w^{(t+j)} \mid w^{(t)})</script><p>我们可以用 $\mathbf{v}$ 和 $\mathbf{u}$ 分别代表中心词和背景词的向量。换言之，对于词典中一个索引为$i$的词，它在作为中心词和背景词时的向量表示分别是 $\mathbf{v}_i$ 和 $\mathbf{u}_i$ 。而词典中所有词的这两种向量正是跳字模型所要学习的模型参数。为了将模型参数植入损失函数，我们需要使用模型参数表达损失函数中的中心词生成背景词的概率。假设中心词生成各个背景词的概率是相互独立的。给定中心词 $w_c$ 在词典中索引为 $c$ ，背景词 $w_o$ 在词典中索引为 $o$ ，损失函数中的中心词生成背景词的概率可以使用 softmax 函数定义为</p>
<script type="math/tex; mode=display">\mathbb{P}(w_o \mid w_c) = \frac{\text{exp}(\mathbf{u}_o^\top \mathbf{v}_c)}{ \sum_{i \in \mathcal{V}} \text{exp}(\mathbf{u}_i^\top \mathbf{v}_c)}</script><p>当序列长度 $T$ 较大时，我们通常随机采样一个较小的子序列来计算损失函数并使用随机梯度下降优化该损失函数。通过微分，我们可以计算出上式生成概率的对数关于中心词向量 $\mathbf{v}_c$ 的梯度为：</p>
<script type="math/tex; mode=display">\frac{\partial \text{log} \mathbb{P}(w_o \mid w_c)}{\partial \mathbf{v}_c} = \mathbf{u}_o - \sum_{j \in \mathcal{V}} \frac{\text{exp}(\mathbf{u}_j^\top \mathbf{v}_c)}{ \sum_{i \in \mathcal{V}} \text{exp}(\mathbf{u}_i^\top \mathbf{v}_c)} \mathbf{u}_j</script><p>而上式与下式等价：</p>
<script type="math/tex; mode=display">\frac{\partial \text{log} \mathbb{P}(w_o \mid w_c)}{\partial \mathbf{v}_c} = \mathbf{u}_o - \sum_{j \in \mathcal{V}} \mathbb{P}(w_j \mid w_c) \mathbf{u}_j</script><p>通过上面计算得到梯度后，我们可以使用随机梯度下降来不断迭代模型参数 $\mathbf{v}_c$ 。其他模型参数 $\mathbf{u}_o$ 的迭代方式同理可得。最终，对于词典中的任一索引为 $i$ 的词，我们均得到该词作为中心词和背景词的两组词向量 $\mathbf{v}_i$ 和 $\mathbf{u}_i$ 。</p>
<h4 id="连续词袋模型-CBOW"><a href="#连续词袋模型-CBOW" class="headerlink" title="连续词袋模型 (CBOW)"></a>连续词袋模型 (CBOW)</h4><p>连续词袋模型与跳字模型类似。与跳字模型最大的不同是，连续词袋模型中用一个中心词在文本序列周围的词来预测该中心词。例如，给定文本序列 “the”, “man”, “hit”, “his”, 和 “son”，连续词袋模型所关心的是，邻近词 “the”, “man”, “his”, 和 “son” 一起生成中心词 “hit” 的概率。</p>
<p>假设词典大小为 $|\mathcal{V}|$ ，我们将词典中的每个词与从 0 到 $|\mathcal{V}|-1$ 的整数一一对应：词典索引集 $\mathcal{V} = {0, 1, \ldots, |\mathcal{V}|-1}$ 。一个词在该词典中所对应的整数称为词的索引。给定一个长度为 $T$ 的文本序列中，$t$ 时刻的词为 $w^{(t)}$ 。当时间窗口大小为 $m$ 时，连续词袋模型需要最大化由背景词生成任一中心词的概率：</p>
<script type="math/tex; mode=display">\prod_{t=1}^T  \mathbb{P}(w^{(t)} \mid  w^{(t-m)}, \ldots,  w^{(t-1)},  w^{(t+1)}, \ldots,  w^{(t+m)})</script><p>上式的最大似然估计与最小化以下损失函数等价</p>
<script type="math/tex; mode=display">-\sum_{t=1}^T  \text{log} \mathbb{P}(w^{(t)} \mid  w^{(t-m)}, \ldots,  w^{(t-1)},  w^{(t+1)}, \ldots,  w^{(t+m)})</script><p>我们可以用 $\mathbf{v}$ 和 $\mathbf{u}$ 分别代表背景词和中心词的向量（注意符号和跳字模型中的不同）。换言之，对于词典中一个索引为$i$的词，它在作为背景词和中心词时的向量表示分别是 $\mathbf{v}<em>i$ 和 $\mathbf{u}_i$ 。而词典中所有词的这两种向量正是连续词袋模型所要学习的模型参数。为了将模型参数植入损失函数，我们需要使用模型参数表达损失函数中的中心词生成背景词的概率。给定中心词 $w_c$ 在词典中索引为 $c$ ，背景词 $w</em>{o<em>1}, \ldots, w</em>{o<em>{2m}}$ 在词典中索引为 $o_1, \ldots, o</em>{2m}$ ，损失函数中的背景词生成中心词的概率可以使用 softmax 函数定义为</p>
<script type="math/tex; mode=display">\mathbb{P}(w_c \mid w_{o_1}, \ldots, w_{o_{2m}}) = \frac{\text{exp}[\mathbf{u}_c^\top (\mathbf{v}_{o_1} + \ldots + \mathbf{v}_{o_{2m}}) /(2m) ]}{ \sum_{i \in \mathcal{V}} \text{exp}[\mathbf{u}_i^\top (\mathbf{v}_{o_1} + \ldots + \mathbf{v}_{o_{2m}}) /(2m)]}</script><p>当序列长度 $T$ 较大时，我们通常随机采样一个较小的子序列来计算损失函数并使用随机梯度下降优化该损失函数。通过微分，我们可以计算出上式生成概率的对数关于任一背景词向量 $\mathbf{v}_{o_i}$($i = 1, \ldots, 2m$) 的梯度为：</p>
<script type="math/tex; mode=display">\frac{\partial \text{log} \mathbb{P}(w_c \mid w_{o_1}, \ldots, w_{o_{2m}})}{\partial \mathbf{v}_{o_i}} = \frac{1}{2m}(\mathbf{u}_c - \sum_{j \in \mathcal{V}} \frac{\text{exp}(\mathbf{u}_j^\top \mathbf{v}_c)}{ \sum_{i \in \mathcal{V}} \text{exp}(\mathbf{u}_i^\top \mathbf{v}_c)} \mathbf{u}_j)</script><p>而上式与下式等价：</p>
<script type="math/tex; mode=display">\frac{\partial \text{log} \mathbb{P}(w_c \mid w_{o_1}, \ldots, w_{o_{2m}})}{\partial \mathbf{v}_{o_i}} = \frac{1}{2m}(\mathbf{u}_c - \sum_{j \in \mathcal{V}} \mathbb{P}(w_j \mid w_c) \mathbf{u}_j)</script><p>通过上面计算得到梯度后，我们可以使用随机梯度下降)来不断迭代各个模型数 $\mathbf{v}_{o_i}$($i = 1, \ldots, 2m$)。其他模型参数 $\mathbf{u}_c$ 的迭代方式同理可得。最终，对于词典中的任一索引为 $i$ 的词，我们均得到该词作为背景词和中心词的两组词向量 $\mathbf{v}_i$ 和 $\mathbf{u}_i$。</p>
<h3 id="近似训练法"><a href="#近似训练法" class="headerlink" title="近似训练法"></a>近似训练法</h3><p>我们可以看到，无论是跳字模型还是连续词袋模型，每一步梯度计算的开销与词典 $\mathcal{V}$ 的大小相关。显然，当词典较大时，例如几十万到上百万，这种训练方法的计算开销会较大。所以，使用上述训练方法在实践中是有难度的。</p>
<p>我们将使用近似的方法来计算这些梯度，从而减小计算开销。常用的近似训练法包括负采样和层序 softmax。</p>
<h4 id="负采样"><a href="#负采样" class="headerlink" title="负采样"></a>负采样</h4><p>我们以跳字模型为例讨论负采样。</p>
<p>词典 $\mathcal{V}$ 大小之所以会在目标函数中出现，是因为中心词 $w_c$ 生成背景词 $w_o$ 的概率 $\mathbb{P}(w_o \mid w_c)$ 使用了 softmax，而 softmax 正是考虑了背景词可能是词典中的任一词，并体现在 softmax 的分母上。</p>
<p>我们不妨换个角度，假设中心词 $w_c$ 生成背景词 $w_o$ 由以下相互独立事件联合组成来近似</p>
<ul>
<li>中心词 $w_c$ 和背景词 $w_o$ 同时出现在该训练数据窗口</li>
<li>中心词 $w_c$ 和第 1 个噪声词 $w_1$ 不同时出现在该训练数据窗口（噪声词 $w_1$ 按噪声词分布 $\mathbb{P}(w)$ 随机生成，假设一定和 $w_c$ 不同时出现在该训练数据窗口）</li>
<li>…</li>
<li>中心词 $w_c$ 和第 $K$ 个噪声词 $w_K$ 不同时出现在该训练数据窗口（噪声词 $w_K$ 按噪声词分布 $\mathbb{P}(w)$ 随机生成，假设一定和 $w_c$ 不同时出现在该训练数据窗口）</li>
</ul>
<p>我们可以使用 $\sigma(x) = 1/(1+\text{exp}(-x))$ 函数来表达中心词 $w_c$ 和背景词 $w_o$ 同时出现在该训练数据窗口的概率：</p>
<script type="math/tex; mode=display">\mathbb{P}(D = 1 \mid w_o, w_c) = \sigma(\mathbf{u}_o^\top \mathbf{v}_c)</script><p>那么，中心词 $w_c$ 生成背景词 $w_o$ 的对数概率可以近似为</p>
<script type="math/tex; mode=display">\text{log} \mathbb{P} (w_o \mid w_c) = \text{log} [\mathbb{P}(D = 1 \mid w_o, w_c) \prod_{k=1, w_k \sim \mathbb{P}(w)}^K \mathbb{P}(D = 0 \mid w_k, w_c) ]</script><p>假设噪声词 $w_k$ 在词典中的索引为 $i_k$ ，上式可改写为</p>
<script type="math/tex; mode=display">\text{log} \mathbb{P} (w_o \mid w_c) = \text{log} \frac{1}{1+\text{exp}(-\mathbf{u}_o^\top \mathbf{v}_c)}  + \sum_{k=1, w_k \sim \mathbb{P}(w)}^K \text{log} [1-\frac{1}{1+\text{exp}(-\mathbf{u}_{i_k}^\top \mathbf{v}_c)}]</script><p>因此，有关中心词 $w_c$ 生成背景词 $w_o$ 的损失函数是</p>
<script type="math/tex; mode=display">- \text{log} \mathbb{P} (w_o \mid w_c) = -\text{log} \frac{1}{1+\text{exp}(-\mathbf{u}_o^\top \mathbf{v}_c)}  - \sum_{k=1, w_k \sim \mathbb{P}(w)}^K \text{log} \frac{1}{1+\text{exp}(\mathbf{u}_{i_k}^\top \mathbf{v}_c)}</script><p>当我们把 $K$ 取较小值时，每次随机梯度下降的梯度计算开销将由 $\mathcal{O}(|\mathcal{V}|)$ 降为 $\mathcal{O}(K)$ 。</p>
<p>我们也可以对连续词袋模型进行负采样。有关背景词 $w^{(t-m)}, \ldots,  w^{(t-1)},  w^{(t+1)}, \ldots,  w^{(t+m)}$ 生成中心词 $w_c$ 的损失函数</p>
<script type="math/tex; mode=display">-\text{log} \mathbb{P}(w^{(t)} \mid  w^{(t-m)}, \ldots,  w^{(t-1)},  w^{(t+1)}, \ldots,  w^{(t+m)})</script><p>在负采样中可以近似为</p>
<script type="math/tex; mode=display">-\text{log} \frac{1}{1+\text{exp}[-\mathbf{u}_c^\top (\mathbf{v}_{o_1} + \ldots + \mathbf{v}_{o_{2m}}) /(2m)]}  - \sum_{k=1, w_k \sim \mathbb{P}(w)}^K \text{log} \frac{1}{1+\text{exp}[(\mathbf{u}_{i_k}^\top (\mathbf{v}_{o_1} + \ldots + \mathbf{v}_{o_{2m}}) /(2m)]}</script><p>同样地，当我们把 $K$ 取较小值时，每次随机梯度下降的梯度计算开销将由 $\mathcal{O}(|\mathcal{V}|)$ 降为 $\mathcal{O}(K)$ 。</p>
<h4 id="层序-softmax"><a href="#层序-softmax" class="headerlink" title="层序 softmax"></a>层序 softmax</h4><p>层序 softmax 利用了二叉树。树的每个叶子节点代表着词典 $\mathcal{V}$ 中的每个词。每个词 $w_i$ 相应的词向量为 $\mathbf{v}_i$ 。我们以下图为例，来描述层序 softmax 的工作机制。</p>
<p><img src="/Blog/.io//hierarchical_softmax.svg" alt="hierarchical_softmax"></p>
<p>假设 $L(w)$ 为从二叉树的根到代表词 $w$ 的叶子节点的路径上的节点数，并设 $n(w,i)$ 为该路径上第 $i$ 个节点，该节点的向量为 $\mathbf{u}_{n(w,i)}$ 。以上图为例，$L(w_3) = 4$ 。那么，跳字模型和连续词袋模型所需要计算的任意词 $w_i$ 生成词 $w$ 的概率为：</p>
<script type="math/tex; mode=display">\mathbb{P}(w \mid w_i) = \prod_{j=1}^{L(w)-1} \sigma([n(w, j+1) = \text{leftChild}(n(w,j))] \cdot \mathbf{u}_{n(w,j)}^\top \mathbf{v}_i)</script><p>其中 $\sigma(x) = 1/(1+\text{exp}(-x))$，如果 $x$ 为真，$[x] = 1$；反之 $[x] = -1$。</p>
<p>由于 $\sigma(x)+\sigma(-x) = 1$，$w_i$ 生成词典中任何词的概率之和为 1：</p>
<script type="math/tex; mode=display">\sum_{w=1}^{\mathcal{V}} \mathbb{P}(w \mid w_i) = 1</script><p>让我们计算 $w_i$ 生成 $w_3$ 的概率，由于在二叉树中由根到 $w_3$ 的路径上需要向左、向右、再向左地遍历，我们得到</p>
<script type="math/tex; mode=display">\mathbb{P}(w_3 \mid w_i) = \sigma(\mathbf{u}_{n(w_3,1)}^\top \mathbf{v}_i)) \cdot \sigma(-\mathbf{u}_{n(w_3,2)}^\top \mathbf{v}_i)) \cdot \sigma(\mathbf{u}_{n(w_3,3)}^\top \mathbf{v}_i))</script><p>我们可以使用随机梯度下降在跳字模型和连续词袋模型中不断迭代计算字典中所有词向量 $\mathbf{v}$ 和非叶子节点的向量 $\mathbf{u}$ 。每次迭代的计算开销由 $\mathcal{O}(|\mathcal{V}|)$ 降为二叉树的高度 $\mathcal{O}(\text{log}|\mathcal{V}|)$。</p>
<h2 id="GloVe"><a href="#GloVe" class="headerlink" title="GloVe"></a>GloVe</h2><p><a href="https://nlp.stanford.edu/pubs/glove.pdf">GloVe</a> 是 Standford 团队在 2014 年发表的. GloVe 使用了词与词之间的共现（co-occurrence）信息。我们定义 $\mathbf{X}$ 为共现词频矩阵，其中元素 $x<em>{ij}$ 为词 $j$ 出现在词 $i$ 的环境（context）的次数。这里的“环境”有多种可能的定义。举个例子，在一段文本序列中，如果词 $j$ 出现在词 $i$ 左边或者右边不超过 10 个词的距离，我们可以认为词 $j$ 出现在词 $i$ 的环境一次。令 $x_i = \sum_k x</em>{ik}$ 为任意词出现在词 $i$ 的环境的次数。那么，</p>
<script type="math/tex; mode=display">P_{ij} = \mathbb{P}(j \mid i) = \frac{x_{ij}}{x_i}</script><p>为词 $j$ 出现在词 $i$ 的环境的概率。这一概率也称词 $i$ 和词 $j$ 的共现概率。</p>
<h3 id="共现概率比值"><a href="#共现概率比值" class="headerlink" title="共现概率比值"></a>共现概率比值</h3><p><a href="https://nlp.stanford.edu/pubs/glove.pdf">GloVe论文</a> 里展示了以下一组词对的共现概率与比值：</p>
<ul>
<li>$\mathbb{P}(k \mid \text{ice})$：0.00019（$k$= solid），0.000066（$k$= gas），0.003（$k$= water），0.000017（$k$= fashion）</li>
<li>$\mathbb{P}(k \mid \text{steam})$：0.000022（$k$= solid），0.00078（$k$= gas），0.0022（$k$= water），0.000018（$k$= fashion）</li>
<li>$\mathbb{P}(k \mid \text{ice}) / \mathbb{P}(k \mid \text{steam})$：8.9（$k$= solid），0.085（$k$= gas），1.36（$k$= water），0.96（$k$= fashion）</li>
</ul>
<p>我们通过上表可以观察到以下现象：</p>
<ul>
<li>对于与 ice 相关而与 steam 不相关的词 $k$ ，例如 $k=$solid ，我们期望共现概率比值 $P<em>{ik}/P</em>{jk}$ 较大，例如上面最后一栏的 8.9。</li>
<li>对于与 ice 不相关而与 steam 相关的词 $k$ ，例如 $k=$gas ，我们期望共现概率比值 $P<em>{ik}/P</em>{jk}$ 较小，例如上面最后一栏的 0.085。</li>
<li>对于与 ice 和 steam 都相关的词 $k$ ，例如 $k=$water ，我们期望共现概率比值 $P<em>{ik}/P</em>{jk}$ 接近 1，例如上面最后一栏的 1.36。</li>
<li>对于与 ice 和 steam 都不相关的词 $k$ ，例如 $k=$fashion，我们期望共现概率比值 $P<em>{ik}/P</em>{jk}$ 接近 1，例如上面最后一栏的 0.96。</li>
</ul>
<p>由此可见，共现概率比值能比较直观地表达词之间的关系。GloVe 试图用有关词向量的函数来表达共现概率比值。</p>
<h3 id="用词向量表达共现概率比值"><a href="#用词向量表达共现概率比值" class="headerlink" title="用词向量表达共现概率比值"></a>用词向量表达共现概率比值</h3><p>GloVe 的核心在于使用词向量表达共现概率比值。而任意一个这样的比值需要三个词 $i$、$j$ 和 $k$ 的词向量。对于共现概率 $P_{ij} = \mathbb{P}(j \mid i)$，我们称词 $i$ 和词 $j$ 分别为中心词和背景词。我们使用 $\mathbf{v}$ 和 $\tilde{\mathbf{v}}$ 分别表示中心词和背景词的词向量。</p>
<p>我们可以用有关词向量的函数 $f$ 来表达共现概率比值：</p>
<script type="math/tex; mode=display">f(\mathbf{v}_i, \mathbf{v}_j, \tilde{\mathbf{v}}_k) = \frac{P_{ik}}{P_{jk}}</script><p>需要注意的是，函数 $f$ 可能的设计并不唯一。首先，我们用向量之差来表达共现概率的比值，并将上式改写成</p>
<script type="math/tex; mode=display">f(\mathbf{v}_i - \mathbf{v}_j, \tilde{\mathbf{v}}_k) = \frac{P_{ik}}{P_{jk}}</script><p>由于共现概率比值是一个标量，我们可以使用向量之间的内积把函数 $f$ 的自变量进一步改写。我们可以得到</p>
<script type="math/tex; mode=display">f((\mathbf{v}_i - \mathbf{v}_j)^\top \tilde{\mathbf{v}}_k) = \frac{P_{ik}}{P_{jk}}</script><p>由于任意一对词共现的对称性，我们希望以下两个性质可以同时被满足：</p>
<ul>
<li>任意词作为中心词和背景词的词向量应该相等：对任意词 $i$ ，$\mathbf{v}_i = \tilde{\mathbf{v}}_i$</li>
<li>词与词之间共现次数矩阵 $\mathbf{X}$ 应该对称：对任意词 $i$ 和 $j$ ，$x<em>{ij} = x</em>{ji}$</li>
</ul>
<p>为了满足以上两个性质，一方面，我们令</p>
<script type="math/tex; mode=display">f((\mathbf{v}_i - \mathbf{v}_j)^\top \tilde{\mathbf{v}}_k) = \frac{f(\mathbf{v}_i^\top \tilde{\mathbf{v}}_k)}{f(\mathbf{v}_j^\top \tilde{\mathbf{v}}_k)}</script><p>并得到 $f(x) = \text{exp}(x)$ 。以上两式的右边联立，</p>
<script type="math/tex; mode=display">\exp(\mathbf{v}_i^\top \tilde{\mathbf{v}}_k) = P_{ik} = \frac{x_{ik}}{x_i}</script><p>由上式可得</p>
<script type="math/tex; mode=display">\mathbf{v}_i^\top \tilde{\mathbf{v}}_k = \log(x_{ik}) - \log(x_i)</script><p>另一方面，我们可以把上式中 $\log(x_i)$ 替换成两个偏移项之和 $b_i + b_k$，得到</p>
<script type="math/tex; mode=display">\mathbf{v}_i^\top \tilde{\mathbf{v}}_k = \log(x_{ik}) - b_i - b_k</script><p>将索引 $i$ 和 $k$ 互换，我们可验证对称性的两个性质可以同时被上式满足。</p>
<p>因此，对于任意一对词 $i$ 和 $j$ ，用它们词向量表达共现概率比值最终可以被简化为表达它们共现词频的对数：</p>
<script type="math/tex; mode=display">\mathbf{v}_i^\top \tilde{\mathbf{v}}_j + b_i + b_j = \log(x_{ij})</script><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>上式中的共现词频是直接在训练数据上统计得到的，为了学习词向量和相应的偏移项，我们希望上式中的左边与右边越接近越好。给定词典大小 $V$ 和权重函数 $f(x_{ij})$ ，我们定义损失函数为</p>
<script type="math/tex; mode=display">\sum_{i, j = 1}^V f(x_{ij}) (\mathbf{v}_i^\top \tilde{\mathbf{v}}_j + b_i + b_j - \log(x_{ij}))^2</script><p>对于权重函数 $f(x)$ ，一个建议的选择是，当 $x &lt; c$（例如 $c = 100$ ），令 $f(x) = (x/c)^\alpha$（例如 $\alpha = 0.75$ ），反之令 $f(x) = 1$ 。需要注意的是，损失函数的计算复杂度与共现词频矩阵 $\mathbf{X}$ 中非零元素的数目呈线性关系。我们可以从 $\mathbf{X}$ 中随机采样小批量非零元素，使用随机梯度下降迭代词向量和偏移项。</p>
<p>需要注意的是，对于任意一对 $i, j$，损失函数中存在以下两项之和</p>
<script type="math/tex; mode=display">f(x_{ij}) (\mathbf{v}_i^\top \tilde{\mathbf{v}}_j + b_i + b_j - \log(x_{ij}))^2 + f(x_{ji}) (\mathbf{v}_j^\top \tilde{\mathbf{v}}_i + b_j + b_i - \log(x_{ji}))^2</script><p>由于 $x<em>{ij} = x</em>{ji}$，对调 $\mathbf{v}$ 和 $\tilde{\mathbf{v}}$ 并不改变损失函数中这两项之和的值。也就是说，在损失函数所有项上对调 $\mathbf{v}$ 和 $\tilde{\mathbf{v}}$ 也不改变整个损失函数的值。因此，任意词的中心词向量和背景词向量是等价的。只是由于初始化值的不同，同一个词最终学习到的两组词向量可能不同。当所有词向量学习得到后，GloVe 使用一个词的中心词向量与背景词向量之和作为该词的最终词向量。</p>
<h2 id="fastText"><a href="#fastText" class="headerlink" title="fastText"></a>fastText</h2><p>fastText在使用负采样的跳字模型基础上，将每个中心词视为子词（subword）的集合，并学习子词的词向量。</p>
<p>以 where 这个词为例，设子词为 3 个字符，它的子词包括 “&lt;wh”、“whe”、“her”、“ere”、“re&gt;” 和特殊子词（整词）“&lt;where&gt;”。其中的 “&lt;” 和 “&gt;” 是为了将作为前后缀的子词区分出来。而且，这里的子词 “her” 与整词 “&lt;her&gt;” 也可被区分。给定一个词 $w$ ，我们通常可以把字符长度在 3 到 6 之间的所有子词和特殊子词的并集 $\mathcal{G}_w$ 取出。假设词典中任意子词 $g$ 的子词向量为 $\mathbf{z}_g$，我们可以把使用负采样的跳字模型的损失函数</p>
<script type="math/tex; mode=display">- \text{log} \mathbb{P} (w_o \mid w_c) = -\text{log} \frac{1}{1+\text{exp}(-\mathbf{u}_o^\top \mathbf{v}_c)}  - \sum_{k=1, w_k \sim \mathbb{P}(w)}^K \text{log} \frac{1}{1+\text{exp}(\mathbf{u}_{i_k}^\top \mathbf{v}_c)}</script><p>直接替换成</p>
<script type="math/tex; mode=display">- \text{log} \mathbb{P} (w_o \mid w_c) = -\text{log} \frac{1}{1+\text{exp}(-\mathbf{u}_o^\top \sum_{g \in \mathcal{G}_{w_c}} \mathbf{z}_g)}  - \sum_{k=1, w_k \sim \mathbb{P}(w)}^K \text{log} \frac{1}{1+\text{exp}(\mathbf{u}_{i_k}^\top \sum_{g \in \mathcal{G}_{w_c}} \mathbf{z}_g)}</script><p>我们可以看到，原中心词向量被替换成了中心词的子词向量的和。与整词学习（word2vec 和 GloVe）不同，词典以外的新词的词向量可以使用 fastText 中相应的子词向量之和。</p>
<p>fastText 对于一些语言较重要，例如阿拉伯语、德语和俄语。例如，德语中有很多复合词，例如乒乓球（英文 table tennis）在德语中叫 “Tischtennis”。fastText 可以通过子词表达两个词的相关性，例如 “Tischtennis” 和 “Tennis”。</p>
<h2 id="困惑度（Perplexity）"><a href="#困惑度（Perplexity）" class="headerlink" title="困惑度（Perplexity）"></a>困惑度（Perplexity）</h2><p>文章最后替一下语言模型的损失函数。在语言模型中，损失函数即被预测字符的对数似然平均值的相反数：</p>
<script type="math/tex; mode=display">\text{loss} = -\frac{1}{N} \sum_{i=1}^N \log p_{\text{target}_i}</script><p>其中 $N$ 是预测的字符总数，$p_{\text{target}_i}$ 是在第 $i$ 个预测中真实的下个字符被预测的概率。</p>
<p>而这里的困惑度可以简单的认为就是对交叉熵做 exp 运算使得数值更好读。</p>
<p>为了解释困惑度的意义，我们先考虑一个完美结果：模型总是把真实的下个字符的概率预测为 1 。也就是说，对任意的 $i$ 来说，$p_{\text{target}_i} = 1$ 。这种完美情况下，困惑度值为 <strong>1</strong> 。</p>
<p>我们再考虑一个基线结果：给定不重复的字符集合 $W$ 及其字符总数 $|W|$，模型总是预测下个字符为集合 $W$ 中任一字符的概率都相同。也就是说，对任意的 $i$ 来说，$p_{\text{target}_i} = 1/|W|$ 。这种基线情况下，困惑度值为 <strong>$|W|$</strong> 。</p>
<p>最后，我们可以考虑一个最坏结果：模型总是把真实的下个字符的概率预测为 0 。也就是说，对任意的 $i$ 来说，$p_{\text{target}_i} = 0$ 。这种最坏情况下，困惑度值为<strong>正无穷</strong>。</p>
<p>任何一个有效模型的困惑度值必须小于预测集中元素的数量。在本例中，困惑度必须小于字典中的字符数 $|W|$ 。如果一个模型可以取得较低的困惑度的值（更靠近 1 ），通常情况下，该模型预测更加准确。</p>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>MXNet/Gluon 深度学习笔记 (十一) —— seq2seq 和注意力机制</title>
    <url>/Blog/2018/02/28/deep-learning-limu-note11/</url>
    <content><![CDATA[<p>在基于词语的语言模型中，我们使用了循环神经网络。它的输入是一段不定长的序列，输出却是定长的，例如一个词语。然而，很多问题的输出也是不定长的序列。以机器翻译为例，输入是可以是英语的一段话，输出可以是法语的一段话，输入和输出皆不定长，例如</p>
<blockquote>
<p>英语：They are watching.</p>
<p>法语：Ils regardent.</p>
</blockquote>
<p>当输入输出都是不定长序列时，我们可以使用编码器—解码器（encoder-decoder）或者 seq2seq。它们分别基于 2014 年的两个工作：</p>
<ul>
<li>Cho et al., <a href="https://www.aclweb.org/anthology/D14-1179">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a></li>
<li>Sutskever et al., <a href="https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf">Sequence to Sequence Learning with Neural Networks</a></li>
</ul>
<p>以上两个工作本质上都用到了两个循环神经网络，分别叫做编码器和解码器。编码器对应输入序列，解码器对应输出序列。</p>
<p>seq2seq 示意图:</p>
<p><img src="/Blog/.io//seq2seq.png" alt="seq2seq"></p>
<span id="more"></span>
<h2 id="编码器—解码器"><a href="#编码器—解码器" class="headerlink" title="编码器—解码器"></a>编码器—解码器</h2><p>编码器和解码器是分别对应输入序列和输出序列的两个循环神经网络。我们通常会在输入序列和输出序列后面分别附上一个特殊字符 ‘&lt;eos&gt;’（end of sequence）表示序列的终止。在测试模型时，一旦输出 ‘&lt;eos&gt;’ 就终止当前的输出序列。</p>
<h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p>编码器的作用是把一个不定长的输入序列转化成一个定长的背景向量 $\mathbf{c}$ 。该背景向量包含了输入序列的信息。常用的编码器是循环神经网络。</p>
<p>假设循环神经网络单元为 $f$ ，在 $t$ 时刻的输入为 $x_t, t=1, \ldots, T$。<br>假设 $\mathbf{x}_t$ 是单个输出 $x_t$ 在嵌入层的结果，例如 $x_t$ 对应的 one-hot向量$\mathbf{o} \in \mathbb{R}^x$ 与嵌入层参数矩阵 $\mathbf{E} \in \mathbb{R}^{x \times h}$ 的乘积 $\mathbf{o}^\top \mathbf{E}$ 。隐含层变量</p>
<script type="math/tex; mode=display">\mathbf{h}_t = f(\mathbf{x}_t, \mathbf{h}_{t-1})</script><p>编码器的背景向量</p>
<script type="math/tex; mode=display">\mathbf{c} =  q(\mathbf{h}_1, \ldots, \mathbf{h}_T)</script><p>一个简单的背景向量是该网络最终时刻的隐含层变量 $\mathbf{h}_T$, 我们将这里的循环神经网络叫做编码器。</p>
<h4 id="双向循环神经网络"><a href="#双向循环神经网络" class="headerlink" title="双向循环神经网络"></a>双向循环神经网络</h4><p>编码器的输入既可以是正向传递，也可以是反向传递。如果输入序列是 $x_1, x_2, \ldots, x_T$ ，在正向传递中，隐含层变量</p>
<script type="math/tex; mode=display">\overrightarrow{\mathbf{h}}_t = f(\mathbf{x}_t, \overrightarrow{\mathbf{h}}_{t-1})</script><p>而反向传递中，隐含层变量的计算变为</p>
<script type="math/tex; mode=display">\overleftarrow{\mathbf{h}}_t = f(\mathbf{x}_t, \overleftarrow{\mathbf{h}}_{t+1})</script><p>当希望编码器的输入既包含正向传递信息又包含反向传递信息时，可以使用双向循环神经网络。例如，给定输入序列 $x_1, x_2, \ldots, x_T$，按正向传递，它们在循环神经网络的隐含层变量分别是 $\overrightarrow{\mathbf{h}}_1, \overrightarrow{\mathbf{h}}_2, \ldots, \overrightarrow{\mathbf{h}}_T$；按反向传递，它们在循环神经网络的隐含层变量分别是 $\overleftarrow{\mathbf{h}}_1, \overleftarrow{\mathbf{h}}_2, \ldots, \overleftarrow{\mathbf{h}}_T$。在双向循环神经网络中，时刻 $i$ 的隐含层变量可以把 $\overrightarrow{\mathbf{h}}_i$ 和 $\overleftarrow{\mathbf{h}}_i$ 连结起来。</p>
<p><img src="/Blog/.io//bi-rnn.svg" alt="bi-rnn"></p>
<p>基于 GRU 的编码器实现:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encoder</span>(<span class="params">Block</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;编码器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, input_dim, hidden_dim, num_layers, drop_prob</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Encoder, self).__init__()</span><br><span class="line">        <span class="keyword">with</span> self.name_scope():</span><br><span class="line">            self.embedding = nn.Embedding(input_dim, hidden_dim)</span><br><span class="line">            self.dropout = nn.Dropout(drop_prob)</span><br><span class="line">            self.rnn = rnn.GRU(hidden_dim, num_layers, dropout=drop_prob,</span><br><span class="line">                               input_size=hidden_dim)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, inputs, state</span>):</span></span><br><span class="line">        <span class="comment"># inputs尺寸: (1, num_steps, 256)，emb尺寸: (num_steps, 1, 256)</span></span><br><span class="line">        emb = self.embedding(inputs).swapaxes(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        emb = self.dropout(emb)</span><br><span class="line">        output, state = self.rnn(emb, state)</span><br><span class="line">        <span class="keyword">return</span> output, state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">begin_state</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.rnn.begin_state(*args, **kwargs)</span><br></pre></td></tr></table></figure></p>
<h3 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h3><p>编码器最终输出了一个背景向量 $\mathbf{c}$，该背景向量编码了输入序列 $x_1, x_2, \ldots, x_T$ 的信息。</p>
<p>假设训练数据中的输出序列是 $y<em>1, y_2, \ldots, y</em>{T^\prime}$ ，我们希望表示每个 $t$ 时刻输出的既取决于之前的输出又取决于背景向量。之后，我们就可以最大化输出序列的联合概率</p>
<script type="math/tex; mode=display">\mathbb{P}(y_1, \ldots, y_{T^\prime}) = \prod_{t^\prime=1}^{T^\prime} \mathbb{P}(y_{t^\prime} \mid y_1, \ldots, y_{t^\prime-1}, \mathbf{c})</script><p>并得到该输出序列的损失函数</p>
<script type="math/tex; mode=display">- \log\mathbb{P}(y_1, \ldots, y_{T^\prime})</script><p>为此，我们使用另一个循环神经网络作为解码器。解码器使用函数 $p$ 来表示单个输出 $y_{t^\prime}$ 的概率</p>
<script type="math/tex; mode=display">\mathbb{P}(y_{t^\prime} \mid y_1, \ldots, y_{t^\prime-1}, \mathbf{c}) = p(y_{t^\prime-1}, \mathbf{s}_{t^\prime}, \mathbf{c})</script><p>其中的 $\mathbf{s}_t$ 为 $t^\prime$ 时刻的解码器的隐含层变量。该隐含层变量</p>
<script type="math/tex; mode=display">\mathbf{s}_{t^\prime} = g(y_{t^\prime-1}, \mathbf{c}, \mathbf{s}_{t^\prime-1})</script><p>其中函数 $g$ 是循环神经网络单元。</p>
<p>需要注意的是，编码器和解码器通常会使用<strong>多层循环神经网络</strong>。</p>
<h2 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h2><p>在以上的解码器设计中，各个时刻使用了相同的背景向量, 如果解码器的不同时刻可以使用不同的背景向量呢？</p>
<p>以英语-法语翻译为例，给定一对输入序列 “they are watching” 和输出序列 “Ils regardent” ，解码器在时刻 1 可以使用更多编码了 “they are” 信息的背景向量来生成 “Ils”，而在时刻 2 可以使用更多编码了 “watching” 信息的背景向量来生成 “regardent”, 这看上去就像是在解码器的每一时刻对输入序列中不同时刻分配不同的注意力, 这也是注意力机制的由来。它最早<a href="https://arxiv.org/abs/1409.0473">由Bahanau等在2015年提出</a>。</p>
<p>现在，对上面的解码器稍作修改。我们假设时刻 $t^\prime$ 的背景向量为 $\mathbf{c}_{t^\prime}$, 那么解码器在 $t^\prime$ 时刻的隐含层变量</p>
<script type="math/tex; mode=display">\mathbf{s}_{t^\prime} = g(\mathbf{y}_{t^\prime-1}, \mathbf{c}_{t^\prime}, \mathbf{s}_{t^\prime-1})</script><p>令编码器在 $t$ 时刻的隐含变量为 $\mathbf{h}_t$ ，解码器在 $t^\prime$ 时刻的背景向量为</p>
<script type="math/tex; mode=display">\mathbf{c}_{t^\prime} = \sum_{t=1}^T \alpha_{t^\prime t} \mathbf{h}_t</script><p>也就是说，给定解码器的当前时刻 $t^\prime$ ，我们需要对解码器中不同时刻的隐含层变量求加权平均。而权值也称注意力权重。它的计算公式是</p>
<script type="math/tex; mode=display">\alpha_{t^\prime t} = \frac{\exp(e_{t^\prime t})}{ \sum_{k=1}^T \exp(e_{t^\prime k}) }</script><p>而 $e_{t^\prime t} \in \mathbb{R}$ 的计算为：</p>
<script type="math/tex; mode=display">e_{t^\prime t} = a(\mathbf{s}_{t^\prime - 1}, \mathbf{h}_t)</script><p>其中函数 $a$ 有多种设计方法。在<a href="https://arxiv.org/abs/1409.0473">Bahanau的论文</a>中，</p>
<script type="math/tex; mode=display">e_{t^\prime t} = \mathbf{v}^\top \tanh(\mathbf{W}_s \mathbf{s}_{t^\prime - 1} + \mathbf{W}_h \mathbf{h}_t)</script><p>其中的 $\mathbf{v}$、$\mathbf{W}_s$、$\mathbf{W}_h$ 和编码器与解码器两个循环神经网络中的各个权重和偏移项以及嵌入层参数等都是需要同时学习的模型参数。在<a href="https://arxiv.org/abs/1409.0473">Bahanau的论文</a>中，编码器和解码器分别使用了门控循环单元（GRU）。</p>
<p>在解码器中，我们需要对GRU的设计稍作修改。假设 $\mathbf{y}<em>t$ 是单个输出 $y_t$ 在嵌入层的结果，例如 $y_t$ 对应的 one-hot 向量 $\mathbf{o} \in \mathbb{R}^y$ 与嵌入层参数矩阵 $\mathbf{B} \in \mathbb{R}^{y \times s}$ 的乘积 $\mathbf{o}^\top \mathbf{B}$。<br>假设时刻 $t^\prime$ 的背景向量为 $\mathbf{c}</em>{t^\prime}$ 。那么解码器在 $t^\prime$ 时刻的单个隐含层变量</p>
<script type="math/tex; mode=display">\mathbf{s}_{t^\prime} = \mathbf{z}_{t^\prime} \odot \mathbf{s}_{t^\prime-1}  + (1 - \mathbf{z}_{t^\prime}) \odot \tilde{\mathbf{s}}_{t^\prime}</script><p>其中的重置门、更新门和候选隐含状态分别为</p>
<script type="math/tex; mode=display">\mathbf{r}_{t^\prime} = \sigma(\mathbf{W}_{yr} \mathbf{y}_{t^\prime-1} + \mathbf{W}_{sr} \mathbf{s}_{t^\prime - 1} + \mathbf{W}_{cr} \mathbf{c}_{t^\prime} + \mathbf{b}_r)</script><script type="math/tex; mode=display">\mathbf{z}_{t^\prime} = \sigma(\mathbf{W}_{yz} \mathbf{y}_{t^\prime-1} + \mathbf{W}_{sz} \mathbf{s}_{t^\prime - 1} + \mathbf{W}_{cz} \mathbf{c}_{t^\prime} + \mathbf{b}_z)</script><script type="math/tex; mode=display">\tilde{\mathbf{s}}_{t^\prime} = \text{tanh}(\mathbf{W}_{ys} \mathbf{y}_{t^\prime-1} + \mathbf{W}_{ss} (\mathbf{s}_{t^\prime - 1} \odot \mathbf{r}_{t^\prime}) + \mathbf{W}_{cs} \mathbf{c}_{t^\prime} + \mathbf{b}_s)</script><p>基于 GRU 的解码器实现, 含注意力机制<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoder</span>(<span class="params">Block</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;含注意力机制的解码器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, hidden_dim, output_dim, num_layers, max_seq_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                 drop_prob, alignment_dim, encoder_hidden_dim</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Decoder, self).__init__()</span><br><span class="line">        self.max_seq_len = max_seq_len</span><br><span class="line">        self.encoder_hidden_dim = encoder_hidden_dim</span><br><span class="line">        self.hidden_size = hidden_dim</span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line">        <span class="keyword">with</span> self.name_scope():</span><br><span class="line">            self.embedding = nn.Embedding(output_dim, hidden_dim)</span><br><span class="line">            self.dropout = nn.Dropout(drop_prob)</span><br><span class="line">            <span class="comment"># 注意力机制。</span></span><br><span class="line">            self.attention = nn.Sequential()</span><br><span class="line">            <span class="keyword">with</span> self.attention.name_scope():</span><br><span class="line">                self.attention.add(nn.Dense(</span><br><span class="line">                    alignment_dim, in_units=hidden_dim + encoder_hidden_dim,</span><br><span class="line">                    activation=<span class="string">&quot;tanh&quot;</span>, flatten=<span class="literal">False</span>))</span><br><span class="line">                self.attention.add(nn.Dense(<span class="number">1</span>, in_units=alignment_dim,</span><br><span class="line">                                            flatten=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line">            self.rnn = rnn.GRU(hidden_dim, num_layers, dropout=drop_prob,</span><br><span class="line">                               input_size=hidden_dim)</span><br><span class="line">            self.out = nn.Dense(output_dim, in_units=hidden_dim)</span><br><span class="line">            self.rnn_concat_input = nn.Dense(</span><br><span class="line">                hidden_dim, in_units=hidden_dim + encoder_hidden_dim,</span><br><span class="line">                flatten=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, cur_input, state, encoder_outputs</span>):</span></span><br><span class="line">        <span class="comment"># 当RNN为多层时，取最靠近输出层的单层隐含状态。</span></span><br><span class="line">        single_layer_state = [state[<span class="number">0</span>][-<span class="number">1</span>].expand_dims(<span class="number">0</span>)]</span><br><span class="line">        encoder_outputs = encoder_outputs.reshape((self.max_seq_len, <span class="number">1</span>,</span><br><span class="line">                                                   self.encoder_hidden_dim))</span><br><span class="line">        <span class="comment"># single_layer_state尺寸: [(1, 1, decoder_hidden_dim)]</span></span><br><span class="line">        <span class="comment"># hidden_broadcast尺寸: (max_seq_len, 1, decoder_hidden_dim)</span></span><br><span class="line">        hidden_broadcast = nd.broadcast_axis(single_layer_state[<span class="number">0</span>], axis=<span class="number">0</span>,</span><br><span class="line">                                             size=self.max_seq_len)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># encoder_outputs_and_hiddens尺寸:</span></span><br><span class="line">        <span class="comment"># (max_seq_len, 1, encoder_hidden_dim + decoder_hidden_dim)</span></span><br><span class="line">        encoder_outputs_and_hiddens = nd.concat(encoder_outputs,</span><br><span class="line">                                                hidden_broadcast, dim=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># energy尺寸: (max_seq_len, 1, 1)</span></span><br><span class="line">        energy = self.attention(encoder_outputs_and_hiddens)</span><br><span class="line"></span><br><span class="line">        batch_attention = nd.softmax(energy, axis=<span class="number">0</span>).reshape(</span><br><span class="line">            (<span class="number">1</span>, <span class="number">1</span>, self.max_seq_len))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># batch_encoder_outputs尺寸: (1, max_seq_len, encoder_hidden_dim)</span></span><br><span class="line">        batch_encoder_outputs = encoder_outputs.swapaxes(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># decoder_context尺寸: (1, 1, encoder_hidden_dim)</span></span><br><span class="line">        decoder_context = nd.batch_dot(batch_attention, batch_encoder_outputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># input_and_context尺寸: (1, 1, encoder_hidden_dim + decoder_hidden_dim)</span></span><br><span class="line">        input_and_context = nd.concat(self.embedding(cur_input).reshape(</span><br><span class="line">            (<span class="number">1</span>, <span class="number">1</span>, self.hidden_size)), decoder_context, dim=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># concat_input尺寸: (1, 1, decoder_hidden_dim)</span></span><br><span class="line">        concat_input = self.rnn_concat_input(input_and_context)</span><br><span class="line">        concat_input = self.dropout(concat_input)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当RNN为多层时，用单层隐含状态初始化各个层的隐含状态。</span></span><br><span class="line">        state = [nd.broadcast_axis(single_layer_state[<span class="number">0</span>], axis=<span class="number">0</span>,</span><br><span class="line">                                   size=self.num_layers)]</span><br><span class="line"></span><br><span class="line">        output, state = self.rnn(concat_input, state)</span><br><span class="line">        output = self.dropout(output)</span><br><span class="line">        output = self.out(output)</span><br><span class="line">        <span class="comment"># output尺寸: (1, output_size)，hidden尺寸: [(1, 1, decoder_hidden_dim)]</span></span><br><span class="line">        <span class="keyword">return</span> output, state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">begin_state</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.rnn.begin_state(*args, **kwargs)</span><br></pre></td></tr></table></figure><br>为了初始化解码器的隐含状态，我们通过一层全连接网络来转化编码器的输出隐含状态<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoderInitState</span>(<span class="params">Block</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;解码器隐含状态的初始化&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, encoder_hidden_dim, decoder_hidden_dim</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DecoderInitState, self).__init__()</span><br><span class="line">        <span class="keyword">with</span> self.name_scope():</span><br><span class="line">            self.dense = nn.Dense(decoder_hidden_dim,</span><br><span class="line">                                  in_units=encoder_hidden_dim,</span><br><span class="line">                                  activation=<span class="string">&quot;tanh&quot;</span>, flatten=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, encoder_state</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [self.dense(encoder_state)]</span><br></pre></td></tr></table></figure></p>
<h2 id="束搜索"><a href="#束搜索" class="headerlink" title="束搜索"></a>束搜索</h2><p>上文我们提到编码器最终输出了一个背景向量 $\mathbf{c}$，该背景向量编码了输入序列 $x<em>1, x_2, \ldots, x_T$ 的信息。假设训练数据中的输出序列是 $y_1, y_2, \ldots, y</em>{T^\prime}$，输出序列的生成概率是</p>
<script type="math/tex; mode=display">\mathbb{P}(y_1, \ldots, y_{T^\prime}) = \prod_{t^\prime=1}^{T^\prime} \mathbb{P}(y_{t^\prime} \mid y_1, \ldots, y_{t^\prime-1}, \mathbf{c})</script><p>对于机器翻译的输出来说，如果输出语言的词汇集合 $\mathcal{Y}$ 的大小为 $|\mathcal{Y}|$，输出序列的长度为 $T^\prime$，那么可能的输出序列种类是 $\mathcal{O}(|\mathcal{Y}|^{T^\prime})$。为了找到生成概率最大的输出序列，一种方法是计算所有 $\mathcal{O}(|\mathcal{Y}|^{T^\prime})$ 种可能序列的生成概率，并输出概率最大的序列。我们将该序列称为最优序列。但是这种方法的计算开销过高（例如，$10000^{10} = 1 \times 10^{40}$）。</p>
<p>我们目前所介绍的解码器在每个时刻只输出生成概率最大的一个词汇。对于任一时刻 $t^\prime$，我们从 $|\mathcal{Y}|$ 个词中搜索出输出词</p>
<script type="math/tex; mode=display">y_{t^\prime} = \text{argmax}_{y_{t^\prime} \in \mathcal{Y}} \mathbb{P}(y_{t^\prime} \mid y_1, \ldots, y_{t^\prime-1}, \mathbf{c})</script><p>因此，搜索计算开销（ $\mathcal{O}(|\mathcal{Y}| \times {T^\prime})$ ）显著下降（例如，$10000 \times 10 = 1 \times 10^5$），但这并不能保证一定搜索到最优序列。</p>
<p><strong>束搜索（beam search）</strong> 介于上面二者之间。我们来看一个例子。</p>
<p>假设输出序列的词典中只包含五个词：$\mathcal{Y} = {A, B, C, D, E}$。束搜索的一个超参数叫做 <strong>束宽（beam width）</strong>。以束宽等于 2 为例，假设输出序列长度为 3，假如时刻 1 生成概率 $\mathbb{P}(y_{t^\prime} \mid \mathbf{c})$ 最大的两个词为 $A$ 和 $C$ ，我们在时刻 2 对于所有的 $y_2 \in \mathcal{Y}$ 都分别计算 $\mathbb{P}(y_2 \mid A, \mathbf{c})$ 和 $\mathbb{P}(y_2 \mid C, \mathbf{c})$ ，从计算出的 10 个概率中取最大的两个，假设为 $\mathbb{P}(B \mid A, \mathbf{c})$ 和 $\mathbb{P}(E \mid C, \mathbf{c})$ 。那么，我们在时刻 3 对于所有的 $y_3 \in \mathcal{Y}$ 都分别计算 $\mathbb{P}(y_3 \mid A, B, \mathbf{c})$ 和 $\mathbb{P}(y_3 \mid C, E, \mathbf{c})$ ，从计算出的 10 个概率中取最大的两个，假设为 $\mathbb{P}(D \mid A, B, \mathbf{c})$ 和 $\mathbb{P}(D \mid C, E, \mathbf{c})$。</p>
<p>接下来，我们可以在输出序列：$A$、$C$、$AB$、$CE$、$ABD$、$CED$ 中筛选出以特殊字符 EOS 结尾的候选序列。再在候选序列中取以下分数最高的序列作为最终候选序列：</p>
<script type="math/tex; mode=display">\frac{1}{L^\alpha} \log \mathbb{P}(y_1, \ldots, y_{L}) = \frac{1}{L^\alpha} \sum_{t^\prime=1}^L \log \mathbb{P}(y_{t^\prime} \mid y_1, \ldots, y_{t^\prime-1}, \mathbf{c})</script><p>其中 $L$ 为候选序列长度，$\alpha$ 一般可选为 0.75。分母上的 $L^\alpha$ 是为了惩罚较长序列的分数中的对数相加项。</p>
<h2 id="评价翻译结果"><a href="#评价翻译结果" class="headerlink" title="评价翻译结果"></a>评价翻译结果</h2><p>2002 年，IBM 团队提出了一种评价翻译结果的指标，叫做 <a href="https://www.aclweb.org/anthology/P02-1040.pdf">BLEU</a> （Bilingual Evaluation Understudy）。</p>
<p>设 $k$ 为我们希望评价的 n-gram 的最大长度，例如 $k=4$ 。n-gram 的精度 $p<em>n$ 为模型输出中的 n-gram 匹配参考输出的数量与模型输出中的 n-gram 的数量的比值。例如，参考输出（真实值）为 ABCDEF，模型输出为 ABBCD。那么 $p_1 = 4/5, p_2 = 3/4, p_3 = 1/3, p_4 = 0$。设 $len</em>{ref}$ 和 $len_{MT}$ 分别为参考输出和模型输出的词数。那么，BLEU 的定义为</p>
<script type="math/tex; mode=display">\exp(\min(0, 1 - \frac{len_{ref}}{len_{MT}})) \prod_{i=1}^k p_n^{1/2^n}</script><p>需要注意的是，随着 $n$ 的提高，n-gram 的精度的权值随着 $p_n^{1/2^n}$ 中的指数减小而提高。例如 $0.5^{1/2} \approx 0.7, 0.5^{1/4} \approx 0.84, 0.5^{1/8} \approx 0.92, 0.5^{1/16} \approx 0.96$。换句话说，匹配 4-gram 比匹配 1-gram 应该得到更多奖励。另外，模型输出越短往往越容易得到较高的 n-gram 的精度。因此，BLEU 公式里连乘项前面的系数为了惩罚较短的输出。例如当 $k=2$ 时，参考输出为 ABCDEF，而模型输出为 AB，此时的 $p_1 = p_2 = 1$，而 $\exp(1-6/3) \approx 0.37$，因此 BLEU=0.37。当模型输出也为 ABCDEF 时，BLEU=1。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>编码器-解码器（seq2seq）的输入和输出可以都是不定长序列。</li>
<li>在解码器上应用注意力机制可以在解码器的每个时刻使用不同的背景向量。每个背景向量相当于对输入序列的不同部分分配了不同的注意力。</li>
<li>我们可以将编码器—解码器和注意力机制应用于神经机器翻译中。</li>
<li>束搜索有可能提高输出质量。</li>
<li>BLEU可以用来评价翻译结果。</li>
</ul>
]]></content>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>git 的内部原理</title>
    <url>/Blog/2016/07/31/git-bottom-layer-principles/</url>
    <content><![CDATA[<p>从根本上来讲 Git 是一套<strong>内容寻址</strong> (content-addressable) 文件系统，在此之上提供了一个 VCS(版本控制) 用户界面。</p>
<h2 id="底层命令-Plumbing-和高层命令-Porcelain"><a href="#底层命令-Plumbing-和高层命令-Porcelain" class="headerlink" title="底层命令 (Plumbing) 和高层命令 (Porcelain)"></a>底层命令 (Plumbing) 和高层命令 (Porcelain)</h2><p><code>Plimbing命令</code>：底层命令。用于以 UNIX 风格使用或由脚本调用。<br>其他的更友好的命令则被称为 <code>porcelain</code> 命令（高层命令）。</p>
<p>我们一般使用的 Git 命令 <code>checkout</code> <code>branch</code> <code>remote</code> 为 procelain 命令。<br><span id="more"></span><br>每一个 git 仓库都有一个 .git 目录，全新的 .git 目录的文件有：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HEAD            #指向当前分支</span><br><span class="line">branches/       #老版本有，新版本不再使用</span><br><span class="line">config          #包含了项目特有的配置选项</span><br><span class="line">description     #仅供 GitWeb 程序使用</span><br><span class="line">hooks/          #保存了客户端或服务端钩子脚本</span><br><span class="line">index           #保存了暂存区域信息</span><br><span class="line">info/           #保存了一份不希望在 .gitignore 文件中管理的忽略模式 (ignored patterns) 的全局可执行文件</span><br><span class="line">objects/        #存储所有数据内容</span><br><span class="line">refs/           #存储指向数据 (分支) 的提交对象的指针</span><br></pre></td></tr></table></figure></p>
<h2 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h2><p>git 从核心来看只是简单的存储<strong>键值对</strong>（key-value）。它允许插入任意类型的内容，并会返回一个键值，通过该键值可以在任何时候再取出该内容。<br>通过底层的<code>hash-object</code> 可以演示该过程，传一些数据给该命令，它会将数据保存在 <code>.git</code> 目录并返回表示这些数据的键值。</p>
<p>Git 初始化了 <code>objects</code>目录，同时在该目录下创建了 <code>pack</code> 和 <code>info</code> 子目录，但是该目录下没有其他常规文件。<br>可以通过以下命令往 Git 数据库中写入内容：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &#x27;test content&#x27; | git hash-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure><br>参数<code>-w</code>指示<code>hash-object</code>命令存储 (数据) 对象，若不指定这个参数该命令仅仅返回键值；<br><code>--stdin</code> 指定从标准输入设备 (stdin) 来读取内容，若不指定这个参数则需指定一个要存储的文件的路径。<br>该命令输出长度为 40 个字符的校验和。这是个 SHA-1 哈希值──其值为要存储的数据加上一种头信息的校验和。</p>
<p>查看到 Git 已经存储了数据:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ find .git/objects -type f</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure><br>可以看到，Git 存储数据内容的方式是： 为每份内容生成一个文件，取得该内容与头信息的 SHA-1 校验和，创建以该校验和<strong>前两个字符</strong>为名称的子目录，并以 (校验和) 剩下 38 个字符为文件命名 (保存至子目录下)。</p>
<p>通过 <code>cat-file</code> 命令可以将数据内容取回。。传入 -p 参数可以让该命令输出数据内容的类型：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">test content</span><br></pre></td></tr></table></figure><br>也可以直接添加文件：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &#x27;version 1&#x27; &gt; test.txt</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line"></span><br><span class="line">$ echo &#x27;version 2&#x27; &gt; test.txt               #写入新内容再次保存</span><br><span class="line">$ git hash-object -w test.txt</span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a    #可以发现SHA1码变了</span><br><span class="line"></span><br><span class="line">$ find .git/objects -type f                 #查看现在的objects内容</span><br><span class="line">.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">.git/objects/83/baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line"></span><br><span class="line">#将文件恢复到第一版本</span><br><span class="line">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt</span><br><span class="line">$ cat test.txt</span><br><span class="line">version 1</span><br></pre></td></tr></table></figure></p>
<h3 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h3><blockquote>
<p>Git 存储文件的形式：<br>所有内容以 <code>tree</code> 或 <code>blob</code> 对象存储，其中 <code>tree</code> 对象对应于 UNIX 中的目录，<code>blob</code> 对象则大致对应于 <code>inodes</code> 或文件内容。一个单独的 <code>tree</code> 对象包含一条或多条 <code>tree</code> 记录，每一条记录含有一个指向 <code>blob</code> 或子 <code>tree</code> 对象的 <code>SHA-1</code> 指针，并附有该对象的权限模式 (mode)、类型和文件名信息。</p>
</blockquote>
<p>树对象示意图：<br><img src="http://git.oschina.net/progit/figures/18333fig0901-tn.png" alt="树对象"></p>
<p><strong>可以自己创建树对象：</strong></p>
<pre><code>通常 Git 根据你的暂存区域或 index 来创建并写入一个 tree 。因此要创建一个 tree 对象的话首先要通过将一些文件暂存从而创建一个 index 。可以使用 plumbing 命令 update-index 为一个单独文件创建一个 index　。通过该命令人为的将文件的首个版本加入到了一个新的暂存区域中。由于该文件原先并不在暂存区域中 (甚至就连暂存区域也还没被创建出来) ，必须传入 --add 参数;由于要添加的文件并不在当前目录下而是在数据库中，必须传入 --cacheinfo 参数。同时指定了文件模式，SHA-1 值和文件名：
</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git update-index --add --cacheinfo 100644 \</span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30 test.txt</span><br></pre></td></tr></table></figure>
<p><code>100644</code> : 表明为普通文件<br><code>100755</code> : 可执行文件<br><code>120000</code> : 符号链接<br>这三种模式仅对 Git 中的 blob 有效。</p>
<p>现在可以用 <code>write-tree</code> 命令将暂存区域的内容写到一个 tree 对象了。无需 <code>-w</code> 参数 ── 如果目标 tree 不存在，调用 write-tree 会自动根据 index 状态创建一个 tree 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> $ git write-tree</span><br><span class="line">    d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">    100644 blob 83baae61804e65cc73a7201a7252750c76066a30 test.txt</span><br><span class="line">    </span><br><span class="line">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579      #验证是否为tree对象</span><br><span class="line">    tree</span><br><span class="line">    </span><br><span class="line">#创建一个新文件与新tree对象</span><br><span class="line">$ echo &#x27;new file&#x27; &gt; new.txt</span><br><span class="line">$ git update-index test.txt</span><br><span class="line">$ git update-index --add new.txt</span><br><span class="line"></span><br><span class="line">#创建该 tree 对象</span><br><span class="line">$ git write-tree</span><br><span class="line">    0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">    100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt</span><br><span class="line">    100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span><br><span class="line"></span><br><span class="line">#将一个已有的 tree 对象作为一个子 tree 读到暂存区域中</span><br><span class="line">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">$ git write-tree</span><br><span class="line">    3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">    040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579 bak</span><br><span class="line">    100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt</span><br><span class="line">    100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span><br></pre></td></tr></table></figure>
<p> 此时 tree 对象示意图：<br> <img src="http://git.oschina.net/progit/figures/18333fig0902-tn.png" alt="tree"></p>
<h3 id="commit-对象"><a href="#commit-对象" class="headerlink" title="commit 对象"></a>commit 对象</h3><p>commit 对象保存了“关于谁、何时以及为何保存了这些快照”的信息。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建 commit 对象</span><br><span class="line">$ echo &#x27;first commit&#x27; | git commit-tree d8329f</span><br><span class="line">    fdf4fc3344e67ab068f836878b6c4951e3b15f3d</span><br><span class="line">    </span><br><span class="line">#查看 commit 对象</span><br><span class="line">$ git cat-file -p fdf4fc3</span><br><span class="line">    tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">    author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700</span><br><span class="line">    committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line">/*</span><br><span class="line">commit 对象有格式很简单：指明了该时间点项目快照的顶层树对象、作者/提交者信息（从 Git 设置的 user.name 和 user.email中获得)以及当前时间戳、一个空行，以及提交注释信息。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#查看 git 历史</span><br><span class="line">$ git log --stat 1a410e</span><br><span class="line">     commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d</span><br><span class="line">    Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">    Date: Fri May 22 18:09:34 2009 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line">    test.txt | 1 +</span><br><span class="line">    1 files changed, 1 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure><br> blob，tree 以及 commit 对象都各自以文件的方式保存在 <code>.git/objects</code> 目录下。</p>
<p> 目前对象示意图：<br> <img src="http://git.oschina.net/progit/figures/18333fig0903-tn.png" alt="对象图"></p>
<h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>当存储数据内容时，同时会有一个文件头被存储起来。 Git 是如何存储对象的呢？<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//进入ruby交互模式</span><br><span class="line">$irb</span><br><span class="line">    &gt;&gt; content = &quot;what is up, doc?&quot;</span><br><span class="line">    =&gt; &quot;what is up, doc?&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Git 以对象类型为起始内容构造一个文件头，本例中是一个 blob</span><br><span class="line">然后添加一个空格，接着是数据内容的长度，最后是一个空字节 (null byte)：</span><br><span class="line">*/</span><br><span class="line">    &gt;&gt; header = &quot;blob #&#123;content.length&#125;\0&quot;</span><br><span class="line">    =&gt; &quot;blob 16\000&quot;</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line"> Git 将文件头与原始数据内容拼接起来，并计算拼接后的新内容的 SHA-1 校验和。可以在 Ruby 中使用 require 语句导入 SHA1 digest 库，然后调用 Digest::SHA1.hexdigest() 方法计算字符串的 SHA-1 值：</span><br><span class="line"> */   </span><br><span class="line">    &gt;&gt; store = header + content</span><br><span class="line">    =&gt; &quot;blob 16\000what is up, doc?&quot;</span><br><span class="line">    &gt;&gt; require &#x27;digest/sha1&#x27;</span><br><span class="line">    =&gt; true</span><br><span class="line">    &gt;&gt; sha1 = Digest::SHA1.hexdigest(store)</span><br><span class="line">    =&gt; &quot;bd9dbf5aae1a3862dd1526723246b20206e5fc37&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Git 用 zlib 对数据内容进行压缩，在 Ruby 中可以用 zlib 库来实现。首先需要导入该库，然后用 Zlib::Deflate.deflate() 对数据进行压缩：</span><br><span class="line">*/</span><br><span class="line">    &gt;&gt; require &#x27;zlib&#x27;</span><br><span class="line">    =&gt; true</span><br><span class="line">    &gt;&gt; zlib_content = Zlib::Deflate.deflate(store)</span><br><span class="line">    =&gt; &quot;x\234K\312\311OR04c(\317H,Q\310,V(-\320QH\311O\266\a\000_\034\a\235&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">最后将用 zlib 压缩后的内容写入磁盘。需要指定保存对象的路径 (SHA-1 值的头两个字符作为子目录名称，剩余 38 个字符作为文件名保存至该子目录中)。在 Ruby 中，如果子目录不存在可以用 FileUtils.mkdir_p() 函数创建它。接着用 File.open 方法打开文件，并用 write() 方法将之前压缩的内容写入该文件：</span><br><span class="line">*/</span><br><span class="line">    &gt;&gt; path = &#x27;.git/objects/&#x27; + sha1[0,2] + &#x27;/&#x27; + sha1[2,38]</span><br><span class="line">    =&gt; &quot;.git/objects/bd/9dbf5aa  e1a3862dd1526723246b20206e5fc37&quot;</span><br><span class="line">    &gt;&gt; require &#x27;fileutils&#x27;</span><br><span class="line">    =&gt; true</span><br><span class="line">    &gt;&gt; FileUtils.mkdir_p(File.dirname(path))</span><br><span class="line">    =&gt; &quot;.git/objects/bd&quot;</span><br><span class="line">    &gt;&gt; File.open(path, &#x27;w&#x27;) &#123; |f| f.write zlib_content &#125;</span><br><span class="line">    =&gt; 32</span><br></pre></td></tr></table></figure><br>这就创建了一个正确的 blob 对象。所有的 Git 对象都以这种方式存储，惟一的区别是类型不同 ── 除了字符串 blob   ，文件头起始内容还可以是 commit 或 tree 。不过虽然 blob 几乎可以是任意内容，commit 和 tree 的数据却是有固定格式的。</p>
<h2 id="Git-References"><a href="#Git-References" class="headerlink" title="Git References"></a>Git References</h2><p>使用 SHA1 作为文件的索引是比较难记的，可以用一个简单的名字来记录这些 SHA-1 值。在 Git 中称为“引用”。可以在 <code>.git/refs</code> 目录下面可以找到这些包含 SHA-1 值的文件。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ find .git/refs</span><br><span class="line">    .git/refs</span><br><span class="line">    .git/refs/heads</span><br><span class="line">    .git/refs/tags</span><br></pre></td></tr></table></figure><br>如果想要创建一个新的引用来记住最后一次提交，可以这样做：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;1a410efbd13591db07496601ebc7a059dd55cfe9&quot; &gt; .git/refs/heads/master</span><br></pre></td></tr></table></figure><br>现在，就可以在 Git 命令中使用刚才创建的引用而不是 SHA-1 值：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline master</span><br><span class="line">    1a410efbd13591db07496601ebc7a059dd55cfe9 third commit</span><br><span class="line">    cac0cab538b970a37ea1e769cbbde608743bc96d second commit</span><br><span class="line">    fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</span><br></pre></td></tr></table></figure><br>基本上 Git 中的一个分支其实就是一个指向某个工作版本一条 HEAD 记录的指针或引用。你可以用这条命令创建一个指向其他提交的分支。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git update-ref refs/heads/test cac0ca</span><br></pre></td></tr></table></figure><br><code>update-ref</code> 命令可以安全的更新一个引用。<br>现在 Git 数据库看起来是这样：<br> <img src="http://git.oschina.net/progit/figures/18333fig0904-tn.png" alt="Git 数据库"><br>每当执行 <code>git branch</code> (分支名称) 这样的命令，Git 基本上就是执行 <code>update-ref</code> 命令，把现在所在分支中最后一次提交的 SHA-1 值，添加到要创建的分支的引用。</p>
<h3 id="HEAD-标记"><a href="#HEAD-标记" class="headerlink" title="HEAD 标记"></a>HEAD 标记</h3><p>HEAD 文件是一个指向你当前所在分支的引用标识符。这样的引用标识符其实并不包含 SHA-1 值，而是一个指向另外一个引用的指针。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat .git/HEAD</span><br><span class="line">    ref: refs/heads/master</span><br></pre></td></tr></table></figure><br>如果执行 <code>git checkout test</code>，HEAD 文件也会改变为 <code>ref: refs/heads/test</code><br>当再次执行 <code>git commit</code> 的时候，会创建了一个 commit 对象，把这个 commit 对象的父级设置为 HEAD 指向的引用的 SHA-1 值。</p>
<p>HEAD 文件安全修改命令： <code>symbolic-ref</code><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git symbolic-ref HEAD refs/heads/test</span><br><span class="line">$ cat .git/HEAD</span><br><span class="line">    ref: refs/heads/test</span><br></pre></td></tr></table></figure></p>
<h3 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h3><p>Tag 对象非常像一个 commit 对象——包含一个标签，一组数据，一个消息和一个指针。最主要的区别就是 <strong>Tag 对象指向一个 commit 而不是一个 tree</strong>。它就像是一个分支引用，但是不会变化——永远指向同一个 commit，仅仅是提供一个更加友好的名字。</p>
<p>可以类似下面这样的命令建立一个 lightweight tag：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</span><br></pre></td></tr></table></figure><br>如果创建一个 annotated tag，Git 会创建一个 tag 对象，然后写入一个指向它而不是直接指向 commit 的 reference。可以这样创建一个 annotated tag（-a 参数表明这是一个 annotated tag）：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m &#x27;test tag&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="Remotes"><a href="#Remotes" class="headerlink" title="Remotes"></a>Remotes</h3><p>第四种 reference 是 <code>remote reference</code>。如果你添加了一个 remote 然后推送代码过去，Git 会把你最后一次推送到这个 remote 的每个分支的值都记录在 refs/remotes 目录下。例如，你可以添加一个叫做 origin 的 remote 然后把你的 master 分支推送上去：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:schacon/simplegit-progit.git</span><br><span class="line">$ git push origin master</span><br><span class="line">    Counting objects: 11, done.</span><br><span class="line">    Compressing objects: 100% (5/5), done.</span><br><span class="line">    Writing objects: 100% (7/7), 716 bytes, done.</span><br><span class="line">    Total 7 (delta 2), reused 4 (delta 1)</span><br><span class="line">    To git@github.com:schacon/simplegit-progit.git</span><br><span class="line">    a11bef0..ca82a6d master -&gt; master</span><br><span class="line"></span><br><span class="line">$ cat .git/refs/remotes/origin/master</span><br><span class="line">    ca82a6dff817ec66f44342007202690a93763949</span><br></pre></td></tr></table></figure><br>Remote 应用和分支主要区别在于他们是不能被 checkout 的。Git 把他们当作是标记这些了这些分支在服务器上最后状态的一种书签。</p>
<h2 id="Packfiles"><a href="#Packfiles" class="headerlink" title="Packfiles"></a>Packfiles</h2><p>Git 往磁盘保存对象时默认使用的格式叫<strong>松散对象</strong> (loose object) 格式。Git 时不时地将这些对象打包至一个叫 <code>packfile</code> 的二进制文件以节省空间并提高效率。当仓库中有太多的松散对象，或是手工调用 <code>git gc</code> 命令，或推送至远程服务器时，Git 都会这样做。手工调用 <code>git gc</code> 命令让 Git 将库中对象打包。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git gc</span><br><span class="line">    Counting objects: 17, done.</span><br><span class="line">    Delta compression using 2 threads.</span><br><span class="line">    Compressing objects: 100% (13/13), done.</span><br><span class="line">    Writing objects: 100% (17/17), done.</span><br><span class="line">    Total 17 (delta 1), reused 10 (delta 0)</span><br><span class="line"></span><br><span class="line">$ find .git/objects -type f</span><br><span class="line">    .git/objects/71/08f7ecb345ee9d0084193f147cdad4d2998293</span><br><span class="line">    .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</span><br><span class="line">    .git/objects/info/packs</span><br><span class="line">    .git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx</span><br><span class="line">    .git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack</span><br></pre></td></tr></table></figure><br>查看一下 objects 目录，会发现大部分对象都不在了，与此同时在 pack 目录下出现了两个新文件。</p>
<p>仍保留着的几个对象是未被任何 commit 引用的 blob，它们没有添加至任何 commit，所以 Git 认为它们是 <strong>“悬空”</strong> 的，不会将它们打包进 packfile 。</p>
<p>剩下的文件是新创建的 <code>packfile</code> 以及一个索引。<code>packfile</code> 文件包含了刚才从文件系统中移除的所有对象。索引文件包含了 <code>packfile</code> 的<strong>偏移</strong>信息，这样就可以快速定位任意一个指定对象。运行 <code>gc</code> 命令前磁盘上的对象大小约为 <strong>12K</strong> ，而这个新生成的 <code>packfile</code> 仅为 <strong>6K</strong> 大小。通过打包对象减少了一半磁盘使用空间。</p>
<p>这是因为，Git 打包对象时，会查找命名及尺寸相近的文件，并只保存文件不同版本之间的差异内容。<code>git verify-pack</code> 命令用于显示已打包的内容。</p>
<h2 id="the-Refspec"><a href="#the-Refspec" class="headerlink" title="the Refspec"></a>the Refspec</h2><p>对于远程仓库连接的建立，在 <code>.git/config</code> 文件中有这样的信息：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:schacon/simplegit-progit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure><br>其中，<code>Refspec</code> 的格式是一个可选的 <strong>+</strong> 号，接着是 <code>&lt;src&gt;:&lt;dst&gt;</code> 的格式，这里 <code>&lt;src&gt;</code> 是<strong>远端</strong>上的引用格式， <code>&lt;dst&gt;</code> 是将要记录在本地的引用格式。可选的 <strong>+</strong> 号告诉 Git 在即使不能快速演进的情况下，也去强制更新它。</p>
<p>缺省情况下 <code>refspec</code> 会被 <code>git remote add</code> 命令所自动生成， Git 会获取远端上 <code>refs/heads/</code> 下面的所有引用，并将它写入到本地的 <code>refs/remotes/origin/</code>。 所以，如果远端上有一个 master 分支，你在本地可以通过下面这种方式来访问它的历史记录：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log origin/master</span><br><span class="line">$ git log remotes/origin/master</span><br><span class="line"> $ git log refs/remotes/origin/master</span><br></pre></td></tr></table></figure><br>它们是等价的，因为 Git 把它们都扩展成 <code>refs/remotes/origin/master</code></p>
<p>如果每次只想拉取远程的master分支，则可以修改：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch = +refs/heads/master:refs/remotes/origin/master</span><br></pre></td></tr></table></figure><br>如果想一次性获取远程的多个分支：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch origin master:refs/remotes/origin/mymaster \</span><br><span class="line">    topic:refs/remotes/origin/topic</span><br></pre></td></tr></table></figure><br>也可以修改配置文件(这里不能用通配符)：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:schacon/simplegit-progit.git</span><br><span class="line">    fetch = +refs/heads/master:refs/remotes/origin/master</span><br><span class="line">    fetch = +refs/heads/experiment:refs/remotes/origin/experiment</span><br></pre></td></tr></table></figure></p>
<h3 id="推送-Refspec"><a href="#推送-Refspec" class="headerlink" title="推送 Refspec"></a>推送 Refspec</h3><p>推送到远程分支，可以这样:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin master:refs/heads/qa/master</span><br></pre></td></tr></table></figure><br>如果想让 Git 每次运行 git push origin 时都这样自动推送，可以在配置文件中添加 push 值：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:schacon/simplegit-progit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">    push = refs/heads/master:refs/heads/qa/master</span><br></pre></td></tr></table></figure></p>
<h3 id="删除引用"><a href="#删除引用" class="headerlink" title="删除引用"></a>删除引用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin :topic</span><br></pre></td></tr></table></figure>
<p>refspec 的格式是 <src>:<dst>, 通过把 <src> 部分留空的方式，这个意思是是把远程的 topic 分支变成空，也就是删除它。</src></dst></src></p>
<h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><p>Git 可以以两种主要的方式跨越两个仓库传输数据：基于HTTP协议之上，和 file://, ssh://, 和 git:// 等智能传输协议。</p>
<h3 id="哑协议"><a href="#哑协议" class="headerlink" title="哑协议"></a>哑协议</h3><p>基于HTTP之上传输通常被称为哑协议，这是因为它在服务端不需要有针对 Git 特有的代码。这个获取过程仅仅是一系列GET请求，客户端可以假定服务端的Git仓库中的布局。</p>
<p>使用 <code>git clone</code> 做的第1件事情就是获取 <code>info/refs</code> 文件。这个文件是在服务端运行了 <code>update-server-info</code> 所生成的，所以服务端要想使用HTTP传输，必须要开启 <code>post-receive</code> 钩子。</p>
<p>整个过程看起来像这样：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone http://github.com/schacon/simplegit-progit.git</span><br><span class="line">    Initialized empty Git repository in /private/tmp/simplegit-progit/.git/</span><br><span class="line">    got ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">    walk ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">    got 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">    Getting alternates list for http://github.com/schacon/simplegit-progit.git</span><br><span class="line">    Getting pack list for http://github.com/schacon/simplegit-progit.git</span><br><span class="line">    Getting index for pack 816a9b2334da9953e530f27bcac22082a9f5b835</span><br><span class="line">    Getting pack 816a9b2334da9953e530f27bcac22082a9f5b835</span><br><span class="line">    which contains cfda3bf379e4f8dba8717dee55aab78aef7f4daf</span><br><span class="line">    walk 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">    walk a11bef06a3f659402fe7563abf99ad00de2209e6</span><br></pre></td></tr></table></figure></p>
<ul>
<li>获取 <code>info/refs</code> 文件，得到一个远程引用和SHA值得列表</li>
<li>寻找HEAD引用，确定什么应该被检出到工作目录</li>
<li>开始获取对象</li>
<li>使用 zlib 解压缩，去除头部，得到 commit 内容</li>
<li>得到进一步需要获取的对象</li>
<li>抓取树对象，分别从<strong>本仓库/替代仓库/打包文件</strong>中查找</li>
<li>在 commit 对象上继续下一步查找</li>
<li>下载全部完成后， 将 master 分支检出工作目录</li>
</ul>
<h3 id="智能协议"><a href="#智能协议" class="headerlink" title="智能协议"></a>智能协议</h3><p>这些协议在远端都有<strong>Git智能型进程</strong>在服务 － 它可以读出本地数据并计算出客户端所需要的，并生成合适的数据给它，这有两类传输数据的进程：一对用于<strong>上传数据</strong>和一对用于<strong>下载</strong>。</p>
<h4 id="上传数据"><a href="#上传数据" class="headerlink" title="上传数据"></a>上传数据</h4><p>当运行 <code>git push origin master</code>, 并且 origin 被定义为一个使用SSH协议的URL时， Git 会使用 <code>send-pack</code> 进程，它会启动一个基于SSH的连接到服务器。它尝试像这样透过SSH在服务端运行命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -x git@github.com &quot;git-receive-pack &#x27;schacon/simplegit-progit.git&#x27;&quot;</span><br><span class="line">    005bca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status delete-refs</span><br><span class="line">    003e085bb3bcb608e1e84b2432f8ecbe6306e7e7 refs/heads/topic</span><br><span class="line">    0000</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>git-receive-pack</code> 命令会立即对它所拥有的每一个引用响应一行。每一行以4字节的十六进制开始，用于指定整行的长度。</p>
</blockquote>
<p>这里第1行以005b开始，这在十六进制中表示91，意味着第1行有91字节长第1行也包含了服务端的能力列表（这里是 report-status 和 delete-refs）。下一行以003e起始，表示有62字节长，所以需要读剩下的62字节。再下一行是0000开始，表示服务器已完成了引用列表过程。</p>
<p>了解了服务器的状态，<code>send-pack</code> 进程会判断哪些 commit 是它所拥有但服务端没有的。针对每个引用，这次推送都会告诉服务端的 <code>receive-pack</code> 这个信息。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0085ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6</span><br><span class="line">    refs/heads/master report-status</span><br><span class="line">    00670000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d refs/heads/experiment</span><br><span class="line">    0000</span><br></pre></td></tr></table></figure><br>这里的全 ‘0’ 的SHA-1值表示之前没有过这个对象 。如果你在删除一个引用，你会看到相反的： 就是右边是全’0’。</p>
<p>Git 针对每个引用发送这样一行信息，就是<strong>旧的SHA值，新的SHA值，和将要更新的引用</strong>的名称。第1行还会包含有客户端的能力。下一步，客户端会发送一个所有那些服务端所没有的对象的一<strong>个打包文件</strong>。最后，服务端以成功(或者失败)来响应：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000Aunpack ok</span><br></pre></td></tr></table></figure></p>
<h4 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h4><p>下载数据时，客户端启动 <code>fetch-pack</code> 进程，连接至远端的 <code>upload-pack</code> 进程，以协商后续数据传输过程。</p>
<p><code>upload-pack</code> 进程的启动可以有多种方式，可以使用与 <code>receive-pack</code> 相同的透过SSH管道的方式，也可以通过 Git 后台来启动这个进程，它默认监听在9418号端口上。这里 <code>fetch-pack</code> 进程在连接后像这样向后台发送数据：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">003fgit-upload-pack schacon/simplegit-progit.git\0host=myserver.com\0</span><br></pre></td></tr></table></figure><br>它也是以<strong>4字节</strong>指定后续字节长度的方式开始，然后是要运行的命令，和一个空字节，然后是服务端的主机名，再跟随一个最后的空字节。 Git 后台进程会检查这个命令是否可以运行，以及那个仓库是否存在，以及是否具有公开权限。如果所有检查都通过了，它会启动这个 <code>upload-pack</code> 进程并将客户端的请求移交给它。</p>
<p>如果透过SSH使用获取功能， <code>fetch-pack</code> 是这样的：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -x git@github.com &quot;git-upload-pack &#x27;schacon/simplegit-progit.git&#x27;&quot;</span><br></pre></td></tr></table></figure><br>在 fetch-pack 连接之后， upload-pack 都会以这种形式返回：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0088ca82a6dff817ec66f44342007202690a93763949 HEAD\0multi_ack thin-pack \</span><br><span class="line">    side-band side-band-64k ofs-delta shallow no-progress include-tag</span><br><span class="line">    003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master</span><br><span class="line">    003e085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 refs/heads/topic</span><br><span class="line">    0000</span><br></pre></td></tr></table></figure><br>这与 <code>receive-pack</code> 响应很类似，但是这里指的能力是不同的。而且它还会<strong>指出HEAD引用</strong>，让客户端可以检查是否是一份克隆。</p>
<p>在这里， <code>fetch-pack</code> 进程检查它自己所拥有的对象和所有它需要的对象，通过发送 “want” 和所需对象的SHA值，发送 “have” 和所有它已拥有的对象的SHA值。在列表完成时，再发送 “done” 通知 upload-pack 进程开始发送所需对象的打包文件。这个过程看起来像这样：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0054want ca82a6dff817ec66f44342007202690a93763949 ofs-delta</span><br><span class="line">    0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">    0000</span><br><span class="line">    0009done</span><br></pre></td></tr></table></figure></p>
<h2 id="维护及数据恢复"><a href="#维护及数据恢复" class="headerlink" title="维护及数据恢复"></a>维护及数据恢复</h2><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>Git 会不定时地自动运行称为 “auto gc” 的命令。大部分情况下该命令什么都不处理。不过要是存在太多松散对象 (loose object, 不在 packfile 中的对象) 或 packfile，Git 会进行调用 <strong>git gc</strong> 命令。 gc 指垃圾收集 (garbage collect)，此命令会做很多工作：收集所有松散对象并将它们存入 packfile，合并这些 packfile 进一个大的 packfile，然后将不被任何 commit 引用并且已存在一段时间 (数月) 的对象删除。</p>
<p>也可以手动运行 auto gc 命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git gc --auto</span><br></pre></td></tr></table></figure><br>gc 还会将所有引用 (references) 并入一个单独文件。假设仓库中包含以下分支和标签：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ find .git/refs -type f</span><br><span class="line">    .git/refs/heads/experiment</span><br><span class="line">    .git/refs/heads/master</span><br><span class="line">    .git/refs/tags/v1.0</span><br><span class="line">    .git/refs/tags/v1.1</span><br></pre></td></tr></table></figure><br>这时如果运行 <code>git gc</code>, <code>refs</code> 下的所有文件都会消失。Git 会将这些文件挪到 <code>.git/packed-refs</code> 文件中去以提高效率，该文件是这个样子的：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat .git/packed-refs</span><br><span class="line">    # pack-refs with: peeled</span><br><span class="line">    cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment</span><br><span class="line">    ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master</span><br><span class="line">    cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0</span><br><span class="line">    9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1</span><br><span class="line">    ^1a410efbd13591db07496601ebc7a059dd55cfe9</span><br></pre></td></tr></table></figure><br>当更新一个引用时，Git 不会修改这个文件，而是在 refs/heads 下写入一个新文件。当查找一个引用的 SHA 时，Git 首先在 refs 目录下查找，如果未找到则到 <code>packed-refs</code> 文件中去查找。</p>
<p>上面文件最后以 <code>^</code> 开头的那一行。这表示该行上一行的那个标签是一个 <code>annotated</code> 标签，而该行正是那个标签所指向的 <code>commit</code> 。</p>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>恢复丢失后的 commit ，通常最快捷的办法是使用 <code>git reflog</code> 工具。当我们在一个仓库下 工作时，Git 会在我们每次修改了 <code>HEAD</code> 时悄悄地将改动记录下来。当提交或修改分支时，reflog 就会更新。<code>git update-ref</code> 命令也可以更新 reflog。运行 <code>git reflog</code> 命令可以查看当前的状态：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">    1a410ef HEAD@&#123;0&#125;: 1a410efbd13591db07496601ebc7a059dd55cfe9: updating HEAD</span><br><span class="line">    ab1afef HEAD@&#123;1&#125;: ab1afef80fac8e34258ff41fc1b867c702daa24b: updating HEAD</span><br></pre></td></tr></table></figure><br>运行 <code>git log -g</code> 会输出 reflog 的正常日志，从而显示更多有用信息。从而找到删除的 commit ，然后新建一个分支指向它。</p>
<p>如果 commit 丢失并没有记录在 reflog 中，还可以使用 <code>git fsck</code> 工具，该工具会检查仓库的数据完整性。如果指定 —ful 选项，该命令显示所有未被其他对象引用 (指向) 的所有对象。</p>
<h3 id="移除对象"><a href="#移除对象" class="headerlink" title="移除对象"></a>移除对象</h3><p>git clone 会将仓库包含的每一个文件的历史版本下载下来，若仓库中有大型文件，这将使得仓库非常大。<br>可以利用 <code>git gc</code> 命令查看文件占用的空间，利用 <code>git count-objects</code> 查看使用多少空间：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git gc</span><br><span class="line">    Counting objects: 21, done.</span><br><span class="line">    Delta compression using 2 threads.</span><br><span class="line">    Compressing objects: 100% (16/16), done.</span><br><span class="line">    Writing objects: 100% (21/21), done.</span><br><span class="line">    Total 21 (delta 3), reused 15 (delta 1)```</span><br><span class="line"></span><br><span class="line">$ git count-objects -v</span><br><span class="line">    count: 4</span><br><span class="line">    size: 16</span><br><span class="line">    in-pack: 21</span><br><span class="line">    packs: 1</span><br><span class="line">    size-pack: 2016</span><br><span class="line">    prune-packable: 0</span><br><span class="line">    garbage: 0</span><br></pre></td></tr></table></figure><br>使用 <code>git verfity-pack</code> 识别大对象，对输出的第三列信息即文件大小进行排序，还可以将输出定向到 tail 命令。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git verify-pack -v .git/objects/pack/pack-3f8c0...bb.idx | sort -k 3 -n | tail -3</span><br><span class="line">    e3f094f522629ae358806b17daf78246c27c007b blob 1486 734 4667</span><br><span class="line">    05408d195263d853f09dca71d55116663690c27c blob 12908 3478 1189</span><br><span class="line">    7a9eb2fba2b1811321254ac360970fc169ba2330 blob 2056716 2056872 5401</span><br></pre></td></tr></table></figure><br>比如要删除最底下那个大文件，可以运行 <code>rev-list</code>命令。若在此传入 <code>--objects</code>选项，它会列出所有 commit SHA 值，blob SHA 值及相应的文件路径。可以这样查看 blob 的文件名：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rev-list --objects --all | grep 7a9eb2fb</span><br><span class="line">    7a9eb2fba2b1811321254ac360970fc169ba2330 git.tbz2</span><br></pre></td></tr></table></figure><br>接下来要将该文件从历史记录的所有 tree 中移除:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline --branches -- git.tbz2</span><br><span class="line">    da3f30d019005479c99eb4c3406225613985a1db oops - removed large tarball</span><br><span class="line">    6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 added git tarball</span><br></pre></td></tr></table></figure><br>必须重写从 6df76 开始的所有 commit 才能将文件从 Git 历史中完全移除。需要用到 <code>filter-branch</code> 命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git filter-branch --index-filter \</span><br><span class="line">    &#x27;git rm --cached --ignore-unmatch git.tbz2&#x27; -- 6df7640^..</span><br><span class="line">    Rewrite 6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 (1/2)rm &#x27;git.tbz2&#x27;</span><br><span class="line">    Rewrite da3f30d019005479c99eb4c3406225613985a1db (2/2)</span><br><span class="line">    Ref &#x27;refs/heads/master&#x27; was rewritten</span><br></pre></td></tr></table></figure><br><code>--index-filter</code> 传入一个命令修改暂存区域或索引。使用 <code>git rm --cached</code> 来从索引而不是磁盘删除文件，这样能提高速度，也可以使用 <code>--tree-filter</code> 达到相同的目的。<br>在这之后， <code>.git/refs/original</code> 添加的一些 refs 中仍有对它的引用，因此需要将这些引用删除并对仓库进行 repack 操作。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rm -Rf .git/refs/original</span><br><span class="line">$ rm -Rf .git/logs/</span><br><span class="line">$ git gc</span><br></pre></td></tr></table></figure><br>在此看看空间占用：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git count-objects -v</span><br><span class="line">    count: 8</span><br><span class="line">    size: 2040</span><br><span class="line">    in-pack: 19</span><br><span class="line">    packs: 1</span><br><span class="line">    size-pack: 7</span><br><span class="line">    prune-packable: 0</span><br><span class="line">    garbage: 0</span><br></pre></td></tr></table></figure><br>repack 后仓库的大小减小到了 7K ，远小于之前的 2MB 。从 size 值可以看出大文件对象还在松散对象中，其实并没有消失，不过再进行推送或复制，这个对象不会再传送出去。如果真的要完全把这个对象删除，可以运行 <code>git prune --expire</code> 命令。</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 面向对象（一）</title>
    <url>/Blog/2016/07/11/java-OOP-1/</url>
    <content><![CDATA[<h2 id="类与对象基础"><a href="#类与对象基础" class="headerlink" title="类与对象基础"></a>类与对象基础</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><strong>定义语法：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">    属性 (变量) ; 行为 (方法) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>类实例化：</strong><br>格式一：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名称 对象名称 = <span class="keyword">new</span> 类名称();</span><br></pre></td></tr></table></figure><br>格式二：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明对象</span></span><br><span class="line">类名称 对象名称 = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line">对象名称 = <span class="keyword">new</span> 类名称 ();</span><br></pre></td></tr></table></figure><br><span id="more"></span><br><strong>两种实例化方法的区别：</strong></p>
<blockquote>
<p><code>new</code> 关键字表示开辟了新的堆内存。<br><code>Person per = null</code>，这个时候只声明了Person对象，但是并没有实例化Person对象（只有了栈内存，并没有对应的堆内存空间）。程序在编译的时候不会出现任何的错误，但是在执行的时候会出现<code>NullPointerException</code>（空指向异常）。</p>
</blockquote>
<p><strong>堆内存</strong>：保存对象的真正数据，都是每一个对象的属性内容。<br><strong>栈内存</strong>：保存的是一块堆内存的空间地址。</p>
<p><strong>引用传递的精髓</strong>：同一块堆内存空间，同时被多个栈内存所指向，不同的栈可以修改同一块堆内存的内容。</p>
<p><strong>垃圾</strong>：指的是在程序开发之中没有任何对象所指向的一块<strong>堆内存空间</strong>，这块空间就成为垃圾，所有的垃圾将等待GC（垃圾收集器）不定期的进行回收与空间的释放。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>public、private、protect。</p>
<p>要保证属性的安全，又要有利于外部操作，需要定义<code>setter</code>与<code>getter</code>方法。<br>在定义类的时候，所有的属性都要编写private封装，封装之后的属性如果需要被外部操作，则编写setter、getter。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法本身的定义如下： </p>
<ul>
<li>构造方法的名称和类名称保持一致； </li>
<li>构造方法不允许有返回值类型声明；</li>
<li>由于对象实例化操作一定需要构造方法的存在，所以如果在类之中没有明确定义构造方法的话，则会自动的生成一个无参的，无返回值的构造方法，供用户使用，如果一个类之中已经明确的定义了一个构造方法的话，则无参的什么都不做的构造方法将不会自动生成，也就是说，一个类之中至少存在一个构造方法。</li>
<li>构造方法在对象实例化的时候完成操作，而且一个对象的构造方法只会显式调用一次。</li>
</ul>
<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>没名字的对象称为匿名对象，对象的名字按照之前的内存关系来讲，在栈内存之中，而对象的具体内容在堆内存之中保存，这样一来，<strong>没有栈内存指向堆内存空间，就是一个匿名对象</strong>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n,<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        name = n ;</span><br><span class="line">        age = a ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;，年龄：&quot;</span> + age) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>).tell() ; <span class="comment">// 匿名对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>匿名对象由于没有对应的栈内存指向，所以只能使用一次，一次之后就将成为垃圾，并且等待被GC回收释放。</p>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>数组的静态初始化</strong><br>格式一：简写格式<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 数组名称 [] = &#123;值,值,...&#125; ;</span><br><span class="line">数据类型 [] 数组名称= &#123;值,值,...&#125; ;</span><br></pre></td></tr></table></figure><br>格式二：完整格式（推荐使用）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 数组名称 [] = <span class="keyword">new</span> 数据类型 [] &#123;值,值,...&#125; ;</span><br><span class="line">数据类型 [] 数组名称 = <span class="keyword">new</span> 数据类型 [] &#123;值,值,...&#125; ;</span><br><span class="line"><span class="keyword">int</span> data [] = <span class="keyword">new</span> <span class="keyword">int</span> [] &#123;<span class="number">209</span>,<span class="number">201</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125; ;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在开发之中使用何种数组初始化的方式并没有一个明确的定义，主要还是看功能，如果已经知道了所有的操作数据，那么使用静态合适，如果有一些数据需要单独配置，那么用动态合适。</p>
</blockquote>
<p><strong>与数组有关的操作方法</strong><br>1、<strong>数组排序</strong>： <code>java.util.Arrays.sort(数组名称)</code></p>
<blockquote>
<p>使用java.util.Arrays.sort()也可以排序。</p>
</blockquote>
<p>2、<strong>数组拷贝</strong>： 从一个数组之中拷贝部分内容到另外一个数组之中<br>方法：<code>System.arraycopy(源数组名称，源数组开始点，目标数组名称，目标数组开始点，拷贝长度)</code> ;</p>
<p><strong>二维数组</strong><br>动态初始化：</p>
<blockquote>
<p>数据类型 数组名称 [][] = new 数组名称 [行数] [列数] ;</p>
</blockquote>
<p>静态初始化</p>
<blockquote>
<p>数据类型 数组名称 [][] = new 数组名称 [] [] { {值,值,…},{值,值,…},{值,值,…},…} ;</p>
</blockquote>
<h2 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h2><p><strong>String类的构造</strong>：public String(String str)；</p>
<p><strong>字符串比较</strong><br><code>==</code>：比较的是两个字符串内存地址的数值是否相等，属于数值比较；  <code>equals()</code>：比较的是两个字符串的内容，属于内容比较。</p>
<p><strong>字符串常量是String的匿名对象</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;Hello&quot;</span> ;</span><br><span class="line">        <span class="comment">// 通过字符串调用方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>.equals(str)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>匿名对象可以调用类之中的方法与属性，以上的字符串可以调用了<code>equals()</code>方法，那么一定是一个对象。</p>
<h3 id="String类的两种实例化方式"><a href="#String类的两种实例化方式" class="headerlink" title="String类的两种实例化方式"></a>String类的两种实例化方式</h3><p>1、分析直接赋值的情况：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;Hello&quot;</span> ;</span><br><span class="line">        String str2 = <span class="string">&quot;Hello&quot;</span> ;</span><br><span class="line">        String str3 = <span class="string">&quot;Hello&quot;</span> ;</span><br><span class="line">        System.out.println(str1 == str2) ; <span class="comment">// true</span></span><br><span class="line">        System.out.println(str1 == str3) ; <span class="comment">// true</span></span><br><span class="line">        System.out.println(str2 == str3) ; <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>直接赋值操作之中，字符串比较都是相同的，原因是：</p>
<blockquote>
<p>在 String 类进行设计的时候采用了一种称为<strong>共享设计模式</strong>的概念，在每一个运行的 JVM 底层存在一个字符串的<strong>对象池</strong>（Object Pool），如果用户采用了直接赋值的方式，会将字符串的内容放入到池之中，以供其他继续使用直接赋值方式的 String 对象使用，如果新声明的字符串内容不再池之中，则会开辟一个新的，继续放到池，以供下次使用。</p>
</blockquote>
<p>2、分析构造方法赋值的情况：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>) ;</span><br><span class="line">        System.out.println(str) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="http://static.zybuluo.com/guoxs/txoxnpweak0408f07jppydr3/1.png" alt="构造方法赋值"></p>
<p>使用构造方法的方式开辟的字符串对象，实际上会开辟两块空间，其中有一块空间将称为垃圾。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>) ;</span><br><span class="line">        String str2 = <span class="string">&quot;Hello&quot;</span> ; <span class="comment">// 入池</span></span><br><span class="line">        String str3 = <span class="string">&quot;Hello&quot;</span> ; <span class="comment">// 使用池对象</span></span><br><span class="line">        System.out.println(str1 == str2) ; <span class="comment">// false</span></span><br><span class="line">        System.out.println(str1 == str3) ; <span class="comment">// false</span></span><br><span class="line">        System.out.println(str2 == str3) ; <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>，使用构造方法实例化的String对象，不会入池，所以，只能自己使用。可是在String类之中为了方便操作提供了一种称为手工入池的方法：<code>public String intern()</code>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>).intern() ;</span><br><span class="line">        String str2 = <span class="string">&quot;Hello&quot;</span> ; <span class="comment">// 入池</span></span><br><span class="line">        String str3 = <span class="string">&quot;Hello&quot;</span> ; <span class="comment">// 使用池对象</span></span><br><span class="line">        System.out.println(str1 == str2) ; <span class="comment">// true</span></span><br><span class="line">        System.out.println(str1 == str3) ; <span class="comment">// true</span></span><br><span class="line">        System.out.println(str2 == str3) ; <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>字符串的内容一旦声明则不可改变</strong></p>
<blockquote>
<p>字符串内容的更改，实际上改变的是字符串对象的引用过程，并且会伴随有大量的垃圾出现</p>
</blockquote>
<h3 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h3><h4 id="字符串与字符"><a href="#字符串与字符" class="headerlink" title="字符串与字符"></a>字符串与字符</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public String(char[] value)</td>
<td style="text-align:center">构造</td>
<td style="text-align:center">将全部的字符数组内容变为字符串</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public String(char[] value, int offset, int count)</td>
<td style="text-align:center">构造</td>
<td style="text-align:center">将部分字符数组变为字符串，offset表示开始点，count表示要操作的长度</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">public char charAt(int index)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得指定索引位置上的字符</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">public char[] toCharArray()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">将字符串转换为字符数组</td>
</tr>
</tbody>
</table>
</div>
<h4 id="字符串与字节"><a href="#字符串与字节" class="headerlink" title="字符串与字节"></a>字符串与字节</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public String(byte[] bytes)</td>
<td style="text-align:center">构造</td>
<td style="text-align:center">将全部的字节数组变为字符串</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public String(byte[] bytes, int offset, int length)</td>
<td style="text-align:center">构造</td>
<td style="text-align:center">将部分的字节数组变为字符串</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">public byte[] getBytes()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">将字符串变为字节数组</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">public byte[] getBytes(String charsetName) throws UnsupportedEncodingException</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">字符串转码操作</td>
</tr>
</tbody>
</table>
</div>
<p>一般情况下，在程序之中如果要想操作字节数组只有两种情况：</p>
<ul>
<li>需要进行编码的转换时</li>
<li>情况二：数据要进行传输的时候</li>
</ul>
<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public boolean equals(String anObject)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">区分大小写的相等判断</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public boolean equalsIgnoreCase(String anotherString)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">不区分大小写比较是否相等</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">public int compareTo(String anotherString)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">比较两个字符串的大小</td>
</tr>
</tbody>
</table>
</div>
<p>要想比较两个字符串的大小关系，必须使用compareTo()方法完成，这个方法返回int型数据，而这个int型数据有三种结果：<strong>大于（返回结果大于0）、小于（返回结果小于0）、等于（返回结果为0）</strong>。</p>
<h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public boolean contains(String s)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">查找指定的子字符串是否存在，JDK 1.5之后有</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public int indexOf(String str)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">从头查找指定字符串的位置，找不到返回-1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">public int indexOf(String str, int fromIndex)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">由指定位置向后查找字符串的位置，找不到返回-1</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">public int lastIndexOf(String str)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">由后向前查找字符串的位置，找不到返回-1</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">public int lastIndexOf(String str, int fromIndex)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">从指定位置由后向前查找</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">public boolean startsWith(String prefix)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">判断是否以指定的字符串开头</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">public boolean startsWith(String prefix, int toffset)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">从指定位置判断是否以指定字符串开头，JDK 1.7</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">public boolean endsWith(String suffix)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">判断是否以指定的字符串结尾</td>
</tr>
</tbody>
</table>
</div>
<h4 id="字符串替换、截取与拆分"><a href="#字符串替换、截取与拆分" class="headerlink" title="字符串替换、截取与拆分"></a>字符串替换、截取与拆分</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public String replaceAll(String regex, String replacement)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">全部替换</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public String replaceFirst(String regex, String replacement)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">替换首个</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">public String substring(int beginIndex)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">从指定位置截取到结尾</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">public String substring(int beginIndex, int endIndex)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">截取指定范围的内容</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">public String[] split(String regex)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">按照指定的字符串全拆分</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">public String[] split(String regex, int limit)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">拆分为指定的长度</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>在进行字符串拆分的时候，如果遇见拆不开的问题，可以试试 <code>\\</code></p>
</blockquote>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">public boolean isEmpty()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">判断是否为空字符串（””）</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">public int length()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得字符串长度</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">public String trim()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">去掉左右空格</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">public String toLowerCase()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">将全部字符串转小写</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">public String toUpperCase()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">将全部字符串转大写</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">public String intern()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">入池</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">public String concat(String str)</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">字符串连接</td>
</tr>
</tbody>
</table>
</div>
<p>编写一个让首字母大写的 initcap() 方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">initcap</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> s.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase().concat(s.substring(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p>在Java中this可以完成三件事情：表示<strong>本类属性</strong>、表示<strong>本类方法</strong>、<strong>当前对象</strong>。</p>
<p><strong>this.属性</strong>表示本类属性</p>
<p><strong>调用本类方法</strong><br>对于一个类之中的方法现在是分为两种： </p>
<ul>
<li>普通方法：在之前强调过，如果现在要调用的是本类方法，则可以使用 <code>this.方法()</code> 调用； </li>
<li>构造方法：调用其他构造使用 <code>this()</code> 调用。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：在使用 this 调用构造方法的时候有以下一些问题： 1、所以的构造方法是在对象实例化的时候被默认调用，而且是在调用普通方法之前调用，所以使用 <code>this()</code> 调用构造方法的操作，<strong>一定要放在构造方法的首行</strong>；</p>
<p>2、如果一个类之中存在了多个构造方法的话，并且这些构造方法都使用了 <code>this()</code> 互相调用，那么至少要保留一个构造方法没有调用其他构造，以作为程序的出口。</p>
</blockquote>
<p><strong>this表示当前对象，</strong>当前对象指的是当前正在调用本类方法的操作对象</p>
<h2 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h2><p>对象比较的操作一定是一个类自己本身所具备的功能，而且对象比较的操作特点：</p>
<ul>
<li>本类接收自己的引用，而后与本类当前对象（this）进行比较；</li>
<li>首先为了避免NullPointerException的产生，应该增加一个null的判断；</li>
<li>为了防止浪费性能的情况出现（要判断的属性会多），可以增加地址数值的判断，因为相同的对象地址相同；</li>
<li>之后进行属性的依次比较，如果属性全部相同，则返回true，否则返回false。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Person per)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (per == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 直接返回false </span></span><br><span class="line">    &#125;<span class="keyword">if</span> (<span class="keyword">this</span> == per) &#123; <span class="comment">// 地址相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="comment">// 这样一来在compare()方法之中有两个对象：传入的Person，另外一个是this </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.name.equals(per.name) &amp;&amp; <span class="keyword">this</span>.age == per.age) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 面向对象（二）</title>
    <url>/Blog/2016/07/11/java-OOP-2/</url>
    <content><![CDATA[<h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><p>static 关键字表示公共的概念：</p>
<ul>
<li>使用 static 定义的属性不在堆内存之中保存，保存在全局数据区； </li>
<li>使用 static 定义的属性表示类属性，类属性可以由类名称直接进行调用；</li>
<li>static 属性虽然定义在类之中，但是其可以在没有实例化对象的时候进行调用（普通属性保存在堆内存里，而 static 属性保存在<strong>全局数据区</strong>之中）；<span id="more"></span>
<h3 id="使用static定义方法"><a href="#使用static定义方法" class="headerlink" title="使用static定义方法"></a>使用static定义方法</h3>使用 static 定义的方法也可以在没有实例化对象产生的情况下由类名称直接进行调用。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCountry</span><span class="params">(String c)</span> </span>&#123;</span><br><span class="line">    country = c ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
方法调用：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person.setCountry(<span class="string">&quot;燕京&quot;</span>) ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>static 定义的方法<strong>不能</strong>调用非static的方法或属性；而非 static 定义的方法可以调用 static 的属性或方法。<br>这是因为使用 static 定义的属性和方法，可以在没有实例化对象的时候使用；而非 static 定义的属性和方法，<strong>必须实例化对象之后才可以进行调用</strong>。</p>
</blockquote>
</li>
</ul>
<h3 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h3><p>如果一个方法在主类之中定义，并且由主方法直接调用的时候，那么前面必须有<strong>public static</strong>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称 (参数列表) &#123;</span><br><span class="line">    [<span class="keyword">return</span> [返回值] ;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        print() ; <span class="comment">// 直接调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World .&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不用 static 修饰的调用方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TestDemo().print() ; <span class="comment">// 对象调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="comment">// 非static方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World .&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="static关键字的使用"><a href="#static关键字的使用" class="headerlink" title="static关键字的使用"></a>static关键字的使用</h3><p>在实际的工作之中，使用static的原因有二：</p>
<ul>
<li>希望可以在没有实例化对象的时候可以轻松的执行类的某些操作；</li>
<li>现在希望表示出数据共享的概念。</li>
</ul>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块是在程序之中使用 “{}” 定义起来的一段程序，而根据代码块声明位置以及声明关键字的不同，代码块一共分为四种：<strong>普通代码块、构造块、静态块、同步块</strong>。</p>
<h3 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h3><p>普通代码块是定义在方法之中的代码块。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    &#123; <span class="comment">// 普通代码块</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span> ; <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">100</span> ; <span class="comment">// 全局变量</span></span><br><span class="line">    System.out.println(<span class="string">&quot;x = &quot;</span> + x) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>几乎用不上。</p>
<h3 id="构造块"><a href="#构造块" class="headerlink" title="构造块"></a>构造块</h3><p>普通代码块是定义在方法之中的，而构造块是定义在类之中的代码块。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; <span class="comment">// 构造块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造块。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person() ; <span class="keyword">new</span> Person() ; <span class="keyword">new</span> Person() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>构造块优先于构造方法执行</strong>，而且每当有一个新的实例化对象产生的时候，就会出现构造块的执行。</p>
<h3 id="静态块"><a href="#静态块" class="headerlink" title="静态块"></a>静态块</h3><p>静态块也是定义在类之中的，如果一个构造块上使用了static关键字进行定义的话，那么就表示静态块，但是静态块要考虑两种情况：</p>
<p>情况一：在非主类之中定义的静态块<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;构造方法。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; <span class="comment">// 构造块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造块。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态块。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person() ; <span class="keyword">new</span> Person() ; <span class="keyword">new</span> Person() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>静态块优先于构造块执行，而且不管有多少个实例化对象产生，静态块只调用一次。</strong></p>
<p>情况二：在主类中定义的静态块<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态块。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World .&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>在主类之中的静态块优先于主方法执行。</strong></p>
<h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><p>java 同步块（synchronized block）用来标记方法或者代码块是同步的。Java同步块用来<strong>避免竞争</strong>。</p>
<p>Java中的同步块用 <strong>synchronized</strong> 标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。</p>
<p><strong>实例方法同步</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count += value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>Java实例方法同步是同步在<strong>拥有该方法的对象</strong>上。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。</p>
<p><strong>静态方法同步</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">     count += value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>静态方法的同步是指<strong>同步在该方法所在的类对象上</strong>。因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。<br>对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。</p>
<p><strong>实例方法中的同步块</strong><br>有时不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">       <span class="keyword">this</span>.count += value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为<strong>调用add方法的实例本身</strong>。在同步构造器中用括号括起来的对象叫做<strong>监视器对象</strong>。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。</p>
<p><strong>静态方法中的同步块</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">log1</span><span class="params">(String msg1, String msg2)</span></span>&#123;</span><br><span class="line">       log.writeln(msg1);</span><br><span class="line">       log.writeln(msg2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log2</span><span class="params">(String msg1, String msg2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(MyClass.class)&#123;</span><br><span class="line">          log.writeln(msg1);</span><br><span class="line">          log.writeln(msg2);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>这两个方法不允许同时被线程访问。<br>如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类指的是在一个类的内部定义了其他类的情况<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123; <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> String msg = <span class="string">&quot;Hello World &quot;</span> ; <span class="comment">// 普通属性</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">// 内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(msg) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner() ;</span><br><span class="line">        in.print() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer() ;</span><br><span class="line">        out.fun() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>内部类属于在一个类内部定义的新的结构，不过按照类的基本组成来讲，一个类之中应该由属性和方法所组成，但是这个时候又多了一个类，这样的结构并不好，所以<strong>内部类本身最大的缺点破坏了程序的结构</strong>。但是内部类本身也有自己的优点，而这个优点如果要想发现，最好的做法是<strong>将内部类拿到外面来</strong>，变为两个类。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123; <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> String msg = <span class="string">&quot;Hello World &quot;</span> ; <span class="comment">// 普通属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner(<span class="keyword">this</span>) ;</span><br><span class="line">        in.print() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.msg ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">private</span> Outer out = <span class="keyword">null</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">(Outer out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.out = out ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.out.getMsg()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer() ;</span><br><span class="line">        out.fun() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>内部类的最大优点<strong>：可以方便的访问外部类的私有操作，或者是由外部类方便的访问内部类的私有操作。</strong></p>
<p>但有一个问题，只要是访问类中的属性前面都要有 <code>this.</code>，但是在内部类使用<code>this</code>表示的只是<strong>内部类的当前对象</strong>，如果要想表示出外部类的当前对象，使用<code>外部类.this</code>来表示。</p>
<h3 id="在不同的类操作内部类"><a href="#在不同的类操作内部类" class="headerlink" title="在不同的类操作内部类"></a>在不同的类操作内部类</h3><p>一般内部类的<code>*.class</code> 文件名称为 <code>Outer$Inner.class</code>，作为Java的标识符，<script type="math/tex">`也是一个标识符的组成元素，但是对于这样的元素，一直从未使用过，而`</script>是在文件中的表示，但是换到了程序之中，每一个<code>$</code>表示一个 “.”，即：如果换到了程序里面，内部类的类名称就是：<code>Outer.Inner</code>。</p>
<p>所以在外部实例化内部类对象的操作格式：</p>
<blockquote>
<p>外部类.内部类内部类对象 = new 外部类().new 内部类() ; </p>
</blockquote>
<p>之所以实例化外部类对象，主要是因为内部类需要访问外部类之中的普通属性，那么普通属性只有在对象实例化之后才会被实例化（可以使用）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123; <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> String msg = <span class="string">&quot;Hello World &quot;</span> ; <span class="comment">// 普通属性</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">// 内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.msg) ;<span class="comment">// 内部类访问外部类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span> </span>; <span class="comment">// 这种格式几乎不会出现</span></span><br><span class="line">        in.print() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果内部类不希望被外面看见,可以这样：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Outer &#123; // 外部类</span><br><span class="line">    private String msg = &quot;Hello World &quot; ; // 普通属性</span><br><span class="line">    private class Inner &#123; // 内部类</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(Outer.this.msg) ;// 内部类访问外部类</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用static定义内部类"><a href="#使用static定义内部类" class="headerlink" title="使用static定义内部类"></a>使用static定义内部类</h3><p>使用 static 定义的属性和方法，是<strong>独立于类之外</strong>的，可以在没有实例化对象的时候调用，而 static 也同样可以进行内部类的定义，而使用了 static 定义的内部类，则就表示为“<strong>外部类</strong>”，并且<strong>只能访问外部类之中 static 类型的操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123; <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String msg = <span class="string">&quot;Hello World &quot;</span> ; <span class="comment">// 普通属性</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">// 内部类= ”外部类“</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Outer.msg) ;<span class="comment">// 内部类访问外部类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Outer.Inner() ;</span><br><span class="line">        in.print() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在方法中定义内部类"><a href="#在方法中定义内部类" class="headerlink" title="在方法中定义内部类"></a>在方法中定义内部类</h3><p>内部类理论上可以在类的任意位置上进行定义，这就包括代码块之中，或者是普通方法之中。在普通方法里面定义内部类的情况是最多的。</p>
<p>但是一个内部类如果要定义在方法之中，并且要访问方法的参数或者是方法中定义变量的时候，这些参数或变量前一定要增加一个“<strong>final</strong>”关键字。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123; <span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> String msg = <span class="string">&quot;Hello World &quot;</span> ; <span class="comment">// 普通属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 参数</span></span><br><span class="line">        <span class="keyword">final</span> String info = <span class="string">&quot;Hello MLDN&quot;</span> ; <span class="comment">// 变量</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">// 方法中定义的内部类</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Outer.<span class="keyword">this</span>.msg) ;</span><br><span class="line">                System.out.println(x) ;</span><br><span class="line">                System.out.println(info) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner() ; <span class="comment">// 产生内部类对象</span></span><br><span class="line">        in.print() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Outer().fun(<span class="number">30</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 面向对象（三）</title>
    <url>/Blog/2016/07/31/java-OOP-3/</url>
    <content><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>语法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>子类又被称为<strong>派生类</strong>，父类又被称为<strong>超类</strong>（Super Class）。</p>
<p><strong>继承的限制</strong></p>
<ul>
<li>一个子类只能够继承一个父类，存在单继承局限（Java之中只允许多层继承，不允许多重继承）</li>
<li>在一个子类继承的时候，实际上会继承父类之中的<strong>所有操作</strong>（属性、方法），但是，对于所有的非私有（no private）操作属于显式继承（可以直接利用对象操作），而所有的私有操作属于隐式继承（间接完成）。</li>
<li>在继承关系之中，如果要实例化子类对象，会默认先调用父类构造，为父类之中的属性初始化，之后再调用子类构造，为子类之中的属性初始化（默认情况下，子类会找到父类之中的<strong>无参构造方法</strong>）。<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        B b = <span class="keyword">new</span> B() ; <span class="comment">// 实例化子类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面代码实例化的是子类对象，但是会默认先执行父类构造，调用父类构造的方法体执行，而后再实例化子类对象，调用子类的构造方法。对于子类的构造而言，就相当于隐含了一个 <code>super()</code> 的形式。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123; <span class="comment">// 子类构造</span></span><br><span class="line">        <span class="keyword">super</span>() ; <span class="comment">// 调用父类构造</span></span><br><span class="line">        System.out.println(<span class="string">&quot;#########################&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
默认调用无参构造，如果父类没有无参构造，则子类必须通过 <code>super</code> 调用指定参数构造器。</li>
</ul>
<p><strong>super调用父类构造的时候，一定要放在构造方法的首行上。</strong></p>
<blockquote>
<p>如果一个类之中有多个构造方法之间使用this()互相调用的话，那么至少要保留有一个构造方法作为出口，而这个出口就一定会去调用父类构造。一个简单Java类一定要保留有一个无参构造方法。</p>
</blockquote>
<h2 id="覆写"><a href="#覆写" class="headerlink" title="覆写"></a>覆写</h2><p>当子类定义了和父类在<strong>方法名称</strong>、<strong>返回值类型</strong>、<strong>参数类型</strong>及<strong>个数</strong>完全相同的方法的时候，称为方法的覆写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World .&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="comment">// 方法名称、参数类型及个数、返回值全相同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;世界，你好！&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        B b = <span class="keyword">new</span> B() ;</span><br><span class="line">        b.print() ; <span class="comment">// 方法从父类继承而来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当一个类之中的方法被覆写之后，如果实例化的是这个子类对象，则调用的方法就是被覆写过的方法。</p>
</blockquote>
<p><strong>注意：</strong>被子类所覆写的方法不能拥有比父类更严格的访问控制权限，如果此时父类之中的方法是 default 权限，那么子类覆写的时候只能是 default 或 public 权限，而如果父类的方法是 public，那么子类之中方法的访问权限只能是 public。</p>
<p>当一个子类覆写了一个父类方法的时候，那么在这种情况下，子类要想调用父类的被覆写过的方法，则在方法前要加 上“<strong>super</strong>”。</p>
<p>this 与 super 区别：</p>
<ul>
<li><strong>this.方法()</strong>：先从本类查找是否存在指定的方法，如果没有找到，则调用父类操作； </li>
<li><strong>super.方法()</strong>：直接由子类调用父类之中的指定方法，不再找子类。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">区别</th>
<th style="text-align:center">this</th>
<th style="text-align:center">super</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">定义</td>
<td style="text-align:center">表示本类对象</td>
<td style="text-align:center">表示父类对象</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">使用</td>
<td style="text-align:center">本类操作：this.属性、this.方法()、this()</td>
<td style="text-align:center">父类操作：super.属性、super.方法()、super(）</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">调用构造</td>
<td style="text-align:center">调用本类构造，要放在首行</td>
<td style="text-align:center">子类调用父类构造，放在首行</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">查找范围</td>
<td style="text-align:center">先从本类查找，找不到查找父类</td>
<td style="text-align:center">直接由子类查找父类</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">特殊</td>
<td style="text-align:center">表示当前对象</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<p>重载与覆写的区别：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">区别</th>
<th style="text-align:center">重载</th>
<th style="text-align:center">覆写</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">英文单词</td>
<td style="text-align:center">Overloading</td>
<td style="text-align:center">Override</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">定义</td>
<td style="text-align:center">方法名称相同、参数的类型及个数不同</td>
<td style="text-align:center">方法名称、参数类型及个数、返回值类型完全相同</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">权限</td>
<td style="text-align:center">没有权限要求</td>
<td style="text-align:center">被子类所覆写的方法不能拥有比父类更严格的访问控制权限</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">范围</td>
<td style="text-align:center">发生在一个类之中</td>
<td style="text-align:center">发生在继承关系类之中</td>
</tr>
</tbody>
</table>
</div>
<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p>在Java中，final关键字表示的是一个<strong>终结器</strong>的概念，使用 final可以定义类、方法、变量。</p>
<ul>
<li>使用final定义的类不能有子类，太监类</li>
<li>使用final定义的方法不能被子类所覆写</li>
<li>如果说使用了public static来定义的常量，那么这个常量就称为全局常量。<blockquote>
<p>public static final String INFO = “hello world” ; // 全局常量</p>
</blockquote>
</li>
</ul>
<p><strong>定义final常量的时候每个单词的字母都要大写。</strong></p>
<h2 id="构造方法私有化"><a href="#构造方法私有化" class="headerlink" title="构造方法私有化"></a>构造方法私有化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; <span class="comment">// 定义一个类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World .&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用private访问权限定义的操作只能被本类所访问，外部无法调用。</p>
<p>对于一个类之中的普通属性，默认情况下一定要在本类存在了实例化对象之后才可以进行调用，如果使用构造方法私有化，外部就无法产生实例化对象，也就不能调用方法。这是可以使用 <strong>static</strong> 关键字，static定义的属性特点：<strong>由类名称直接调用，并且在没有实例化对象的时候也可以调用。</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; <span class="comment">// 定义一个类</span></span><br><span class="line">    <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton() ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World .&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Singleton inst = <span class="keyword">null</span> ; <span class="comment">// 声明对象</span></span><br><span class="line">        inst = Singleton.instance ; <span class="comment">// 实例化对象</span></span><br><span class="line">        inst.print() ; <span class="comment">// 调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>类之中的全部属性都应该封装，所以以上的instance属性应该进行封装，而封装之后要想取得属性要编写getter方法，只不过这个时候的getter方法应该也由类名称直接调用，定义为static型。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; <span class="comment">// 定义一个类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton() ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World .&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Singleton inst = <span class="keyword">null</span> ; <span class="comment">// 声明对象</span></span><br><span class="line">        inst = Singleton.getInstance() ; <span class="comment">// 实例化对象</span></span><br><span class="line">        inst.print() ; <span class="comment">// 调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果说现在一个类只希望有唯一的一个实例化对象出现，应该控制构造方法，如果构造方法对外部不可见了，那么现在肯定无法执行对象的实例化操作，必须将构造方法隐藏，使用<strong>private</strong>隐藏。</p>
</blockquote>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>但是，以上代码还有问题，比如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    instance = <span class="keyword">new</span> Singleton() ;</span><br><span class="line">    <span class="keyword">return</span> instance ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样就打破了一个类只实例化一个对象的设定。可以通过添加 final 关键字弥补：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; <span class="comment">// 定义一个类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton() ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World .&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Singleton inst = <span class="keyword">null</span> ; <span class="comment">// 声明对象</span></span><br><span class="line">        inst = Singleton.getInstance() ; <span class="comment">// 实例化对象</span></span><br><span class="line">        inst.print() ; <span class="comment">// 调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样的设计在设计模式上讲就称为<strong>单例设计模式（Singleton）</strong>。</p>
<blockquote>
<p>单例设计模式特点：<br>构造方法被私有化，只能够通过<strong>getInstance()</strong>方法取得Singleton类的实例化对象，这样不管外部如何操作，最终也只有一个实例化对象，在单例设计模式之中，一定会存在一个<strong>static</strong>方法，用于取得本类的实例化对象。</p>
</blockquote>
<p>单例设计模式按照设计模式的角度而言，分为两种：</p>
<ul>
<li><strong>饿汉式</strong>：之前写的程序就属于饿汉式，因为在类之中的<strong>INSNTACE</strong>属性是在定义属性的时候直接实例化；</li>
<li><strong>懒汉式</strong>：在第一次使用一个类实例化对象的时候才去实例化。</li>
</ul>
<p>懒汉式：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; <span class="comment">// 定义一个类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World .&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 没有实例化</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton() ; <span class="comment">// 实例化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="多例设计模式"><a href="#多例设计模式" class="headerlink" title="多例设计模式"></a>多例设计模式</h3><p>单例设计模式只留有一个类的一个实例化对象，而多例设计模式，会定义出多个对象。</p>
<p>例如：定义一个表示星期X的类，这个类的对象只有7个取值，定义一个表示性别的类，只有2个取值，定义一个表示颜色基色的操作类，颜色只有三个：红、绿、蓝，这种情况下，这样的类就<strong>不应该由用户无限制的去创造实例化对象</strong>，应该只使用有限的几个，这个就属于<strong>多例设计</strong>，但不管是单例设计还是多例设计，有一个核心不可动摇 —— <strong>构造方法私有化</strong>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex MALE = <span class="keyword">new</span> Sex(<span class="string">&quot;男&quot;</span>) ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sex FEMALE = <span class="keyword">new</span> Sex(<span class="string">&quot;女&quot;</span>) ;</span><br><span class="line">    <span class="keyword">private</span> String title ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Sex</span><span class="params">(String title)</span> </span>&#123; <span class="comment">// 构造方法私有化</span></span><br><span class="line">        <span class="keyword">this</span>.title = title ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sex <span class="title">getInstance</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(msg) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;male&quot;</span> :</span><br><span class="line">                <span class="keyword">return</span> MALE ;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;female&quot;</span> :</span><br><span class="line">                <span class="keyword">return</span> FEMALE ;</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.title ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Sex male = Sex.getInstance(<span class="string">&quot;male&quot;</span>) ;</span><br><span class="line">        System.out.println(male.getTitle()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>多态性包括方法的多态性和对象的多态性。</p>
<ul>
<li>方法的多态性：重载与覆写<ul>
<li><strong>重载</strong>：同一个方法名称，根据不同的参数类型及个数可以完成不同的功能；</li>
<li><strong>覆写</strong>：同一个方法，根据操作的子类不同，所完成的功能也不同。</li>
</ul>
</li>
<li>对象的多态性：父子类对象的转换。<ul>
<li><strong>向上转型</strong>：子类对象变为父类对象，格式：父类父类对象 = 子类实例，自动；</li>
<li><strong>向下转型</strong>：父类对象变为子类对象，格式：子类子类对象= (子类) 父类实例，强制；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> B() ; <span class="comment">// 向上转型</span></span><br><span class="line">B b = (B) a ; <span class="comment">// 向下转型 java.lang.ClassCastException: A cannot be cast to B</span></span><br></pre></td></tr></table></figure>
<p>转型因素： </p>
<ul>
<li>在实际的工作之中，对象的向上转型为主要使用，80%，向上转型之后，所有的方法以父类的方法为主，但是具体的实现，还是要看子类是否覆写了此方法； </li>
<li>向下转型，10%，因为在进行向下转型操作之前，<strong>一定要首先发生向上转型</strong>，以建立两个对象之间的联系，如果没有这种联系，是不可能发生向下转型的，一旦发生了运行中就会出现“ClassCastException”，当需要调用子类自己特殊定义方法的时候，才需要向下转型；</li>
<li>不转型，10%，在一些资源较少的时候，例如：移动开发。</li>
</ul>
<p>可以使用 <strong>instanceof</strong> 关键字判断某一个对象是否是一个类的实例<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A() ;</span><br><span class="line">        System.out.println(a <span class="keyword">instanceof</span> A) ;</span><br><span class="line">        System.out.println(a <span class="keyword">instanceof</span> B) ;</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> B) &#123;</span><br><span class="line">            B b = (B) a ;</span><br><span class="line">            b.getB() ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>子类操作的过程之中，尽量向父类靠拢。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A、public void print()&#123;&#125;&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="comment">// 方法覆写</span></span><br><span class="line">        <span class="keyword">this</span>.getB() ;</span><br><span class="line">        System.out.println(<span class="string">&quot;B、public void print()&#123;&#125;&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B、getB()&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="comment">// 方法覆写</span></span><br><span class="line">        <span class="keyword">this</span>.getC() ;</span><br><span class="line">        System.out.println(<span class="string">&quot;C、public void print()&#123;&#125;&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C、getC()&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        fun(<span class="keyword">new</span> B()) ;</span><br><span class="line">        fun(<span class="keyword">new</span> C()) ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        a.print() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>一个类不能去继承一个已经实现好的类，只能继承抽象类或实现接口。</strong></p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>普通类就是一个完善的功能类，可以直接产生对象并且可以使用，里面的方法都是带有方法体的。而<br>抽象类之中最大的特点是<strong>包含了抽象方法</strong>，<strong>抽象方法是只声明而未实现（没有方法体）的方法</strong>，抽象方法定义的时候要使用<code>abstract</code>关键字完成。抽象方法一定要在抽象类之中，抽象类也要使用<code>abstract</code>关键字声明。<br>定义一个抽象类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String info = <span class="string">&quot;Hello World .&quot;</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(info) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>; <span class="comment">// 只声明没有方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>抽象类的实例化不能用 new 关键字，这是由于一个类的对象实例化之后，可以调用类中的属性和方法，但是抽象类之中的抽象方法没有方法体。</p>
<p>抽象类的使用原则：</p>
<ul>
<li>抽象类必须有子类，使用 extends 继承，<strong>一个子类只能继承一个抽象类</strong>；</li>
<li>子类（如果不是抽象类）则<strong>必须覆写抽象类之中的全部抽象方法</strong>；</li>
<li>抽象类对象可以使用对象的向上转型方式，通过子类来进行实例化操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String info = <span class="string">&quot;Hello World .&quot;</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(info) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>; <span class="comment">// 只声明没有方法体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impl</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello MLDN .&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> Impl() ; <span class="comment">// 向上转型</span></span><br><span class="line">        a.print() ; <span class="comment">// 自己类定义</span></span><br><span class="line">        a.get() ; <span class="comment">// 子类负责实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类可以没有抽象方法，但是即使没有抽象方法也不能直接实例化。</p>
<blockquote>
<p>定义的外部抽象类不能使用 static 关键字修饰，但是定义的是内部抽象类时，这个内部的抽象类使用了static声明之后，就表示是一个外部的抽象类。</p>
</blockquote>
<h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><p>现在有三种类型：狗、机器人、人；<br>狗具备三种功能：吃、睡、跑；<br>机器人具备两个功能：吃、工作；<br>人具备四个功能：吃、睡、跑、工作。<br>现在给出的三个类实际上并没有任何的联系，唯一的联系就是在于一些行为上。</p>
<p>可以使用模板设计模式：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EAT = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SLEEP = <span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORK = <span class="number">5</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUN = <span class="number">7</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order</span><span class="params">(<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">case</span> EAT :</span><br><span class="line">                <span class="keyword">this</span>.eat() ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">case</span> SLEEP:</span><br><span class="line">                <span class="keyword">this</span>.sleep() ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">case</span> WORK :</span><br><span class="line">                <span class="keyword">this</span>.work() ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">case</span> RUN :</span><br><span class="line">                <span class="keyword">this</span>.run() ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">case</span> EAT + SLEEP + RUN :</span><br><span class="line">                <span class="keyword">this</span>.eat() ;</span><br><span class="line">                <span class="keyword">this</span>.sleep() ;</span><br><span class="line">                <span class="keyword">this</span>.run() ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">case</span> EAT + WORK :</span><br><span class="line">                <span class="keyword">this</span>.eat() ;</span><br><span class="line">                <span class="keyword">this</span>.work() ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">case</span> EAT + SLEEP + RUN + WORK :</span><br><span class="line">                <span class="keyword">this</span>.eat() ;</span><br><span class="line">                <span class="keyword">this</span>.sleep() ;</span><br><span class="line">                <span class="keyword">this</span>.run() ;</span><br><span class="line">                <span class="keyword">this</span>.work() ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗在吃。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗在睡。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗在跑步。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;机器人喝油。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;机器人在工作。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人在吃饭。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人在睡觉。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人在跑步。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人在工作。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Action act1 = <span class="keyword">new</span> Dog() ;</span><br><span class="line">        act1.order(Action.EAT + Action.SLEEP + Action.RUN) ;</span><br><span class="line">        Action act2 = <span class="keyword">new</span> Robot() ;</span><br><span class="line">        act2.order(Action.EAT + Action.WORK) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所有的子类如果要想正常的完成操作，必须按照指定的方法进行覆写才可以，而这个时候抽象类所起的功能就是一个类定义模板的功能。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口属于一种特殊的类，如果一个类定义的时候全部由<strong>抽象方法</strong>和<strong>全局常量</strong>所组成的话，那么这种类就称为接口，但是接口是使用<code>interface</code>关键字进行定义的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123; <span class="comment">// 定义接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INFO = <span class="string">&quot;Hello World .&quot;</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接口中同样存在了抽象方法，接口的使用原则如下： </p>
<ul>
<li>每一个接口必须定义子类，子类使用<code>implements</code>关键字实现接口；</li>
<li>接口的子类（如果不是抽象类）则<strong>必须</strong>覆写接口之中所定义的<strong>全部</strong>抽象方法；</li>
<li>利用接口的子类，采用对象的向上转型方式，进行接口对象的实例化操作。</li>
</ul>
<p>子类实现接口的语法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 [<span class="keyword">extends</span> 父类] [<span class="title">implemetns</span> 接口1,接口2,...] </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>每一个子类可以同时实现多个接口，但是只能继承一个父类。</p>
<p>如果一个类现在即要实现接口又要继承抽象类的话，则应该采用<strong>先继承后实现</strong>的方式完成。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123; <span class="comment">// 定义接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INFO = <span class="string">&quot;Hello World .&quot;</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="keyword">extends</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span> </span>&#123; <span class="comment">// 同时实现了两个接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="comment">// 方法覆写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World .&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(INFO) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;世界，你好！&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> X() ;</span><br><span class="line">        B b = <span class="keyword">new</span> X() ;</span><br><span class="line">        C c = <span class="keyword">new</span> X() ;</span><br><span class="line">        a.print() ;</span><br><span class="line">        b.get() ;</span><br><span class="line">        c.fun() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接口之中的全部组成就是抽象方法和全局常量，故以下两种定义接口的最终效果是一样的：<br>完整定义<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123; <span class="comment">// 定义接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INFO = <span class="string">&quot;Hello World .&quot;</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>简化定义<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123; <span class="comment">// 定义接口</span></span><br><span class="line">    <span class="keyword">public</span> String INFO = <span class="string">&quot;Hello World .&quot;</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>接口之中的访问权限只有一种：<strong>public</strong>，即：定义接口方法的时候就算没有写上public，那么最终也是public。</p>
</blockquote>
<p>在Java之中每一个抽象类都可以实现多个接口，但是反过来讲，<strong>一个接口却不能继承抽象类</strong>，可是Java之中，<strong>一个接口却可以同时继承多个接口</strong>，以实现接口的多继承操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span> </span>&#123; <span class="comment">// 一个接口继承了多个接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="keyword">implements</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开发过程中，内部类永远不会受到概念的限制。同样的，在定义内部接口的时候如果使用了<strong>static</strong>，表示是一个外部接口。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123; <span class="comment">// 外部接口</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="keyword">implements</span> <span class="title">A</span>.<span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World .&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        A.B temp = <span class="keyword">new</span> X() ;</span><br><span class="line">        temp.printB() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在实际开发过程中，接口有三大功能：</p>
<ul>
<li>制订操作标准； </li>
<li>表示一种能力； </li>
<li>将服务器端的远程方法视图暴露给客户端。</li>
</ul>
<p><strong>抽象类和接口的区别</strong><br>| No.  |  区别   |                   抽象类                    |         接口          |<br>| :—: | :—-: | :———————————————————: | :————————-: |<br>|  1   | 定义关键字 |              abstract class              |      interface      |<br>|  2   |  组成   |           常量、变量、抽象方法、普通方法、构造方法           |      全局常量、抽象方法      |<br>|  3   |  权限   |                 可以使用各种权限                 |      只能是public      |<br>|  4   |  关系   |              一个抽象类可以实现多个接口               | 接口不能够继承抽象类，却可以继承多接口 |<br>|  5   |  使用   | 子类使用extends继承抽象类抽象类和接口的对象都是利用对象多态性的向上转型，进行接口或抽象类的实例化操作 | 子类使用implements实现接口  |<br>|  6   | 设计模式  |                  模板设计模式                  |    工厂设计模式、代理设计模式    |<br>|  7   |  局限   |              一个子类只能够继承一个抽象类              |    一个子类可以实现多个接口     |</p>
<h3 id="使用接口定义标准"><a href="#使用接口定义标准" class="headerlink" title="使用接口定义标准"></a>使用接口定义标准</h3><p>下面使用接口定义一个 USB 的标准<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span> </span>&#123; <span class="comment">// 操作标准</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>定义 USB 设备<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;安装手机驱动程序。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机与电脑进行工作。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">USB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;安装打印机驱动程序。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行文件打印。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在电脑上应用此接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plugin</span><span class="params">(USB usb)</span> </span>&#123;</span><br><span class="line">        usb.install() ;</span><br><span class="line">        usb.work() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>测试<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Computer c = <span class="keyword">new</span> Computer() ;</span><br><span class="line">        c.plugin(<span class="keyword">new</span> Phone()) ; <span class="comment">// USB usb = new Phone() ;</span></span><br><span class="line">        c.plugin(<span class="keyword">new</span> Print()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="工厂设计模式（Factory）"><a href="#工厂设计模式（Factory）" class="headerlink" title="工厂设计模式（Factory）"></a>工厂设计模式（Factory）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃苹果。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃橘子。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;apple&quot;</span>.equals(className)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Apple() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;orange&quot;</span>.equals(className)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Orange () ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Fruit f = Factory.getInstance(args[<span class="number">0</span>]) ;</span><br><span class="line">        f.eat() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个接口不和一个固定的子类绑在一起，中间经过一个过渡，降低接口与子类之间的耦合。</p>
<h3 id="代理设计模式（Proxy）"><a href="#代理设计模式（Proxy）" class="headerlink" title="代理设计模式（Proxy）"></a>代理设计模式（Proxy）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123; <span class="comment">// 操作主题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真实业务主题&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject sub = <span class="keyword">null</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(Subject sub)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sub = sub ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备操作。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收尾操作。&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prepare() ;</span><br><span class="line">        <span class="keyword">this</span>.sub.get() ;</span><br><span class="line">        <span class="keyword">this</span>.destroy() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Subject sub = <span class="keyword">new</span> ProxySubject(<span class="keyword">new</span> RealSubject()) ;</span><br><span class="line">        sub.get() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理负责完成与真实业务有关的所有辅助性操作。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 面向对象（四）</title>
    <url>/Blog/2016/07/31/java-OOP-4/</url>
    <content><![CDATA[<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类指的是没有名字的内部类。匿名内部类是在抽象类和接口的基础之上所发展起来的一种应用。<br>匿名内部类的语法为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> SuperType(construction parameters)&#123;</span><br><span class="line">    inner <span class="class"><span class="keyword">class</span> <span class="title">methods</span> <span class="title">and</span> <span class="title">data</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><span id="more"></span><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Message</span> </span>&#123; <span class="comment">// 定义了一个接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>; <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(Message msg)</span> </span>&#123; <span class="comment">// 接收接口对象</span></span><br><span class="line">        msg.print() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Demo.get(<span class="keyword">new</span> Message() &#123; <span class="comment">// 匿名内部类</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello World .&quot;</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object 类是所有类的超类。<br>在Java的定义之中，除了 Object 类之外，所有的类实际上都存在继承关系。如果定义一个类没有默认继承任何一个父类的话，则默认将继承 Object 类。<br>所以下面两种定义是等价的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>Object类可以接收所有类的实例化对象:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">        Object obj = <span class="keyword">new</span> Person() ;</span><br><span class="line">        Person per = (Person) obj ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于任意的一个简单Java类而言，理论上讲应该覆写Object类之中的三个方法： </p>
<ul>
<li><strong>取得对象信息</strong>：public String toString()； </li>
<li><strong>对象比较</strong>：public boolean equals(Object obj)； </li>
<li><strong>取得哈希码</strong>：public int hashCode()。</li>
</ul>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>对对象直接调用 println() 函数的话得到的是一个对象的地址，而 toString() 方法默认也是输出对象的地址。也就是说执行 println() 函数是对象默认调用了 toString() 函数。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Person() ;</span><br><span class="line">        System.out.println(per) ; <span class="comment">// Person@ 1f 6226 </span></span><br><span class="line">        System.out.println(per.toString()) ; <span class="comment">// Person@ 1f 6226 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果要输出对象的具体信息，可以对这个方法进行覆写：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="comment">// 方法覆写 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;，年龄：&quot;</span> + <span class="keyword">this</span>.age ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>在Object类之中，默认的 equals() 方法实现比较的是两个对象的<strong>内存地址数值</strong>，这并不符合于真正的对象比较需要，需要进行覆写：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name ; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age ; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name ; </span><br><span class="line">        <span class="keyword">this</span>.age = age ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="comment">// 方法覆写 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;，年龄：&quot;</span> + <span class="keyword">this</span>.age ; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (! (obj <span class="keyword">instanceof</span> Person)) &#123; <span class="comment">// 不是本类对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为name和age属性是在Person类中定义，而Object类没有</span></span><br><span class="line">        Person per = (Person) obj ;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name.equals(per.name) &amp;&amp; <span class="keyword">this</span>.age == per.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用Object接收所有的引用数据类型"><a href="#使用Object接收所有的引用数据类型" class="headerlink" title="使用Object接收所有的引用数据类型"></a>使用Object接收所有的引用数据类型</h3><p>Object是所有类的父类，所以 Object 类可以接收所有类的对象，但是在Java设计的时候，考虑到引用数据类型的特殊性，所以 Object 类实际上是可以接收<strong>所有引用数据类型</strong>的数据，这就包括了数组、接口、类。</p>
<p>使用Object类接收数组<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">        Object obj = <span class="keyword">new</span> <span class="keyword">int</span> [] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; ; <span class="comment">// 接收数组 </span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="keyword">int</span> []) &#123; </span><br><span class="line">            <span class="keyword">int</span> [] data = (<span class="keyword">int</span> []) obj ; <span class="comment">// 向下转型 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; data.length ; x ++) &#123; </span><br><span class="line">                System.out.println(data[x]) ; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>hash code 是对象导出的一个整数值。散列码是没有规律的。两个不同的对象其散列码基本上不会相同。<br>String 类使用下列算法计算散列码:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length(); i++)&#123;</span><br><span class="line">    hash = <span class="number">31</span> * hash + charAt(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于hashCode 方法定义在Object类中，故每个对象都有一个默认的散列码，其值为对象的存储地址。<br>如果重新定义了 equals() 方法，就一定要重新定义 hashCode() 方法，以便用户可以将对象插入到散列表中。</p>
<p>hasCode 方法应该返回一个整型数值（也可能是负数），合理的组合实例域的散列码，可以使各个不同对象产生的散列码更加均匀。</p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>在Java的设计之中，一直提倡一个原则：一切皆对象。但是基本数据类型不是对象，这就促使了包装类的诞生。<br>包装类基本是这样定义的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span> </span>&#123; <span class="comment">// 类 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num ; <span class="comment">// 基本型 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Int</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.num = num ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>java 提供了八种包装类，这八种包装类又分为两大阵营：</p>
<ul>
<li>数值型（Number子类）：Byte、Short、Integer、Float、Double、Long；</li>
<li>对象型（Object子类）：Boolean、Character。</li>
</ul>
<p>针对数值型包装类定义的方法：byteValue()、intValue()、doubleValue()、shortValue()、floatValue()、doubleValue()，可以从包装的类之中取得所包装的数值。</p>
<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>在基本数据类型和包装类之间的转换操作之中分为两个重要概念：</p>
<ul>
<li>装箱操作：将基本数据类型变为包装类，称为装箱，包装类的构造方法；</li>
<li>拆箱操作：将包装类变为基本数据类型，称为拆箱，各个类的 xxValue()方法。</li>
</ul>
<p>以double和Double为例<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">        Double <span class="keyword">var</span> = <span class="keyword">new</span> Double(<span class="number">15.5</span>) ; <span class="comment">// 装箱 </span></span><br><span class="line">        <span class="keyword">double</span> result = <span class="keyword">var</span>.doubleValue() ; <span class="comment">// 拆箱 </span></span><br><span class="line">        System.out.println(result * result) ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>JDK 1.5之后，Java提供了自动的装箱和拆箱机制，并且包装类的对象可以自动的进行数学计算<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">        Integer <span class="keyword">var</span> = <span class="number">15</span> ; <span class="comment">// 自动装箱 </span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">var</span> ; <span class="comment">// 自动拆箱 </span></span><br><span class="line">        System.out.println(++ <span class="keyword">var</span> * result) ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为有了这样的自动装箱和拆箱的机制，所以Object也可以接收基本数据类型的数据。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">        Object obj = <span class="number">15</span> ; <span class="comment">// int --&gt; 自动装箱 --&gt; Object </span></span><br><span class="line">        <span class="keyword">int</span> result = (Integer) obj ; <span class="comment">// Object --&gt; 包装类 --&gt; 自动拆箱</span></span><br><span class="line">        System.out.println(result * result) ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用包装类的时候还需要考虑equals()和==的区别<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">        Integer x = <span class="keyword">new</span> Integer(<span class="number">10</span>) ; <span class="comment">// 新空间 </span></span><br><span class="line">        Integer y = <span class="number">10</span> ; <span class="comment">// 入池 </span></span><br><span class="line">        Integer z = <span class="number">10</span> ; </span><br><span class="line">        System.out.println(x == y) ; <span class="comment">// false </span></span><br><span class="line">        System.out.println(x == z) ; <span class="comment">// false </span></span><br><span class="line">        System.out.println(z == y) ; <span class="comment">// true </span></span><br><span class="line">        System.out.println(x.equals(y)) ; <span class="comment">// true </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="数据转型"><a href="#数据转型" class="headerlink" title="数据转型"></a>数据转型</h3><p>包装类之中所提供的最大优点还在于可以将字符串变为指定的基本数据类型</p>
<ul>
<li><strong>Integer类</strong>：public static int parseInt(String s)； </li>
<li><strong>Double类</strong>：public static double parseDouble(String s)； </li>
<li><strong>Boolean类</strong>：public static boolean parseBoolean(String s)；</li>
</ul>
<p>但是 Character 这个包装类之中，并没有提供一个类似的 <code>parseCharacter()</code>，因为字符串 String 类之中提供了一个<code>charAt()</code>方法，可以取得指定索引的字符，而且一个字符的长度就是一位。</p>
<p>在执行这种转换的操作过程之中，字符串中的全部内容必须由数字所组成，如果有一位内容不是数字，则在转换的过程之中将出现如下的错误提示：<strong>NumberFormatException</strong>。</p>
<p>在使用Boolean型包装类的时候，如果字符串之中的内容不是true或者是false，统一都按照false处理。</p>
<p><strong>基本类型变为String字符串</strong><br>方式一：任何的基本类型数据遇到了String之后都变为String型数据；<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span> ; </span><br><span class="line">        String str = num + <span class="string">&quot;&quot;</span> ; <span class="comment">// int --&gt; String </span></span><br><span class="line">        System.out.println(str.length()) ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>方式二：利用String类的方法，public static String valueOf(数据类型b)<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span> ; </span><br><span class="line">        String str = String.valueOf(num) ; <span class="comment">// int --&gt; String </span></span><br><span class="line">        System.out.println(str.length()) ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 创建与销毁对象</title>
    <url>/Blog/2016/10/04/java-create-and-destroy-object/</url>
    <content><![CDATA[<p>本文《Effective Java》第一章的读书笔记，主要内容是：在java程序升设计中，何时以及如何创建对象，何时以及如何避免创建对象，如何确保对象及时地销毁以及销毁对象后的清理工作。</p>
<h2 id="静态工厂方法代替构造器"><a href="#静态工厂方法代替构造器" class="headerlink" title="静态工厂方法代替构造器"></a>静态工厂方法代替构造器</h2><p>创建类的实例，有两种方法：<br>① 利用共有构造器<br>② 类提供一个共有的静态工厂方法，它返回类的实例</p>
<p>第二种方法类似于这样：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><span id="more"></span></p>
<h3 id="静态工厂方法的优点"><a href="#静态工厂方法的优点" class="headerlink" title="静态工厂方法的优点"></a>静态工厂方法的优点</h3><p><strong>① 静态工厂方法有名字</strong></p>
<p>一个类只能有一个带有指定签名的构造器，如果要提供多个构造器，则只能在参数上做文章。这样不利于编写文档。由于静态方法有名称，故可以很好的区分不同的实例化静态方法。</p>
<p><strong>② 静态方法不必在每次调用时都创建一个新的对象</strong></p>
<p>这个特点可以使不可变类提前创建好实例然后缓存起来重复利用，从而避免创建不必要的对象。这类方法类似于<strong>享元（Flyweight）模式</strong>，避免大量拥有相同内容的小类的开销(如耗费内存),使大家共享一个类(元类)。<br>静态工厂方法能够为重复的调用返回相同的对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在，这种类称为<strong>实例受控的类（instance-contrilled）</strong>。</p>
<p><strong>③ 静态工厂方法可以返回原返回类型的任何子类型对象</strong></p>
<p>使用这种方法在返回对象的类时有很大的灵活性，API可以返回对象，同时又不会使对象的类变为公有的。以这种方法隐藏实现类会使API变得十分简洁。这项技术适用于基于接口的框架。使用这种静态方法时，甚至要求客户端通过接口来引用被访问的对象，而不是通过它的实现类来引用被返回的对象。</p>
<p><strong>④ 创建参数化类型实例的时候可以使代码变得更加简洁</strong><br>对于参数化类的构造器，即使类型参数很明显，在调用时也必须指明：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; m = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br></pre></td></tr></table></figure><br>如果类型参数很长，那么这种说明将是很难受的。<br>如果使用静态工厂方法，编译器就可以替你找到类型参数，这种被称作<strong>类型推导（type inference）</strong>，例如，假设 HashMap 提供了这个静态工厂：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">HashMap&lt;K,V&gt; <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K,V&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么上面那句繁琐的声明就可以写成这样：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; m = HashMap.newInstance();</span><br></pre></td></tr></table></figure></p>
<h3 id="静态工厂方法的缺点"><a href="#静态工厂方法的缺点" class="headerlink" title="静态工厂方法的缺点"></a>静态工厂方法的缺点</h3><p><strong>① 类如果不含共有或者受保护的构造器，就不能被子类化</strong></p>
<p><strong>② 静态工厂方法与其他静态方法实际上没有任何区别</strong><br>在API文档中，没有任何标志说明某个静态方法可用于实例化类，因此，对于那些没有构造器的类来说，想要查明如何实例化一个类将是很困难的。当然，也许以后 Javadoc 会注意到这一点。</p>
<p>一些静态工厂方法的惯用名称：</p>
<ul>
<li>valueOf</li>
<li>of</li>
<li>getInstance</li>
<li>newInstance</li>
<li>getType</li>
<li>newType</li>
</ul>
<p><strong>切记第一反应就提供共有的构造器，而不考虑静态工厂。</strong></p>
<h2 id="遇到多个构造器参数时要考虑用构建器"><a href="#遇到多个构造器参数时要考虑用构建器" class="headerlink" title="遇到多个构造器参数时要考虑用构建器"></a>遇到多个构造器参数时要考虑用构建器</h2><p>静态工厂和构造器有个共同的局限性：<strong>它们都不能很好地扩展到大量的可选参数。</strong><br><strong>重叠构造器模式（telescoping constructor）</strong>可以很好地解决这个问题。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize; <span class="comment">// (mL) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings; <span class="comment">// (per container) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories; <span class="comment">// optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat; <span class="comment">// (g) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium; <span class="comment">// (mg) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate; <span class="comment">// (g) optional</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(servingSize, servings, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(servingSize, servings, calories, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(servingSize, servings, calories, fat, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat, <span class="keyword">int</span> sodium)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(servingSize, servings, calories, fat, sodium, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat, <span class="keyword">int</span> sodium, <span class="keyword">int</span> carbohydrate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">        <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        <span class="keyword">this</span>.calories = calories;</span><br><span class="line">        <span class="keyword">this</span>.fat = fat;</span><br><span class="line">        <span class="keyword">this</span>.sodium = sodium;</span><br><span class="line">        <span class="keyword">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不过，这种模式当需要传递许多参数的时候，代码也会变得难以编写。要仔细弄清楚每个参数的含义才能正确地使用构造器。</p>
<p>另一种替代方法为<strong>JavaBeans模式</strong>，在这种模式下，调用一个无参数构造器创建对象，然后调用setter方法来设置每个必要的参数，以及每个相关的可选参数。这种模式虽然弥补了重叠构造器模式的不足，但是也有自身的缺陷。因为构造过程被分到几个调用中，在构造过程中JavaBeans可能处于不一致的状态，类无法仅仅通过检验构造器参数来保证一致性。</p>
<p>比较完美地替代方法是<strong>Builder模式</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Required parameters</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// Optional parameters - initialized to default values</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">            </span>&#123; calories = val; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">            </span>&#123; fat = val; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">            </span>&#123; carbohydrate = val; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">            </span>&#123; sodium = val; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        servingSize = builder.servingSize;</span><br><span class="line">        servings = builder.servings;</span><br><span class="line">        calories = builder.calories;</span><br><span class="line">        fat = builder.fat;</span><br><span class="line">        sodium = builder.sodium;</span><br><span class="line">        carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种方法参数传递是一个链式操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">240</span>,<span class="number">8</span>).calories(<span class="number">100</span>).sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build();</span><br></pre></td></tr></table></figure><br>Builder模式非常之灵活，可以利用单个builder构建多个对象，builder参数可以在创建对象期间进行调整，也可以随着不同的对象而改变。<br>带有builder实例的方法通常利用有限制的通配符类型来约束构建器的类型参数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Tree <span class="title">buildTree</span><span class="params">(Builder&lt;? extends Node&gt; nodeBuilder)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br><strong>如果累个构造器或者静态工厂方法中具有多个参数，设计这种类时，Builder模式就是中不错的选择，特别是当大多数参数都是可选的时候。</strong></p>
<h2 id="用私有构造器或者枚举类型强化Singleton属性"><a href="#用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="用私有构造器或者枚举类型强化Singleton属性"></a>用私有构造器或者枚举类型强化Singleton属性</h2><p>Singleton指的是仅仅被实例化一次的类，它通常代表那些本质上唯一的系统组件。</p>
<p>实现Singleton有三种方法：</p>
<p><strong>① 共有静态成员是一个final域</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singleton with public final field</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>私有构造器仅被调用一次，用来实例化公有的静态final域Elvis.INSTANCE。</p>
<p>公有域方法的主要好处在于，组成类的成员声明很清楚地表明了这个类是一个Singleton: 共有的静态域是final的，所以该域将总是包含相同的对象引用。<br><strong>② 公有的成员是个静态工厂方法</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singleton with static factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于静态方法Elvis.getInstance的所有调用，都会返回同一个对象引用，所以永远不会创建其他Elvis实例。</p>
<blockquote>
<p><strong>注意：</strong> 享有特权的客户端可以借助 AccessibleObject.setAccessible 方法，通过反射机制调用私有构造器。要抵御这种攻击，可以修改构造器，让它在被要求创建第二次的时候抛出异常。</p>
</blockquote>
<p><strong>③ 使用单个元素枚举类型</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种方式在功能上和公有域方法相近，但是它更加简洁，无偿提供了序列化机制，绝对泛指多次实例化，即使面对复杂的序列化或者反射攻击的时候。<strong>单元素的枚举类已经成为实现Singleton的最佳方案。</strong></p>
<h2 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h2><p>有时候我们需要编写只包含静态方法和静态域的类，这种时候我们不希望类被实例化。但是即使在不提供构造器的时候，编译器也会自动提供一个共有的、无参的缺省构造器。<br>这个时候可以使用私有构造器，使类不能被实例化：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Noninstantiable utility class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UtilityClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Suppress default constructor for noninstantiability</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UtilityClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于只有类中不包含显式的构造器时编译器才会生成默认构造器，且私有的构造器外部不可以访问，所以这样就完全限制了类不可实例化。</p>
<blockquote>
<p>AssertionError不是必需的，但是它可以避免不小心在类的内部调用构造器。</p>
</blockquote>
<h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><p>一般来说，最好能重用对象而不是每次需要的时候就创建一个相同功能的新对象，重用方式既快速又流行。如果对象是不可变的，它始终可以被重用。</p>
<p>对于同时提供静态工厂方法与构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创建不必要的对象。</p>
<p>除了可重用不可变的对象外，还可以重用那些一直不会改变的可变对象，例如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date birthDate;</span><br><span class="line">    <span class="comment">// Other fields, methods, and constructor omitted</span></span><br><span class="line">    <span class="comment">// DON&#x27;T DO THIS!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBabyBoomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Unnecessary allocation of expensive object</span></span><br><span class="line">        Calendar gmtCal =</span><br><span class="line">            Calendar.getInstance(TimeZone.getTimeZone(<span class="string">&quot;GMT&quot;</span>));</span><br><span class="line">        gmtCal.set(<span class="number">1946</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        Date boomStart = gmtCal.getTime();</span><br><span class="line">        gmtCal.set(<span class="number">1965</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        Date boomEnd = gmtCal.getTime();</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(boomStart) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                birthDate.compareTo(boomEnd) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>isBabyBoomer 每次调用都会新建一个Calendar, TimeZone和两个 Date对象，这是不必要的。可以使用<strong>静态的初始化器（initiallizer）</strong>避免这种低效的情况：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date birthDate;</span><br><span class="line">    <span class="comment">// Other fields, methods, and constructor omitted</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The starting and ending dates of the baby boom.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Date BOOM_START;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Date BOOM_END;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(<span class="string">&quot;GMT&quot;</span>));</span><br><span class="line">        gmtCal.set(<span class="number">1946</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        BOOM_START = gmtCal.getTime();</span><br><span class="line">        gmtCal.set(<span class="number">1965</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        BOOM_END = gmtCal.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBabyBoomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthDate.compareTo(BOOM_START) &gt;= <span class="number">0</span> &amp;&amp; birthDate.compareTo(BOOM_END) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>改进后的Person类只在初始化的时候创建Calendar, TimeZone 和 Date 对象，而不是每次调用都重新创建。</p>
<blockquote>
<p>如果想进一步优化，比如在第一次调用时才初始化，这种可以通过<strong>延迟初始化（lazily initializing）</strong>实现。但是不建议这么做，因为会使方法的实现变得更加复杂。</p>
</blockquote>
<p>另外，也要注意<strong>自动装箱</strong>所创建的不必要的对象。</p>
<h2 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h2><p>Java虽然有自动垃圾回收机制，但是也会存在<strong>内存泄漏</strong>的情况。比如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Ensure space for at least one more element, roughly</span></span><br><span class="line"><span class="comment">    * doubling the capacity each time the array needs to grow.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段程序有 “内存泄漏”，如果一个栈先增长，后收缩，那么从栈中弹出的对象将不会当做垃圾回收。这是因为<strong>栈每部维护着这些对象的过期引用（obsolete reference）</strong>。过期引用是永远不会再被解除的引用，本例中凡是在elements数组的“活动部分”之外的任何引用都是过期的，活动部分是指elements中下标小于size的那些元素。</p>
<p>这类问题的处理很简单,字需要按如下方式修改pop()函数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>; <span class="comment">// Eliminate obsolete reference</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>一旦数字元素变成非活动元素的一部分，程序员就手工清空这些数组元素。</p>
</blockquote>
<p><strong>内存泄漏的另一个常见来源是缓存</strong>。当所要的缓存项的生命周期是由该键的外部引用而不是由值来决定，可以使用 WeakHashMap 来代表缓存，当缓存项过期之后，它们会被自动删除。</p>
<p><strong>内存泄漏的第三个常见来源是监听器和其他回调。</strong>确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用，例如，只将它们保存为 WeakHashMap 的键。</p>
<h2 id="避免使用finalizer"><a href="#避免使用finalizer" class="headerlink" title="避免使用finalizer"></a>避免使用finalizer</h2><p>终结方法通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定，降低性能，以及可移植性问题。</p>
<p><strong>终结方法的缺点</strong></p>
<ul>
<li>从一个对象变得不可达开始，到它的终结方法被执行，所花费的这段时间是任意长的。</li>
<li>如果未捕获的异常在终结过程中被抛出，那么这种异常可以被忽略，并且该对象的终结过程也会终止。</li>
<li>终结方法非常严重的性能损失。</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程编程基础</title>
    <url>/Blog/2016/09/11/java-multithread-01/</url>
    <content><![CDATA[<h2 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h2><p>在 Java 之中，如果要想实现多线程的程序，那么就必须依靠一个线程的<strong>主体类</strong>（就好比主类的概念一<br>样，表示的是一个线程的主类），但是这个线程的主体类在定义的时候也需要有一些特殊的要求，这个类<br>可以继承<strong>Thread</strong> 类或实现<strong>Runnable</strong> 接口来完成定义。<br><span id="more"></span></p>
<h3 id="继承-Thread-类实现多线程"><a href="#继承-Thread-类实现多线程" class="headerlink" title="继承 Thread 类实现多线程"></a>继承 Thread 类实现多线程</h3><p><strong>java.lang.Thread</strong> 是一个负责线程操作的类，任何的类只需要继承了<strong>Thread</strong> 类就可以成为一个线程的主类，但是既然是主类必须有它的使用方法，而线程启动的主方法是需要覆写Thread类中的<strong>run()方法</strong>才可以。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; <span class="comment">// 线程的主体类</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 线程的主方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">50</span>; x++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.title + <span class="string">&quot;运行，x = &quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>主类调用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;线程A&quot;</span>) ;</span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;线程B&quot;</span>) ;</span><br><span class="line">        MyThread mt3 = <span class="keyword">new</span> MyThread(<span class="string">&quot;线程C&quot;</span>) ;</span><br><span class="line">        mt1.run() ;</span><br><span class="line">        mt2.run() ;</span><br><span class="line">        mt3.run() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是以上操作并没有真正启动多线程，，因为多个线程彼此之间的执行一定是交替的方式运行，而此时是顺序执行，即：每一个对象的代码执行完之后才向下继续执行。如果要想在程序之中真正的启动多线程，必须依靠Thread类的一个方法：<code>public void start()</code>，表示真正启动多线程，调用此方法后会间接调用<code>run()</code>方法:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TestDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        MyThread mt1 = new MyThread(&quot;线程A&quot;) ;</span><br><span class="line">        MyThread mt2 = new MyThread(&quot;线程B&quot;) ;</span><br><span class="line">        MyThread mt3 = new MyThread(&quot;线程C&quot;) ;</span><br><span class="line">        mt1.start() ;</span><br><span class="line">        mt2.start() ;</span><br><span class="line">        mt3.start() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>要想启动线程必须依靠Thread类的start()方法执行，线程启动之后会默认调用了run()方法。</strong></p>
<p>那为什么调用 start() 方法就可以实现多线程呢？查看其定义如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>首先看到该方法会抛出一个异常：<code>IllegalThreadStateException()</code>，这个异常属于运行时异常。当一个线程对象被重复启动之后会抛出此异常，即：一个线程对象只能启动唯一的一次。</p>
<p>在<code>start()</code>方法之中有一个最为关键的部分就是<code>start0()</code>方法，而且这个方法上使用了一个<strong>native</strong>关键字的定义。<br><strong>native</strong>关键字指的是<strong>Java本地接口调用</strong>（Java Native Interface），即：是使用Java调用本机操作系统的函数功能完成一些特殊的操作，而这样的代码开发在Java之中几乎很少出现，因为Java的最大特点是可移植性，如果一个程序只能在固定的操作系统上使用，那么可移植性就将彻底的丧失，所以，此操作一般只作为兴趣使用。</p>
<p>多线程的实现一定需要操作系统的支持，<code>start0()</code>方法和抽象方法类似，没有方法体，而这个方法体交给<strong>JVM</strong>去实现。即：在windows下的JVM可能使用<strong>A</strong>方法实现了<code>start0()</code>，而在linux下的JVM可能使用了<strong>B</strong>方法实现了<code>start0()</code>，但是在调用的时候并不会去关心具体是何方式实现了<code>start0()</code>方法，只会关心最终的操作结果，交给JVM去匹配了不同的操作系统。所以在多线程操作之中，使用<code>start()</code>方法启动多线程的操作是需要进行操作系统函数调用的。</p>
<h3 id="实现Runnable接口实现多线程"><a href="#实现Runnable接口实现多线程" class="headerlink" title="实现Runnable接口实现多线程"></a>实现Runnable接口实现多线程</h3><p>使用 Thread类实现多进程最大的缺点就是单继承问题，可以使用 Runnable 接口实现多线程来弥补这个缺陷。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过Runnable接口实现多线程:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">// 线程的主体类</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 线程的主方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">50</span>; x++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.title + <span class="string">&quot;运行，x = &quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于使用接口，没有继承启动多线程要依靠 Thread类的 <code>start()</code> 方法，为了解决这个问题，，在Thread类中定义了一个构造方法：<code>public Thread(Runnable target)</code>，接收Runnable接口对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">        MyThread mt3 = <span class="keyword">new</span> MyThread(<span class="string">&quot;线程C&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(mt1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt2).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt3).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Thread类和Runnable接口实现多线程的区别"><a href="#Thread类和Runnable接口实现多线程的区别" class="headerlink" title="Thread类和Runnable接口实现多线程的区别"></a>Thread类和Runnable接口实现多线程的区别</h3><p>事实上，Thread类也是Runnable接口的子类，Thread 类的定义如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure><br>这样的话，之前的程序结构就是下面的形式：<br><img src="http://static.zybuluo.com/guoxs/6gpf6y99uovm1vxxw29wcf9g/%E7%BB%98%E5%9B%BE1.png" alt="代理设计模式"></p>
<p>这个时候所表现出来的代码模式<strong>非常类似于代理设计模式</strong>，但是它并不是严格意义上代理设计模式，因为从严格来讲代理设计模式之中，代理主题所能够使用的方法依然是接口中定义的run()方法，而此处代理主题调用的是start()方法，所以只能够说形式上类似于代理设计模式，但本质上还是有差别的。</p>
<p>除此之外，<strong>使用Runnable接口可以更加方便的表示出数据共享的概念。</strong></p>
<h3 id="线程的操作状态"><a href="#线程的操作状态" class="headerlink" title="线程的操作状态"></a>线程的操作状态</h3><p>每一个线程对象实际上都拥有属于自己的运行状态:</p>
<ul>
<li>所有的线程对象都必须通过关键字<strong>new</strong>进行创建</li>
<li>线程如果要进行启动则一定会调用Thread类的<strong>start()</strong>方法，但是代码可能会分先后顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(mt).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt).start();</span><br><span class="line"><span class="keyword">new</span> Thread(mt).start();</span><br></pre></td></tr></table></figure>
<p>以上启动了三个线程，虽然在代码上有先后调用start()方法的顺序，可是对于JVM而言，都表示着所有的线程将同时进入到就绪状态，等待执行。</p>
<ul>
<li>进入到就绪状态之后，将等待着CPU进行资源的抢占，抢占到了资源之后，线程会进如到运行状态，开始执行run()方法体之中所定义的代码</li>
<li>每一个线程执行run()方法到一定的时间的时候会让出CPU资源，进入到阻塞状态，而后重新回到就绪状态等待下次资源调度并继续执行run()方法中的代码</li>
<li>如果全部方法执行完毕之后，将进入到线程的终止状态，并且不会再进入到就绪状态，直接结束。</li>
</ul>
<p>线程的状态：<br><img src="http://static.zybuluo.com/guoxs/sj5p34wp84ry6ln8oul2tcz6/%E8%BF%9B%E7%A8%8B.png" alt="线程的状态"></p>
<h2 id="线程的主要操作方法"><a href="#线程的主要操作方法" class="headerlink" title="线程的主要操作方法"></a>线程的主要操作方法</h2><h3 id="线程的命名"><a href="#线程的命名" class="headerlink" title="线程的命名"></a>线程的命名</h3><p>线程本身是属于不可见的运行状态的，所以如果要想在程序之中操作线程，唯一依靠的就是线程名称，而要想取得和设置线程的名称可以使用如下的方法：</p>
<ul>
<li>构造方法：public Thread(Runnable target, String name)；</li>
<li>设置名字：public final void setName(String name)；</li>
<li>取得名字：public final String getName()。</li>
</ul>
<p>取得当前线程对象的方法：<code>public static Thread currentThread()</code></p>
<blockquote>
<p>如果为线程设置了名字，那么会使用用户定义的名字，而如果没有设置线程名称，会自动的为其分配一个名称。</p>
</blockquote>
<p>每一次使用java命令执行一个类的时候就表示启动了一个<strong>JVM的进程</strong>，而主方法是这个进程上的一个线程。一个 JVM 进程启动的时候至少启动两个进程，一个是<strong>main</strong>，一个是<strong>gc</strong>。</p>
<h3 id="线程的休眠"><a href="#线程的休眠" class="headerlink" title="线程的休眠"></a>线程的休眠</h3><p>线程的休眠指的是让程序的执行速度变慢一些，方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure></p>
<p>设置的休眠单位是毫秒。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">// 线程的主体类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 线程的主方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;，x = &quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt, <span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt, <span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt, <span class="string">&quot;线程C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt, <span class="string">&quot;线程D&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt, <span class="string">&quot;线程E&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>从理论上讲，线程的优先级越高，越有可能先执行。如果要想操作线程的优先级有如下两个方法：</p>
<ul>
<li>设置线程的优先级：public final void setPriority(int newPriority)；</li>
<li>取得线程的优先级：public final int getPriority()；</li>
</ul>
<p>发现设置和取得优先级的时候都是利用了一个int型数据的操作，而这个int型数据有三种取值：</p>
<ul>
<li>最高优先级：public static final int MAX_PRIORITY，10；</li>
<li>中等优先级：public static final int NORM_PRIORITY，5；</li>
<li>最低优先级：public static final int MIN_PRIORITY，1；</li>
</ul>
<p>主线程的优先级是5，是<strong>中等级别</strong>。</p>
<h3 id="等待与唤醒"><a href="#等待与唤醒" class="headerlink" title="等待与唤醒"></a>等待与唤醒</h3><p>等待：public final void wait() throws InterruptedException；<br>唤醒第一个等待线程：public final void notify()；<br>唤醒全部等待线程：public final void notifyAll()。</p>
<blockquote>
<p>对于唤醒的两个操作：<br>notify()是<strong>按照等待顺序</strong>进行了唤醒，而使用了notifyAll()则表示所有等待的线程都会被唤醒，那个线程的优先级高，那个线程就先执行。</p>
</blockquote>
<p><strong>sleep()和wait()的区别？</strong></p>
<ul>
<li>sleep()是Thread类定义的static方法，表示线程休眠，休眠到一定时间后自动唤醒；</li>
<li>wait()是Object类定义的方法，表示线程等待，一直到执行了notify()或notifyAll()之后才结束等待。</li>
</ul>
<h2 id="线程的同步与死锁"><a href="#线程的同步与死锁" class="headerlink" title="线程的同步与死锁"></a>线程的同步与死锁</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>所谓的同步问题指的是多个线程操作同一资源时所带来的信息的安全性问题。同步具体的实现思想是指多个操作在同一时间段内只能有一个线程进行，其他线程要等待此线程完成之后才可以继续执行。</p>
<p>实现同步有两种方式，一种是<strong>同步代码块</strong>，另外一种就是<strong>同步方法</strong>。</p>
<p>① <strong>同步代码块</strong>，使用<code>synchronized</code>关键字定义的代码块就称为同步代码块，但是在进行同步的操作之中必须设置一个要同步的对象，而这个对象应该理解为当前对象：this。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">// 线程的主体类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">6</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 线程的主方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 同步代码块</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot;卖票，ticket = &quot;</span> + <span class="keyword">this</span>.ticket--);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt, <span class="string">&quot;票贩子A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt, <span class="string">&quot;票贩子B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt, <span class="string">&quot;票贩子C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt, <span class="string">&quot;票贩子D&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mt, <span class="string">&quot;票贩子E&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>② 同步方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; <span class="comment">// 线程的主体类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">6</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 线程的主方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sale() ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">            + <span class="string">&quot;卖票，ticket = &quot;</span> + <span class="keyword">this</span>.ticket--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>加入同步之后明显比不加入同步慢许多，所以同步的代码性能会很低，但是数据的安全性会高。</strong></p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>同步就是指一个线程要等待另外一个线程执行完毕才会继续执行的一种操作形式，但是如果在一个操作之中都是在互相等着的话，那么就会出现<strong>死锁</strong>问题。</p>
<h2 id="线程间的经典操作案例"><a href="#线程间的经典操作案例" class="headerlink" title="线程间的经典操作案例"></a>线程间的经典操作案例</h2><p>在多线程的开发之中存在一种称为“<strong>生产者和消费者的程序</strong>”，这个程序的主要功能是生产者负责生产一些内容，每当生产完成之后，会由消费者取走全部内容。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title ;</span><br><span class="line">    <span class="keyword">private</span> String content ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span> ;</span><br><span class="line">    <span class="comment">// flag == true：表示可以生产，但是不能取走</span></span><br><span class="line">    <span class="comment">// flag == false：表示可以取走，但是不能生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String title,String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.flag == <span class="keyword">false</span>) &#123; <span class="comment">// 已经生产过了，不能生产</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.wait() ;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.title = title ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>) ;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.content = content ;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span> ;</span><br><span class="line">        <span class="keyword">super</span>.notify() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.flag == <span class="keyword">true</span>) &#123; <span class="comment">// 不能取走</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.wait() ;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>) ;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.title + <span class="string">&quot; --&gt; &quot;</span> + <span class="keyword">this</span>.content);</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">true</span> ; <span class="comment">// 已经取走了，可以继续生产</span></span><br><span class="line">        <span class="keyword">super</span>.notify() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的反射</title>
    <url>/Blog/2016/06/30/java-reflection/</url>
    <content><![CDATA[<p>最近在项目中为了减少切换数据而带来的额外操作，需要用到反射的知识，于是了解了一下 Java 高级语法中的反射。</p>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>在Java中万物皆对象，类也是对象。</p>
<blockquote>
<p>java中的静态成员、普通成员数据类型不是对象，但是普通数据类型有包装对象。</p>
</blockquote>
<span id="more"></span>
<p><strong>类是 java.lang.Class 的实例对象。</strong><br>Class类的构造函数是一个私有对象，故不能通过 new 关键字实例化。<br>Class 类实例化的三种表示方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//Foo实例化对象表示</span></span><br><span class="line">Foo foo1 = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Foo这个类是Class类的实例化对象</span></span><br><span class="line"><span class="comment">//第一种表示方法（实际上说明每个类都有一个隐含的静态成员变量class）</span></span><br><span class="line">Class c1 = Foo.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种表达方式，通过getClass方法</span></span><br><span class="line">Class c2 = foo1.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种表达方法</span></span><br><span class="line">Class c3 = Class.forName(<span class="string">&quot;Foo的完整类名&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过类的类类型创建该类的对象实例（通过c1 or c2 or c3创建Foo的实例对象）</span></span><br><span class="line"><span class="comment">//需进行强制类型转换，应该做异常处理</span></span><br><span class="line">Foo foo = (Foo) c1.newInstance();<span class="comment">//需要有无参数的构造方法</span></span><br></pre></td></tr></table></figure></p>
<p><code>类类型</code> ： Class类的实例对象称为该类的类类型。上面的c1 ,c2 表示了Foo类的类类型(class type)，一个类只可能是Class类的一个实例对象，故 c1 == c2 == c3。</p>
<h2 id="动态加载类"><a href="#动态加载类" class="headerlink" title="动态加载类"></a>动态加载类</h2><p><strong>Class.forName(“类的全称”)</strong> 不仅表示了，类的类类型，还代表了动态加载类。编译时刻加载类是静态加载类、运行时刻加载类是动态加载类。<br><code>new</code> 创建的对象是静态加载类，在编译时就需要加载所有的可能使用到的类。<br>比如下面代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Office</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Word&quot;</span>.equal(args[<span class="number">0</span>])&#123;</span><br><span class="line">            Word w = <span class="keyword">new</span> Word();</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Excel&quot;</span>.equal(args[<span class="number">0</span>])&#123;</span><br><span class="line">            Excel w = <span class="keyword">new</span> Excel();</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个程序中，只有当 Word 类与 Excel 类都实现了才能通过编译，但是有时否则有一个有问题就不能编译。这是非常不友好的，比如说如果有100多个 if 语句分别对应着不同的功能，如果一个功能有问题那么所有的功能都不能实现，这是非常糟糕的一件事情。<br>如果用到<strong>动态加载类</strong>，这种情况可以很好地避免：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OfficeBetter</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//动态加载类，在运行时刻加载</span></span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//在类的是实例化中，由于需要用到类的类型转换，要提前知道类名，可通过接口统一</span></span><br><span class="line">            OfficeAble oa = (OfficeAble) c.newInstance();</span><br><span class="line">            oa.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OfficeAble</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Word类的实现中就需要继承接口OfficeAble</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span> <span class="keyword">implements</span> <span class="title">OfficeAble</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在，有一个功能就能实现一个功能，通过动态加载类，以后如果需要添加其他功能，之前的类不需要修改，只需要实现相应的接口就行了。程序的许多在线快速升级也是这样的，不需要重新编译已有的类，只需要编译新加入的功能类。</p>
<h2 id="获取对象方法"><a href="#获取对象方法" class="headerlink" title="获取对象方法"></a>获取对象方法</h2><p>基本数据类型、void 关键字都有类类型。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1 = <span class="keyword">int</span>.class;<span class="comment">//int 的类类型</span></span><br><span class="line">Class c2 = String.class;<span class="comment">//java.lang.String String类的类类型  </span></span><br><span class="line">Class c3 = <span class="keyword">double</span>.class;</span><br><span class="line">Class c4 = Double.class;</span><br><span class="line">Class c5 = <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line">System.out.println(c2.getName());</span><br><span class="line">System.out.println(c2.getSimpleName());<span class="comment">//不包含包名的类的名称</span></span><br></pre></td></tr></table></figure><br>下面程序实现获取类的信息，获取类的任何信息得到第一步，就是拿到类的类类型：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印类的信息，包括类的成员函数、成员变量(只获取成员函数)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 该对象所属类的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassMethodMessage</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">	<span class="comment">//要获取类的信息  首先要获取类的类类型</span></span><br><span class="line">	Class c = obj.getClass();<span class="comment">//传递的是哪个子类的对象  c就是该子类的类类型</span></span><br><span class="line">	<span class="comment">//获取类的名称</span></span><br><span class="line">	System.out.println(<span class="string">&quot;类的名称是:&quot;</span>+c.getName());</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Method类，方法对象</span></span><br><span class="line"><span class="comment">	 * 一个成员方法就是一个Method对象</span></span><br><span class="line"><span class="comment">	 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的</span></span><br><span class="line"><span class="comment">	 * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Method[] ms = c.getMethods();<span class="comment">//c.getDeclaredMethods()</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ms.length;i++)&#123;</span><br><span class="line">		<span class="comment">//得到方法的返回值类型的类类型</span></span><br><span class="line">		Class returnType = ms[i].getReturnType();</span><br><span class="line">		System.out.print(returnType.getName()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="comment">//得到方法的名称</span></span><br><span class="line">		System.out.print(ms[i].getName()+<span class="string">&quot;(&quot;</span>);</span><br><span class="line">		<span class="comment">//获取参数类型---&gt;得到的是参数列表的类型的类类型</span></span><br><span class="line">		Class[] paramTypes = ms[i].getParameterTypes();</span><br><span class="line">		<span class="keyword">for</span> (Class class1 : paramTypes) &#123;</span><br><span class="line">			System.out.print(class1.getName()+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="获取类的成员变量与构造函数"><a href="#获取类的成员变量与构造函数" class="headerlink" title="获取类的成员变量与构造函数"></a>获取类的成员变量与构造函数</h2><p>获取成员变量的信息：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取成员变量的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFieldMessage</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	Class c = obj.getClass();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 成员变量也是对象</span></span><br><span class="line"><span class="comment">	 * java.lang.reflect.Field</span></span><br><span class="line"><span class="comment">	 * Field类封装了关于成员变量的操作</span></span><br><span class="line"><span class="comment">	 * getFields()方法获取的是所有的public的成员变量的信息</span></span><br><span class="line"><span class="comment">	 * getDeclaredFields获取的是该类自己声明的成员变量的信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//Field[] fs = c.getFields();</span></span><br><span class="line">	Field[] fs = c.getDeclaredFields();</span><br><span class="line">	<span class="keyword">for</span> (Field field : fs) &#123;</span><br><span class="line">		<span class="comment">//得到成员变量的类型的类类型</span></span><br><span class="line">		Class fieldType = field.getType();</span><br><span class="line">		String typeName = fieldType.getName();</span><br><span class="line">		<span class="comment">//得到成员变量的名称</span></span><br><span class="line">		String fieldName = field.getName();</span><br><span class="line">		System.out.println(typeName+<span class="string">&quot; &quot;</span>+fieldName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>获取构造函数信息：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 打印对象的构造函数的信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConMessage</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">Class c = obj.getClass();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造函数也是对象</span></span><br><span class="line"><span class="comment"> * java.lang. Constructor中封装了构造函数的信息</span></span><br><span class="line"><span class="comment"> * getConstructors获取所有的public的构造函数</span></span><br><span class="line"><span class="comment"> * getDeclaredConstructors得到所有的构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Constructor[] cs = c.getConstructors();</span></span><br><span class="line">Constructor[] cs = c.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor constructor : cs) &#123;</span><br><span class="line">	System.out.print(constructor.getName()+<span class="string">&quot;(&quot;</span>);</span><br><span class="line">	<span class="comment">//获取构造函数的参数列表---&gt;得到的是参数列表的类类型</span></span><br><span class="line">	Class[] paramTypes = constructor.getParameterTypes();</span><br><span class="line">	<span class="keyword">for</span> (Class class1 : paramTypes) &#123;</span><br><span class="line">		System.out.print(class1.getName()+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法反射的基本操作"><a href="#方法反射的基本操作" class="headerlink" title="方法反射的基本操作"></a>方法反射的基本操作</h2><p>方法的名称和方法的参数列表才能唯一决定某个方法。方法反射的操作 ：<code>method.invoke(对象，参数列表)</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	   <span class="comment">//要获取print(int ,int )方法  1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型</span></span><br><span class="line">		A a1 = <span class="keyword">new</span> A();</span><br><span class="line">		Class c = a1.getClass();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 2.获取方法 名称和参数列表来决定  </span></span><br><span class="line"><span class="comment">		 * getMethod获取的是public的方法</span></span><br><span class="line"><span class="comment">		 * getDelcaredMethod自己声明的方法</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	    	Method m = c.getMethod(<span class="string">&quot;print&quot;</span>, <span class="keyword">int</span>.class,<span class="keyword">int</span>.class);</span><br><span class="line">	    	<span class="comment">//Method m =  c.getMethod(&quot;print&quot;, new Class[]&#123;int.class,int.class&#125;);也可</span></span><br><span class="line">	    	</span><br><span class="line">	    	<span class="comment">//方法的反射操作  </span></span><br><span class="line">	    	<span class="comment">//a1.print(10, 20);方法的反射操作是用m对象来进行方法调用 和a1.print调用的效果完全相同</span></span><br><span class="line">	    	<span class="comment">//Object o = m.invoke(a1,new Object[]&#123;10,20&#125;);或</span></span><br><span class="line">	    	Object o = m.invoke(a1, <span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">	    	</span><br><span class="line">	    	<span class="comment">//获取方法print(String,String)</span></span><br><span class="line">             Method m1 = c.getMethod(<span class="string">&quot;print&quot;</span>,String.class,String.class);</span><br><span class="line">             <span class="comment">//用方法进行反射操作</span></span><br><span class="line">             o = m1.invoke(a1, <span class="string">&quot;hello&quot;</span>,<span class="string">&quot;WORLD&quot;</span>);</span><br><span class="line">             </span><br><span class="line">            Method m2 = c.getMethod(<span class="string">&quot;print&quot;</span>);</span><br><span class="line">           <span class="comment">//Method m2 = c.getMethod(&quot;print&quot;, new Class[]&#123;&#125;);也可</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment">// m2.invoke(a1, new Object[]&#123;&#125;);</span></span><br><span class="line">            m2.invoke(a1);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">     </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		System.out.println(a+b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String a,String b)</span></span>&#123;</span><br><span class="line">		System.out.println(a.toUpperCase()+<span class="string">&quot;,&quot;</span>+b.toLowerCase());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="集合中的泛型"><a href="#集合中的泛型" class="headerlink" title="集合中的泛型"></a>集合中的泛型</h2><p>Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译就无效了。一般来说，java中数组都是存储相同类型的元素，但是可以通过反射来绕过编译，存储不同类型的元素，但此时不能用 for……in 遍历。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		list1.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="comment">//list1.add(20);错误的</span></span><br><span class="line">		Class c1 = list.getClass();</span><br><span class="line">		Class c2 = list1.getClass();</span><br><span class="line">		System.out.println(c1 == c2);</span><br><span class="line">		<span class="comment">//反射的操作都是编译之后的操作</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * c1==c2结果返回true说明编译之后集合的泛型是去泛型化的</span></span><br><span class="line"><span class="comment">		 * Java中集合的泛型，是防止错误输入的，只在编译阶段有效，</span></span><br><span class="line"><span class="comment">		 * 绕过编译就无效了</span></span><br><span class="line"><span class="comment">		 * 验证：可以通过方法的反射来操作，绕过编译</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Method m = c2.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">			m.invoke(list1, <span class="number">20</span>);<span class="comment">//绕过编译操作就绕过了泛型</span></span><br><span class="line">			System.out.println(list1.size());   <span class="comment">//2</span></span><br><span class="line">			System.out.println(list1);          <span class="comment">//[hello,20]</span></span><br><span class="line">			<span class="comment">/*for (String string : list1) &#123;</span></span><br><span class="line"><span class="comment">				System.out.println(string);</span></span><br><span class="line"><span class="comment">			&#125;*/</span><span class="comment">//现在不能这样遍历</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		  e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>科技论文短语收集（持续更新中……）</title>
    <url>/Blog/2018/03/01/paper-phrase/</url>
    <content><![CDATA[<p>quantitative assessments: 量化评价</p>
<p>the relentless success of: 持续地成功</p>
<p>boundary localization: 边界定位</p>
<p>boundary delineation: 边界描绘</p>
<p>the majority of: 大量</p>
<p>match the criteria: 符合标准, 匹配条件</p>
<p>topologically identical: 结构, 拓扑相等</p>
<p>consist of: 由…组成</p>
<p>be incorporated into: 使成为…的一部分</p>
<p>trade-off: 权衡, 折衷</p>
<p>pros and cons: 优点和缺点<br><span id="more"></span><br>hand engineered features: 手工设计的特征</p>
<p>state-of-the-art: 技术发展最新水平</p>
<p>from a benchmarking point of view: 从基准的角度来看</p>
<p>be inspired by: 受…启发</p>
<p>an integral part of: 是…的整体部分</p>
<p>sub-sampling: 二次采样</p>
<p>negligible: 微不足道的</p>
<p>bilinear-interpolation: 双线性插值</p>
<p>structurally different: 结构上不同</p>
<p>instance of: 实例…</p>
<p>counterproductive: 反生产的，使达不到预期目的</p>
<p>experimentally show: 实验说明</p>
<p>substantial practical merit: 实质性的实际价值</p>
<p>computational expensive: 計算量大</p>
<p>effective and efficient: 高效有力的</p>
<p>to facilitate future research: 为了促进以后的研究…</p>
<p>outstanding performance</p>
]]></content>
      <tags>
        <tag>论文写作</tag>
      </tags>
  </entry>
  <entry>
    <title>科技论文例句收集（持续更新中……）</title>
    <url>/Blog/2018/01/24/paper-sentences/</url>
    <content><![CDATA[<ol>
<li><p>This architecture can model local pairwise feature interactions in a translationally invariant manner which is particularly useful for fine-grained categorization.</p>
</li>
<li><p>We present experiments with bilinear models where the feature extractors are based on convolutional neural networks.</p>
</li>
<li><p>Results show that the architecture compares favorably to the existing state of the art on a number of fine-grained datasets while being substantially simpler and easier to train.</p>
</li>
<li><p>Moreover, the architecture can be easily trained end-to-end unlike these texture descriptions leading to significant improvements in performance.</p>
</li>
<li><p>Significant accuracy gains in semantic segmentation have recently been obtained through the use of convolutional networks</p>
</li>
<li><p>Convolutional network architectures that had originally been developed for image classification can be successfully repurposed for dense prediction</p>
</li>
<li><p>The <strong>relentless success of</strong> deep learning techniques in various high-level computer vision tasks – in particular, supervised approaches such as Convolutional Neural Networks (CNNs) for image classification or object detection – motivated researchers to explore the capabilities of such networks for pixel-level labelling problems like semantic segmentation.</p>
</li>
<li><p>It is designed to be efficient both in terms of memory and computational time during inference.</p>
</li>
<li><p>We present a novel and practical … architecture for …</p>
</li>
<li><p>Sth. has a wide array of applications ranging from … to …</p>
<span id="more"></span></li>
<li><p>Sth. has seen huge success in …</p>
</li>
<li><p>Sth. is shown both qualitatively and quantitatively to…</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>论文写作</tag>
      </tags>
  </entry>
  <entry>
    <title>How to Write Research Papers (Part I)</title>
    <url>/Blog/2018/01/21/paperWriting/</url>
    <content><![CDATA[<p>本文基本参考 PPT <a href="https://people.engr.ncsu.edu/txie/publications/writepapers.pdf">How to Write Research Papers</a>，在论文写作套路方面也有导师给的一些私货。</p>
<blockquote>
<p>The key research contributions are the deciding factor for your paper’s acceptance.</p>
</blockquote>
<p>— 尽管论文写作有许多套路，但是论文能被接收的关键还是要看你的研究成果。</p>
<blockquote>
<p>Quality/impact over quantity of papers</p>
</blockquote>
<p>— 论文的质量远胜于质量。</p>
<span id="more"></span>
<h2 id="好论文的特征"><a href="#好论文的特征" class="headerlink" title="好论文的特征"></a>好论文的特征</h2><ul>
<li><strong>Interesting</strong> research (有趣的研究)<ul>
<li>提出有趣的问题</li>
<li>在问题的解决方法上提出了有趣的想法</li>
<li>在方法的评估上有有趣的发现</li>
</ul>
</li>
<li><strong>Novel</strong> research (新颖的研究，being the first)<ul>
<li>提出新的问题</li>
<li>提出新的解决方案</li>
<li>有新的发现</li>
</ul>
</li>
<li><strong>Inspiring</strong> research (研究推广，research generalization)<ul>
<li>Problem formulation，抽象化一类问题，使其能够描述类似的问题</li>
<li>Slution formulation，抽象化一类解，使其能够解决相似的问题</li>
</ul>
</li>
<li><strong>Impactful</strong> research (意义深远的研究)<ul>
<li>Impactful problem<ul>
<li>high severity level：impact an case seriously</li>
<li>large scope level：impact many cases</li>
</ul>
</li>
<li>Impactful solution，解决问题的高效（effective/efficient）方法<ul>
<li>发现前人研究中未发现的巨大漏洞</li>
<li>比前人的方法节省了 N 倍时间</li>
<li>能拿出实际的证据再好不过</li>
</ul>
</li>
</ul>
</li>
<li><strong>Rigorous/accurate</strong> description 严格/准确的描述<ul>
<li>准确的问题定义（无论是否形式化）</li>
<li>使用算法和实例详细描述解决方案（<strong>不能只有实例！</strong>），达到可重现（reprodicible）的要求</li>
</ul>
</li>
<li><strong>Significant</strong> research (e.g., not easy problem to solve)<ul>
<li>Technical challenges 技术上的挑战<ul>
<li>问题的水平</li>
<li>解得水平</li>
</ul>
</li>
<li>智商上的碾压</li>
</ul>
</li>
<li><strong>Validated</strong> research<ul>
<li>Clear and strong (empirical) evidence to validate/justify the claims. 清晰而有力的证据</li>
</ul>
</li>
</ul>
<h2 id="Key-Questions-to-Double-Check-Your-Paper"><a href="#Key-Questions-to-Double-Check-Your-Paper" class="headerlink" title="Key Questions to Double Check Your Paper"></a>Key Questions to Double Check Your Paper</h2><p>① Is the research problem significant/important? (研究的问题的重要性)</p>
<blockquote>
<p><strong>YES</strong> a problem that people care (evidenced by concrete statistics or examples) (大家都关心的问题总是很有意义的)<br><strong>NO</strong> a problem created/imagined by you and no one else cares about it (冷门的问题研究比较危险)</p>
</blockquote>
<p>② Is your research solution significant or addressing technical challenges? (你的解决方案是否意义重大或者解决了技术上的难题)</p>
<blockquote>
<p><strong>NO</strong> a solution that is incremental over previous work (比前人方案复杂的解决方案并不受待见)<br><strong>NO</strong> a solution that is straightforward/trivial (解决方案过于简单或者性能轻微提升也是不行的)</p>
</blockquote>
<p>③ Is your evaluation justifying the claimed contributions or benefits of your solution? (你的评估手段是否能够准确体现你的解决方案对于问题的贡献）</p>
<blockquote>
<p>Double check by making traceability from your claims listed in your contributions to your research questions to investigate in your evaluation</p>
</blockquote>
<p>论文中涉及到的术语、观点、主张或者解决方案要有可追溯性。确保每一个 contribution/claim 都被适当地转化为了研究问题，没有未经证实的证据；确保每个问题都得到了适当地度量。</p>
<p><a href="http://en.wikipedia.org/wiki/GQM">GQM</a> ： 目标问题度量(Goal Question Metric)</p>
<p><strong>Traceability Links</strong></p>
<p><img src="http://static.zybuluo.com/guoxs/yuyo5v7kerlqo1oot154ir3s/001.png" alt="Traceability Links"></p>
<h2 id="Know-What-Your-Audience-is"><a href="#Know-What-Your-Audience-is" class="headerlink" title="Know What Your Audience is"></a>Know What Your Audience is</h2><p>明确的介绍你的论文与你要投的会议/期刊的相关性以及契合程度。</p>
<blockquote>
<p>E.g., if ICSM, explain clearly in abstract and intro how your work is related to maintenance; if WWW, explain clearly in abstract and intro how your work is related to web; …</p>
</blockquote>
<p>详细的解释你的工作中用到的一些基本假设/概念，即使这些在你所从事的领域里是最最基本的，但是你也不能够确定审稿人或者读者能够理解。</p>
<blockquote>
<p>E.g., if your approach is about achieving high structural coverage of code, need to explain why achieving high structural coverage is important</p>
</blockquote>
<h2 id="Justify-Your-Choices"><a href="#Justify-Your-Choices" class="headerlink" title="Justify Your Choices"></a>Justify Your Choices</h2><p>论文中药明确你做的任何一个选择。为什么你要提出一个新方法而不是用已有的方案？为什么你要选择这个方法解决你的问题而不是另一个可选方案？ 某种技术的使用与否对结果是否由影响，影响有多大？你的结果和前人研究结果相比新能提升多少？</p>
<p><strong>Pitfall</strong>：In intro sec, you describe that you propose a way of solutions to address your stated problem, BUT you never discuss why alternative way of solutions would not be chosen</p>
<p><strong>Pitfall</strong>: In approach sec, you describe that you use a technique to address a sub-problem in your approach, BUT you never discuss why alterative way of techniques would not be chosen</p>
<p><strong>Pitfall</strong>: In your evaluation sec, you don’t compare the results of including or not including an important technique claimed to be a major contribution</p>
<p><strong>Pitfall</strong>: in your evaluation sec, you don’t justify why you choose the experimental subjects or a subset of subjects used by previous work</p>
<h2 id="Don’t-Write-Too-Little-or-More-Than-Enough"><a href="#Don’t-Write-Too-Little-or-More-Than-Enough" class="headerlink" title="Don’t Write Too Little or More Than Enough"></a>Don’t Write Too Little or More Than Enough</h2><p>文章的页数是有限制的，要严格按照期刊的要求，太多太少都不好。在某些很具体或者很 low-level 的细节上不要花太多笔墨，而在一些重要的思想、实验结果等方面要着重叙述。</p>
<p>Need balance on reproducibility (可重现性) and new idea/research contributions</p>
<blockquote>
<p>E.g. solution: separation of approach and implementation sections (方法与实现分离，附源码…)</p>
</blockquote>
<h2 id="Formalize-Just-Enough"><a href="#Formalize-Just-Enough" class="headerlink" title="Formalize Just Enough"></a>Formalize Just Enough</h2><p>适当的形式化。形式化定义，算法…</p>
<p>Formalization helps</p>
<ul>
<li>write clearly and force you to think and write rigorously</li>
<li>help grasp problem/solution essence, avoid shooting moving targets</li>
</ul>
<p>但是不要过分形式化，形式化的目的是为了让审稿人/读者更容易理解，而不是增加阅读难度。</p>
<h2 id="Technical-Challenges"><a href="#Technical-Challenges" class="headerlink" title="Technical Challenges"></a>Technical Challenges</h2><h3 id="Why-list-challenges"><a href="#Why-list-challenges" class="headerlink" title="Why list challenges?"></a>Why list challenges?</h3><p>论文中列出技术挑战有利于体现论文的成果以及重要性，审稿人/读者不会被一些简单的解决方案打动。</p>
<p>主要可以从两个方面列举</p>
<ul>
<li>Problem-level challenges，解决问题有哪些挑战？</li>
<li>Solution-level challenges，执行解决问题的方案有哪些挑战？</li>
</ul>
<h3 id="Simple-vs-Sophisticated-Solutions"><a href="#Simple-vs-Sophisticated-Solutions" class="headerlink" title="Simple vs. Sophisticated Solutions"></a>Simple vs. Sophisticated Solutions</h3><p>求解复杂问题时不要忽视简单的、最直接的解决方案（例如枚举法），最简单的解决方案可以作为评估中的 baseline。</p>
<blockquote>
<p>“Make things as simple as possible, but not simpler.” - Einstein</p>
</blockquote>
<h3 id="Challenges-→-Contribution-Points"><a href="#Challenges-→-Contribution-Points" class="headerlink" title="Challenges → Contribution Points"></a>Challenges → Contribution Points</h3><p>contribution list 的一般结构：</p>
<ul>
<li>The overall approach</li>
<li>A list of specific techniques in the approach</li>
<li>Implementation and evaluation</li>
<li>Evaluation results</li>
</ul>
<p>对于贡献列表中的每一项技术，至少应该有一个明确的技术挑战，或者也可以将整个方法表述为技术上的挑战。</p>
<h2 id="附：导师关于写论文的小-Tips-【更新中】"><a href="#附：导师关于写论文的小-Tips-【更新中】" class="headerlink" title="附：导师关于写论文的小 Tips 【更新中】"></a>附：导师关于写论文的小 Tips 【更新中】</h2><ul>
<li>论文的 Abstract 不要超过 5 句话，介绍论文涉及到的领域现状，你要解决的问题现状，前人的研究进展怎样，你用了什么方法解决问题，取得了怎样的效果……一句话也不宜太长，5句话差不多就10行；</li>
<li>每一段要有中心句，很 detail 的解释不宜放在 Abstract 中；</li>
<li>论文一般不用主动语态，用被动语句，我们解决的是客观的问题；</li>
<li>遇到模棱两可的词一定要查字典，推荐 <a href="https://dictionary.cambridge.org/">Cambridge Dictionary</a></li>
<li>多用连接词，however，on constract，whereas…</li>
<li>针对不同的期刊会议，在 Introduction 中有不同的策略；</li>
<li>一段不宜太长，太长意味着一段有多个中心句。一段话只说一个事情；</li>
<li>注意文章字体，figure 的字体和大小；</li>
<li>论文 figure 尽量不要使用 powerpoint/excel 做，推荐使用 <a href="https://tug.org/PSTricks/main.cgi/">PSTricks</a></li>
<li>注意 figure 使用的语义，特别是流程图，不同的形状的语义要统一；figure 不宜过长，figure 字体要和中文统一；figure 占用空间要仔细斟酌，寸土寸金</li>
<li>注意 figure caption 的写法，一般看 caption 就能够使读者了解整幅图要表达的意思</li>
<li>能够用表格表示的就不要用文字，能够用图表示的就不要用表格</li>
<li>类似的图不要太多</li>
<li>多做量化结果</li>
<li>提到帧率一定要说要说在哪个硬件上</li>
<li>说多少倍 小于10 写数字，大于 10 写文字</li>
<li>专有名词如果不是太普遍要在论文中加定义</li>
<li>several/some 等非定量词最好不要用，very 不要用 替代：significantly</li>
<li>great amount -&gt; huge amount，最好用中性的词</li>
</ul>
]]></content>
      <tags>
        <tag>论文写作</tag>
      </tags>
  </entry>
  <entry>
    <title>How to Write Research Papers (Part II)</title>
    <url>/Blog/2018/01/21/paperWritingCons/</url>
    <content><![CDATA[<p>典型的科技论文结构如下：</p>
<ul>
<li>Title/Abstract</li>
<li>Introduction</li>
<li>Optional: Background</li>
<li>Optional: Formal Problem Definition</li>
<li>Related Work (alternatively put before conclusion)</li>
<li>Example</li>
<li>Approach/Framework</li>
<li>Implementation</li>
<li>Evaluation<ul>
<li>Experiment/Case Studies/Experiences/Examples</li>
</ul>
</li>
<li>Discussion</li>
<li>Conclusions (and Future work)</li>
</ul>
<p>下面将论文分解，按点一一介绍其结构以及写作时的注意事项。<br><span id="more"></span></p>
<h2 id="Title-and-Abstract"><a href="#Title-and-Abstract" class="headerlink" title="Title and Abstract"></a>Title and Abstract</h2><p>标题和概述就相当于一个人的脸，一个让人印象深刻的标题和简明扼要的概述是十分重要的，这直接影响了审稿人或读者是否有继续看下去的意愿。</p>
<p><strong>Title writing</strong></p>
<ul>
<li><p>不要使用不常用的时髦词 (uncommon buzzwords)</p>
<blockquote>
<p>这有利于读者通过阅读标题了解文章大致内容</p>
</blockquote>
</li>
<li><p>要具体，但不要太具体 (Be specific enough but not too specific)</p>
</li>
<li>给你的方法一个好名字 (Name your approach with a cute name)<blockquote>
<p>这方便别人记住和引用</p>
</blockquote>
</li>
</ul>
<p><strong>Abstract structure</strong></p>
<ul>
<li>Short motivation (problem)</li>
<li>Proposed solution</li>
<li>Evaluation</li>
<li>Evaluation results</li>
</ul>
<blockquote>
<p>介绍你研究的问题，说明针对这个问题你提出了什么解决方法，你是怎么评估你的方法的好坏，评估的结果怎么样…</p>
</blockquote>
<p><strong>Abstract writing</strong></p>
<ul>
<li>Don’t put unexplained or undefined terms whose meanings are not well known</li>
<li>Solutions: explain them; rephrase them using plain words; not get into too much detail (without mentioning them).</li>
</ul>
<blockquote>
<p>不要使用无法解释或者未定义的、意义不明的术语，可以组织语言重新措辞，避开这些模棱两可的词语</p>
</blockquote>
<h2 id="Introduction-Part"><a href="#Introduction-Part" class="headerlink" title="Introduction Part"></a>Introduction Part</h2><h3 id="Introduction-Structure"><a href="#Introduction-Structure" class="headerlink" title="Introduction Structure"></a>Introduction Structure</h3><ul>
<li>领域长期的动向，需要解决的问题，为什么现有的解决方案不行，存在那些不足…(可以举例说明)</li>
<li>说明你研究的问题的重要性，需要使用具体的统计数据、具体的例子或者引用</li>
<li>建议的解决方案（输入/输出）和关键思想（步骤）</li>
<li>（可选）简短介绍相关的研究并且说明差异</li>
<li>Evaluation and evaluation results (评估和评估结果)</li>
<li>（可选）The paper makes the following main contributions: + 分项列出，这方便审稿人抓住重点，哪个是主要贡献</li>
<li>页面结构布局，可以向读者展示不同部分的关联，这在论文的其他部分也同样适用。</li>
</ul>
<h3 id="Introduction-pitfall"><a href="#Introduction-pitfall" class="headerlink" title="Introduction pitfall"></a>Introduction pitfall</h3><ul>
<li>不要花费过分笔墨叙述 (even throughout the paper)<ul>
<li>可以使用流程图/示意图来展示你的工作</li>
<li>但是需要着重强调问题的重要性以及你的解决方案</li>
</ul>
</li>
<li>不要过多引用别人的工作 (even throughout the paper)</li>
<li>如果想提出一些已经证实的想法(unjustified points)，最好是将其放在 conclusion 或者 discussion 部分</li>
<li>注意措辞和单词拼写</li>
</ul>
<blockquote>
<p>X “Our approach provides a foundation for this new field.”<br>“We believe our approach can provide a foundation…”<br>“We believe our approach has a good potential for providing a foundation …”</p>
</blockquote>
<p>另一个例子：</p>
<blockquote>
<p>X “Our/X’s approach is the only/first one on ….”<br>“With the best of our knowledge, our/X’s approach is the only one/first on …”<br>“Our/X’s approach is one of the/a few approaches …”<br>“Our/X’s approach is a major/representative approach …”</p>
</blockquote>
<p>另外一个需要注意的问题是，有些审稿人很厌烦你自己说你的方法是 “<strong>novel</strong>“ 的，他们认为<br>你的方法 “novel” 不 “novel” 这个问题是由他们决定的，而不是你说了算。所以不要强调你的方法很<br>“novel”，或者至少不要将 <strong>“novel”</strong> 这个词放在你的论文中！</p>
<blockquote>
<p>“TestEra: A Novel Framework for Automated Testing of Java Programs” → “TestEra: Specification-based Testing of Java Programs Using SAT”</p>
</blockquote>
<h3 id="Stirewalt’s-5-paragraph-rule-on-writing-Introduction"><a href="#Stirewalt’s-5-paragraph-rule-on-writing-Introduction" class="headerlink" title="Stirewalt’s 5-paragraph rule on writing Introduction"></a>Stirewalt’s 5-paragraph rule on writing Introduction</h3><p><a href="http://www.cse.msu.edu/~chengb/Writing/intro-guidelines-stirewalt.txt">Stirewalt’s 5-paragraph rule</a></p>
<ul>
<li><p><strong>Introductory paragraph</strong>: Very briefly: What is the problem and why is it relevant to the audience attending <em>THIS CONFERENCE</em>? Moreover, why is the problem hard, and what is your solution? You must be brief here. This forces you to boil down your contribution to its bare essence and communicate it directly.</p>
<blockquote>
<p>引言段。非常简短：问题是什么？为什么与这次会议有关？为什么这个问题很难解决？你的解决方案是什么？这里必须做简短介绍，你需要直接说明你的贡献.</p>
</blockquote>
</li>
<li><p><strong>Background paragraph</strong>: Elaborate on why the problem is hard, critically examining prior work, trying to tease out one or two central shortcomings that your solution overcomes.</p>
<blockquote>
<p>相关背景介绍段。详细说明为什么这个问题是困难的，仔细考究前人的工作，试着找出你的解决方案克服的一两个主要缺点。</p>
</blockquote>
</li>
<li><p><strong>Transition paragraph</strong>: What keen insight did you apply to overcome the shortcomings of other approaches? Structure this paragraph like a syllogism: Whereas P and P =&gt; Q, infer Q.</p>
<blockquote>
<p>过渡段，你的方法能够克服缺点的原因原因的什么？方法的关键思想是什么？这个段的结构类似于三段论：P and P =&gt; Q，则 Q。</p>
</blockquote>
</li>
<li><p><strong>Details paragraph</strong>: What technical challenges did you have to overcome and what kinds of validation did you perform?</p>
<blockquote>
<p>细节段，你需要克服哪些技术难题？你使用的验证方案又是什么？</p>
</blockquote>
</li>
<li><p><strong>Assessment paragraph</strong>: Assess your results and briefly state the broadly interesting conclusions that these results support. This may only take a couple of sentences. I usually then follow these sentences by an optional overview of the structure of the paper with interleaved section callouts.</p>
<blockquote>
<p>评估段， 评估你的结果，并简要说明这些结果所引出的关键结论。这可能只需要几句话，之后还可以对整篇文章结构做一个概述。</p>
</blockquote>
</li>
</ul>
<p><strong><a href="http://infolab.stanford.edu/~widom/paper-writing.html">The Stanford InfoLab’s patented five-point structure for Introductions</a></strong></p>
<ul>
<li>What is the problem?</li>
<li>Why is it <strong>interesting</strong> and <strong>important</strong>?</li>
<li>Why is it <strong>hard</strong>? (E.g., why do <strong>naive approaches</strong> fail?)</li>
<li>Why hasn’t it been <strong>solved</strong> before? (Or, what’s wrong with previous proposed solutions? How does mine <strong>differ</strong>?)</li>
<li>What are the key components of my approach and results? Also include any specific limitations.</li>
</ul>
<h3 id="Tell-a-Good-Story-in-Intro"><a href="#Tell-a-Good-Story-in-Intro" class="headerlink" title="Tell a Good Story in Intro"></a>Tell a Good Story in Intro</h3><p>Abstract 和 introduction 是非常重要的部分，通常审稿人可以通过阅读摘要和简介准确地判断这篇文章是接受还是拒绝。在这种情况下，我们需要在摘要和简介部分讲述一个有趣生动的故事（以正确和角度和恰当的抽象层次），使得读者忍不住往下读，这也能激发读者的求知欲。</p>
<blockquote>
<p>After finishing reading the short description of the target problem, they couldn’t predict what challenges or significant issues real world setting could face.</p>
<p>After finishing reading the description of your problem, they couldn’t predict what solutions you will provide (e.g., clever, neat ideas to address challenges)  → attract them to read on</p>
</blockquote>
<p><strong>Suggestion Actions Against Intro/Abstract</strong></p>
<ul>
<li>在小组讨论中反复迭代改进，可以大声朗读，听取小组成员的意见</li>
<li>注意 Abstract 部分句子的逻辑过渡以及 Introduction 部分段落的逻辑过渡，可以借助思维导图整理思路。</li>
<li>多次确认先前陈诉的特征是否满足<ul>
<li>例如：目标问题很重要…</li>
<li>例如：你的解决方案是很有优势的，解决了非平凡的技术难题，并且得到了很好的验证</li>
</ul>
</li>
</ul>
<h2 id="Problem-Definition-optional"><a href="#Problem-Definition-optional" class="headerlink" title="Problem Definition (optional)"></a>Problem Definition (optional)</h2><p>如果你的论文提出了一个新的问题或者解决了一个 formalizable 的问题，那么最好有一个<strong>问题定义</strong> (problem definition) 的部分。这样一节有助于清晰地描述论文所讨论的问题。</p>
<p>例如：<a href="https://people.engr.ncsu.edu/txie/publications/icse09-carminer.pdf">Mining Exception-Handling Rules as Sequence Association Rules</a></p>
<p><strong>Formal Problem Definition</strong></p>
<ul>
<li>定义你的方法想要解决的问题</li>
<li>可以放在 intro/example 部分之后的一个部分，为之后的示例目的部分服务</li>
<li>可以在这部分正式定义你的方法中提到的一些重要概念（问题空间或解空间的概念）。</li>
<li>将问题规范化于是论文的贡献之一。</li>
</ul>
<p>以下审稿人关于 formal definition 部分的意见很有借鉴意义：</p>
<blockquote>
<ol>
<li><p>“Section 3, the formal definition, is not very well organized. A formal definition can be useful and clarifying, but in that case ought to be crisp, clear, and elegant. To my taste your definitions are a bit messy”</p>
</li>
<li><p>“Definition 1 is not really a definition”</p>
</li>
<li><p>“It is also interesting to see that you don’t use your formal definition in the rest of the paper.”</p>
</li>
<li><p>“I am not sure what the formalization of XXX adds. It seems rather disconnected to the rest of the paper.”</p>
</li>
</ol>
</blockquote>
<h2 id="Background-and-Related-Work"><a href="#Background-and-Related-Work" class="headerlink" title="Background and Related Work"></a>Background and Related Work</h2><p><strong>Background</strong> 有时也叫作 <strong>Preliminaries</strong>，包括 notion，teminology 或者你以前的工作等。</p>
<p> <strong>Related Work</strong></p>
<ul>
<li><p>不要简单的列出相关的工作而不涉及你自己的工作</p>
<ul>
<li>keywords to use：whereas、in contrast、but、however</li>
<li>“excuses” to use: “does not require specs”, “focus on different problems”, “complement with each other”, …</li>
<li>可以简单描述几种类似的方法，并与你的方法作比较</li>
</ul>
</li>
<li><p>不要仅在解空间上列举你的工作与相关工作之间的差异，也需要考虑问题空间的对比</p>
</li>
</ul>
<p><strong>related work</strong> 部分应该放在 introduction/example 部分之后，在 conclusion 部分之前。（放在 example 之后也是可以的）</p>
<ul>
<li>After the introduction/example section<ul>
<li>Pros: Immediately clear out reviewers’ wonder on how the work differs from previous work</li>
<li>Cons: hard to let readers to know what you are talking about before showing the approach details</li>
</ul>
</li>
<li>Before the conclusion section<ul>
<li>Pros: Now reviewers’ know what your approach is about</li>
<li>Cons: reviewers keep wondering how the work differs from previous work till this point</li>
</ul>
</li>
</ul>
<blockquote>
<p>对于非常相关的工作，应该在 introduction 部分指出差异</p>
</blockquote>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ul>
<li>A simple example<ul>
<li>Include: where it comes from; a figure listing source code; brief description</li>
<li>Throughout the paper, it is important to have illustrating examples for those places that contain “dry” descriptions of your approach</li>
<li>If you use several examples throughout the paper, you may not need a separate Example section.</li>
</ul>
</li>
<li>Optional/important part of the section: high level description of applying your approach on the example<ul>
<li>describe inputs/outputs of your approach without getting into too much detail</li>
<li>very important if the later approach description involves heavy hard-to-understand formalisms</li>
</ul>
</li>
</ul>
<h2 id="Approach-or-Framework"><a href="#Approach-or-Framework" class="headerlink" title="Approach or Framework"></a>Approach or Framework</h2><ul>
<li>在抽象层上概括你的工作，比如概括为“框架”、“算法”而不是工具<ul>
<li>What you develop should be beyond your own implementation</li>
<li>A workflow diagram is useful for explaining your framework</li>
</ul>
</li>
<li>理念与具体实现分离</li>
<li>细节方面最好用示例解释</li>
</ul>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><ul>
<li>What libraries you used in your tool</li>
<li>Detailed implementations of each step in your framework</li>
<li>List complications of implementing a certain idea and how you get around them<ul>
<li>if some complications are important and general, you may move them to the framework section</li>
</ul>
</li>
<li>Applicable to both approach/implementation</li>
</ul>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><h3 id="实验部分写作结构"><a href="#实验部分写作结构" class="headerlink" title="实验部分写作结构"></a>实验部分写作结构</h3><ul>
<li><p>Hypotheses/Questions to be answered</p>
<blockquote>
<p>Double check your questions. Ex. “<strong>Can</strong> our approach perform better than a previous related approach?” → “<strong>How much better</strong> can our approach perform than …”</p>
</blockquote>
</li>
<li><p>Measures you use to answer these questions (higher better?)</p>
</li>
<li><p>Experiment setup</p>
<blockquote>
<p>a good number of subjects, some scripts, some third-party tools or reimplemented tools for comparison</p>
</blockquote>
</li>
<li><p>Independent variables+dependent variables → metrics</p>
</li>
<li>Experimental results<ul>
<li>Illustrate how to read your table/diagrams</li>
<li>Explain what does the curve or data mean，e.g. “We observed that …”, “The experimental results show”</li>
<li>Summarize your findings, remember to get back to answer the hypotheses and questions</li>
<li>Optional: discussion subsection</li>
</ul>
</li>
<li>Sometimes you may not include cost (time/memory) in your experimental results but you need to at least discuss the analysis cost</li>
<li>Threats to validity: internal, external, and construct, sometimes may not need that fined-grained type classification</li>
<li>In the experimental results, need describe how the results relate back to which hypotheses and how hypotheses relate back to which research questions</li>
</ul>
<blockquote>
<p>When using colored figures, make sure you describe both colors and gray-scale in text (since people may read papers in black-white copy)</p>
</blockquote>
<h3 id="评估部分"><a href="#评估部分" class="headerlink" title="评估部分"></a>评估部分</h3><ul>
<li><p>Need explain evaluation results or describe your insights from the observed results rather than just describing the results</p>
<blockquote>
<p>if some subjects’ results are especially favorable or unfavorable, explain the reasons or even your hypothesis (“We suspect that …”  “We hypothesize that …”)</p>
</blockquote>
</li>
<li><p>Need describe “Experiment Designs”</p>
</li>
<li>Need hypothesis testing, t-testing especially if you want to say “A result is <strong>significantly</strong> better than B result”; <strong>statistically significant vs. practically significant</strong></li>
<li>Using “benchmarks”</li>
<li>Measure both mean and variance/deviation, not just mean</li>
</ul>
<blockquote>
<p>Tips: Construct a project web including the evaluation subjects, evaluation results, Building <strong>trust</strong> from reviewers in your work and your results.</p>
</blockquote>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><ul>
<li>Limitations and issues your approach/implementation currently cannot address<ul>
<li>Optional: how are you going to address them in future work</li>
</ul>
</li>
<li>Other caveats (scope of your approach)</li>
<li>It is often a good idea to list (obvious) limitations and discuss possible solutions for them rather than hiding them</li>
<li>Possible applications of your approach that you haven’t validated but are convincingly feasible or effective</li>
</ul>
<blockquote>
<p>Under what situations your proposed solution would achieve the best results and under what situations your proposed solution would achieve the worst results</p>
</blockquote>
<h2 id="Conclusions-and-Future-Work"><a href="#Conclusions-and-Future-Work" class="headerlink" title="Conclusions (and Future Work)"></a>Conclusions (and Future Work)</h2><p>这个部分只需要简单的总结你的工作。</p>
<blockquote>
<p>In the introduction: “We propose a new approach …”<br>In the conclusions: “We have proposed a new approach …”</p>
</blockquote>
<p>也可以描述你的方法的应用场景以及未来的改进方向。</p>
<blockquote>
<p>“We are currently doing X…, and preliminary results are promising.”</p>
</blockquote>
<p>最后就是 Acknowledgments.</p>
]]></content>
      <tags>
        <tag>论文写作</tag>
      </tags>
  </entry>
  <entry>
    <title>寄存器（数据存储）</title>
    <url>/Blog/2016/06/23/register/</url>
    <content><![CDATA[<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>看操作系统的书发现需要补一补汇编的知识，于是上网找了一本好评度很高的汇编语言教科书，抽空恶补。</p>
<ul>
<li>汇编语言是机器指令的助记符，同机器指令一一对应。</li>
<li>每一种CPU都有自己的汇编指令集。</li>
<li>CPU可以直接使用的信息在存储器中存放。</li>
<li>在存储器中指令与数据没有任何区别，都是二进制信息。</li>
<li>存储单元从零开始顺序编号。</li>
</ul>
<span id="more"></span>
<blockquote>
<p>每一个CPU芯片都有许多管脚，这些管脚与总线相连。也就是说，这些管脚引出总线。一个CPU可以引出3种总线的宽度标志着这个CPU不同方面的性能：<br><code>地址总线</code>： 地址总线的宽度决定CPU的寻址能力；<br><code>数据总线</code>： 数据总线的宽度决定CPU与其他器件传送时的一次数据传送量；<br><code>控制总线</code>： 控制总线的宽度决定CPU对系统中其他器件的控制能力。</p>
</blockquote>
<h3 id="各类存储器芯片"><a href="#各类存储器芯片" class="headerlink" title="各类存储器芯片"></a>各类存储器芯片</h3><ul>
<li>随机存储器</li>
<li>装有BIOS的ROM</li>
<li>接口卡上的RAM</li>
</ul>
<p>PC机中各类存储器的逻辑连接<br><img src="http://static.zybuluo.com/guoxs/8mo43da65qx4g2n5pfswerz7/1.png" alt="PC机中各类存储器的逻辑连接"></p>
<h3 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h3><p>上述存储器在物理上是独立的器件，但是有两点是相同的：</p>
<ul>
<li>都与CPU的总线连接</li>
<li>CPU对它们进行读或写的时候都通过控制线发出内存读写命令</li>
</ul>
<p>将各类存储器看做一个逻辑存储器：<br><img src="http://static.zybuluo.com/guoxs/wp7yvs8o4anzz0ub3rhmq867/2.png" alt="将各类存储器看做一个逻辑存储器"></p>
<p>上图中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储单元在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</p>
<p>不同的计算机系统内存地址空间的分配情况是不同的，对于8086PC 机，其内存地址空间分配如下图所示：</p>
<p><img src="http://static.zybuluo.com/guoxs/rh19kh5t9g9v8twppajm493n/3.png" alt="8086PC其内存地址空间分配"></p>
<p>从图中可知，从地址0~9FFFF的内存单元中读取数据，实际上就是在读取主随机存储器中的数据；向地址A0000~BFFFF的内存单元写数据，就是向显卡中写入数据，这些数据会被显示卡输出到显示器上；向地址C0000~FFFFF的内存单元写入数据是无效的，因为这等于改写只读存储器中的内容。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>不同的CPU，寄存器的个数，结构是不相同的。8086 CPU有14个寄存器，每个寄存器都有一个名称，这些寄存器是：AX BX CX DX SI DI SP BP IP CS SS DS ES PSW。</p>
<p>8086 CPU的所有寄存器都是16位的，可以存储两个字节。AX BX CX DX 这四个寄存器通常用来存放一般性数据，被称为通用寄存器。</p>
<p>8086 为了兼容上一代8位寄存器，使AX BX  CX DX 这四个寄存器都可以分为两个可独立使用的8位寄存器来使用：</p>
<ul>
<li>AX可分为AH和AL;</li>
<li>BX可分为BH和BL;</li>
<li>CX可分为CH和CL;</li>
<li>DX可分为DH和DL;</li>
</ul>
<p>其结构如图所示：<br><img src="http://static.zybuluo.com/guoxs/i6yzffmb619xm4g7un9ss17z/4.png" alt="AX可分为AH和AL"></p>
<p>数据在其中的存储情况：<br><img src="http://static.zybuluo.com/guoxs/nit10xycos27yqd1geozhpsv/5.png" alt="数据在其中的存储情况"></p>
<h3 id="几条基本汇编指令"><a href="#几条基本汇编指令" class="headerlink" title="几条基本汇编指令"></a>几条基本汇编指令</h3><p><img src="http://static.zybuluo.com/guoxs/s8fs1a36j9bkpblnwgp3rrzr/6.png" alt="汇编指令举例"></p>
<h3 id="8086CPU给出物理地址的方法"><a href="#8086CPU给出物理地址的方法" class="headerlink" title="8086CPU给出物理地址的方法"></a>8086CPU给出物理地址的方法</h3><p><img src="http://static.zybuluo.com/guoxs/lha4s7n5oioew4ls70czmv0x/7.png" alt="8086CPU给出物理地址的方法"></p>
<p>如图所示，8086CPU要读写内存时：</p>
<ul>
<li>CPU中的相关部件提供两个16位的地址，一个称谓段地址，一个称为偏移地址；</li>
<li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；</li>
<li>机制加法器将两个16位地址合成一个20位的物理地址；</li>
<li>20位物理地址被送入输入输出控制电路；</li>
<li>输入输出控制电路将20位物理地址送上地址总线；</li>
<li>20位物理地址被地址总线传送到存储器。</li>
</ul>
<p>地址加法器采用<strong>物理地址 = 段地址×16 + 偏移地址</strong>的方法合成物理地址。</p>
<h3 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h3><p>内存中并没有分段，段的划分来自于CPU。<br><img src="http://static.zybuluo.com/guoxs/ea243l2n4m0saoq3boab1rsy/8.png" alt="分段"></p>
<blockquote>
<p>注意: 段地址×16必然是16的倍数，所以一个段的起始地址也一定是16的倍数，偏移地址也是16位，16位的寻址能力是64KB，所以一个段的长度最大为64KB。</p>
</blockquote>
<h3 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h3><p>CS和IP是8086CPU中两个最关键的寄存器，他们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器。<strong>在任何时刻，CPU将CS:IP指向的内容当做指令执行。</strong></p>
<blockquote>
<p>每读取一条指令，IP值自动加1，以使CPU可以读取下一条指令。</p>
</blockquote>
<p>8086CPU的工作过程可以简要概述如下：</p>
<ul>
<li><ol>
<li>从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器；</li>
</ol>
</li>
<li><ol>
<li>IP = IP + 所读取指令的长度，从而指向下一条指令；</li>
</ol>
</li>
<li><ol>
<li>执行指令，转到步骤1，重复这个过程。</li>
</ol>
</li>
</ul>
<p><img src="http://static.zybuluo.com/guoxs/3wtz8y4af623bq7y8hepr4sm/9.png" alt="8086CPU的工作过程"></p>
<blockquote>
<p>在8086CPU 加电启动或复位后（即CPU刚开始工作时），CS和IP被设置为CS = FFFFH, IP = 0000H; 即在8086PC刚启动是，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。</p>
</blockquote>
<p><strong>修改CS、IP中的指令</strong><br><code>jump 段地址：偏移地址</code> ： 用指令中给出的段地址修改CS，偏移地址修改IP。<br>若想只修改IP的值，可用形如： <strong>jmp 某一合法寄存器</strong>的指令来完成。</p>
<blockquote>
<p>jmp ax == mov IP,ax</p>
</blockquote>
]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/Blog/2016/09/03/sort/</url>
    <content><![CDATA[<p>参考文章：<a href="http://blog.csdn.net/amazing7/article/details/51603682">http://blog.csdn.net/amazing7/article/details/51603682</a></p>
<p>排序算法总结：<br><img src="http://static.zybuluo.com/guoxs/f2hpk3xr8b8rz6zlbw4uk9l6/20160607144411150" alt="对比分析图"><br><span id="more"></span></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>　重复走访要排序的数列，一次比较两个元素，如果顺序错误则交换，直到没有再需要交换的元素为止。每一轮都有一个最小的数字在正确的位置上。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	Boolean flag = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">int</span> len = arr.length;</span><br><span class="line">	<span class="keyword">while</span>(flag)&#123;</span><br><span class="line">		flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">					swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">					flag = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		len--;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>所排序序列的记录个数为n，i取1,2,…,n-1。从所有n-i+1个记录（Ri,Ri+1,…,Rn）中找出排序码最小（或最大）的记录，与第i个记录交换。执行n-1趟后就完成了记录序列的排序。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = arr.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> min = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class="line">				min = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(min != i)&#123;</span><br><span class="line">			swap(arr,min,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在简单选择排序过程中，所需移动记录的次数比较少。最好情况下，即待排序记录初始状态就已经是<strong>正序</strong>排列了，则不需要移动记录。</p>
<p>最坏情况下，即待排序记录初始状态是按<strong>第一条记录最大，之后的记录从小到大顺序排列</strong>，则需要移动记录的次数最多为3（n-1）。</p>
<p>简单选择排序过程中需要进行的<strong>比较次数</strong>与初始状态下待排序的记录序列的排列情况无关。</p>
<p>当i=1时，需进行n-1次比较；当i=2时，需进行n-2次比较；依次类推，共需要进行的比较次数是 n(n-1)/2，即进行比较操作的时间复杂度为O(n^2)，进行移动操作的时间复杂度为O(n)。　</p>
<p>简单选择排序是不稳定排序。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是指利用<strong>堆</strong>这种数据结构所设计的一种排序算法。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值。<br>堆每次只能取得根节点元素，以大顶堆为例，第一次0号为最大的元素，取出0号元素，最后一个元素补在0号位置上，重建大顶堆。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] number = &#123;<span class="number">95</span>,<span class="number">45</span>,<span class="number">15</span>,<span class="number">78</span>,-<span class="number">84</span>,<span class="number">51</span>,<span class="number">24</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">88</span>,<span class="number">4</span>,<span class="number">145</span>&#125;;</span><br><span class="line">		buildMaxHeapify(number);</span><br><span class="line">		heap_sort(number);</span><br><span class="line">		print(number);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeapify</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> startIndex = getParentIndex(data.length -<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = startIndex; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">			maxHeapify(data,data.length,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//末尾与头交换，交换后调整最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = data.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = data[<span class="number">0</span>];</span><br><span class="line">            data[<span class="number">0</span>] = data[i];</span><br><span class="line">            data[i] = temp;</span><br><span class="line">            maxHeapify(data, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建最大堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapSize需要创建最大堆的大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index当前需要创建最大堆的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> heapSize, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当前点与左右子节点比较</span></span><br><span class="line">        <span class="keyword">int</span> left = getChildLeftIndex(index);</span><br><span class="line">        <span class="keyword">int</span> right = getChildRightIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> largest = index;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; data[index] &lt; data[left]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; data[largest] &lt; data[right]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整</span></span><br><span class="line">        <span class="keyword">if</span> (largest != index) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = data[index];</span><br><span class="line">            data[index] = data[largest];</span><br><span class="line">            data[largest] = temp;</span><br><span class="line">            maxHeapify(data, heapSize, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父节点位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> current)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (current - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左子节点position注意括号，加法优先级更高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildLeftIndex</span><span class="params">(<span class="keyword">int</span> current)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右子节点position</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildRightIndex</span><span class="params">(<span class="keyword">int</span> current)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (current &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序法(缩小增量法) 属于插入类排序，是将整个无序列分割成若干小的子序列分别进行插入排序的方法。<br>把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> gap = <span class="number">1</span>;	<span class="comment">//记录步长</span></span><br><span class="line">	<span class="keyword">int</span> len = arr.length;</span><br><span class="line">	<span class="keyword">int</span> temp;		<span class="comment">//插入排序交换值的暂存</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(gap &lt; len / <span class="number">3</span>)&#123;</span><br><span class="line">		gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//循环遍历步长，最后必为1</span></span><br><span class="line">	<span class="keyword">for</span>(; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> i,j;</span><br><span class="line">		<span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">			temp = arr[i];</span><br><span class="line">			<span class="comment">//每一列中在a[i]上面且比a[i]大的元素依次向下移动</span></span><br><span class="line">			<span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">				arr[j + gap] = arr[j];</span><br><span class="line">			&#125;</span><br><span class="line">			arr[j + gap] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>希尔排序是一个不稳定的排序，其时间复杂度受<strong>步长</strong>（增量）的影响。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序采用分治法，各层递归可以同时进行。<br>归并排序速度<strong>仅次于快速排序</strong>，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。归并排序比较占用内存。</p>
<h3 id="归并排序的非递归算法"><a href="#归并排序的非递归算法" class="headerlink" title="归并排序的非递归算法"></a>归并排序的非递归算法</h3><p>① 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>② 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>③ 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>④ 重复步骤③直到某一指针到达序列尾<br>⑤ 将另一序列剩下的所有元素直接复制到合并序列尾<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort_iterator</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = arr.length;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	<span class="keyword">int</span> block,start;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//两两合并后块大小变大两倍 (注意最后一次block等于len)</span></span><br><span class="line">	<span class="keyword">for</span>(block = <span class="number">1</span>; block &lt;= len; block *= <span class="number">2</span>)&#123;</span><br><span class="line">		 <span class="comment">//把整个数组分成很多个块，每次合并处理两个块</span></span><br><span class="line">		<span class="keyword">for</span>(start = <span class="number">0</span>; start &lt; len; start += <span class="number">2</span>*block)&#123;</span><br><span class="line">			<span class="keyword">int</span> low = start;</span><br><span class="line">			<span class="keyword">int</span> mid = (start + block) &lt; len ? (start + block) : len;</span><br><span class="line">			<span class="keyword">int</span> high = (start + <span class="number">2</span>*block) &lt; len ? (start + <span class="number">2</span>*block) : len;</span><br><span class="line">			 <span class="comment">//两个块的起始下标及结束下标</span></span><br><span class="line">            <span class="keyword">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="keyword">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="comment">//开始对两个block进行归并排序</span></span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2) &#123;</span><br><span class="line">                result[low++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(start1 &lt; end1) &#123;</span><br><span class="line">                result[low++] = arr[start1++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(start2 &lt; end2) &#123;</span><br><span class="line">                result[low++] = arr[start2++];</span><br><span class="line">            &#125;       </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//每次归并后把结果result存入arr中，以便进行下次归并</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = arr;</span><br><span class="line">        arr = result;</span><br><span class="line">        result = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="归并排序的递归实现"><a href="#归并排序的递归实现" class="headerlink" title="归并排序的递归实现"></a>归并排序的递归实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = arr.length;</span><br><span class="line">	<span class="keyword">int</span>[] reg = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	binary_sort(arr,reg,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binary_sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] reg, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">	<span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line">	<span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">	<span class="comment">//递归到子序列只有一个数的时候，开始逐个返回</span></span><br><span class="line">	binary_sort(arr, reg, start1, end1);</span><br><span class="line">	binary_sort(arr, reg, start2, end2);</span><br><span class="line">	<span class="comment">//-------合并操作，必须在递归之后（子序列有序的基础上）-------</span></span><br><span class="line">	<span class="keyword">int</span> k = start;</span><br><span class="line">	<span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) &#123;</span><br><span class="line">		reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(start1 &lt;= end1) &#123;</span><br><span class="line">    	reg[k++] = arr[start1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(start2 &lt;= end2) &#123;</span><br><span class="line">    	reg[k++] = arr[start2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//借用reg数组做合并，然后把数据存回arr中</span></span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= end; k++)&#123;</span><br><span class="line">    	arr[k] = reg[k];</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是对冒泡排序的一种改进，又称划分交换排序。快速排序使用分治法策略来把一个序列（list）分为两个子序列（sub-lists）。</p>
<p>基本步骤为：<br>① 从数列中挑出一个元素，称为<strong>基准</strong>（pivot）<br>② 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为<strong>分区</strong>（partition）操作。<br>③ 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序</p>
<blockquote>
<p>在平均状况下，排序n个项目要<strong>Ο(nlogn)</strong>次比较。在最坏状况下则需要Ο(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(nlogn)算法更快，因为它的<strong>内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = getMiddle(arr,low,high);</span><br><span class="line">		quick_sort(arr, low, mid - <span class="number">1</span>);</span><br><span class="line">		quick_sort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMiddle</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = arr[low];</span><br><span class="line">	<span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt;= temp)&#123;</span><br><span class="line">			high --;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[low] = arr[high];</span><br><span class="line">		<span class="keyword">while</span>(low &lt; high &amp;&amp; arr[low] &lt;= temp)&#123;</span><br><span class="line">			low ++;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[high] = arr[low];</span><br><span class="line">	&#125;</span><br><span class="line">	arr[low] = temp;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>输入是由一个随机过程产生的[0,1)区间上均匀分布的实数。将区间[0,1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)，[1/n,2/n)，[2/n,3/n)，…，[k/n,(k+1)/n)，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n]&lt; 1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。</p>
<p><img src="http://static.zybuluo.com/guoxs/777ogd5g1fuhisrskgl2u2u6/1.jpg" alt="桶排序"><br>平均情况下桶排序以线性时间运行，桶排序是稳定的，排序非常快,但是同时也非常耗空间,基本上是<strong>最耗空间</strong>的一种排序算法。</p>
<p>提高桶排序的效率：</p>
<blockquote>
<p>① 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。　<br>②尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。 当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 对arr进行桶排序，排序结果仍放在arr中 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">double</span> arr[])</span></span>&#123;  </span><br><span class="line">	<span class="comment">//分桶     </span></span><br><span class="line">    <span class="keyword">int</span> n = arr.length;  </span><br><span class="line">    <span class="comment">//存放桶的链表</span></span><br><span class="line">	ArrayList bucketList[] = <span class="keyword">new</span> ArrayList [n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个桶是一个list，存放此桶的元素   </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;  </span><br><span class="line">        <span class="comment">//下取等</span></span><br><span class="line">        <span class="keyword">int</span> temp = (<span class="keyword">int</span>) Math.floor(n*arr[i]);  </span><br><span class="line">        <span class="comment">//若不存在该桶，就新建一个桶并加入到桶链表中</span></span><br><span class="line">        <span class="keyword">if</span>(bucketList[temp] == <span class="keyword">null</span>)  </span><br><span class="line">            bucketList[temp] = <span class="keyword">new</span> ArrayList();  </span><br><span class="line">        <span class="comment">//把当前元素加入到对应桶中</span></span><br><span class="line">        bucketList[temp].add(arr[i]);            </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//桶内排序  </span></span><br><span class="line">    <span class="comment">//对每个桶中的数进行插入排序   </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(bucketList[i] != <span class="keyword">null</span>)  </span><br><span class="line">            insert(bucketList[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//合并桶内数据</span></span><br><span class="line">    <span class="comment">//把各个桶的排序结果合并   </span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(bucketList[i] != <span class="keyword">null</span>)&#123;  </span><br><span class="line">            Iterator iter = bucketList[i].iterator();  </span><br><span class="line">            <span class="keyword">while</span>(iter.hasNext())&#123;  </span><br><span class="line">                Double d = (Double)iter.next();  </span><br><span class="line">                arr[count] = d;  </span><br><span class="line">                count++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 用插入排序对每个桶进行排序 </span></span><br><span class="line"><span class="comment"> * 从小到大排序</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(ArrayList list)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(list.size() &gt; <span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>((Double)list.get(i) &lt; (Double)list.get(i-<span class="number">1</span>))&#123;  </span><br><span class="line">                <span class="keyword">double</span> temp = (Double) list.get(i);  </span><br><span class="line">                <span class="keyword">int</span> j = i-<span class="number">1</span>;  </span><br><span class="line">                <span class="keyword">for</span>(; j &gt;= <span class="number">0</span> &amp;&amp; ((Double)list.get(j) &gt; (Double)list.get(j+<span class="number">1</span>)); j--)&#123;</span><br><span class="line">                	list.set(j+<span class="number">1</span>, list.get(j));  <span class="comment">//后移</span></span><br><span class="line">                &#125;                        </span><br><span class="line">                list.set(j+<span class="number">1</span>, temp);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="comment">//确定排序趟数</span></span><br><span class="line">	<span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">			max = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		max /= <span class="number">10</span>;</span><br><span class="line">		time ++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化10个链表</span></span><br><span class="line">	List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		List&lt;Integer&gt; item = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		list.add(item);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//进行time次分配与收集</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time; i++) &#123;</span><br><span class="line">		<span class="comment">//分配元素</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> index = arr[j] % (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i+<span class="number">1</span>) / (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i);</span><br><span class="line">			list.get(index).add(arr[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//收集元素</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(list.get(k).size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> a : list.get(k)) &#123;</span><br><span class="line">					arr[count] = a;</span><br><span class="line">					count ++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//清除数据，以便下次收集</span></span><br><span class="line">				list.get(k).clear();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，是稳定的排序方法。<br>插入排序又分为　<strong>直接插入排序</strong>　和 <strong>折半插入排序</strong>。</p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>把待排序的纪录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的纪录插入完为止，得到一个新的有序序列。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simple_insert_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;		<span class="comment">//当前要插入的位置</span></span><br><span class="line">	<span class="keyword">int</span> pre;	<span class="comment">//j前一个位置</span></span><br><span class="line">	<span class="keyword">int</span> key;	<span class="comment">//后移时来暂存要插入的值</span></span><br><span class="line">	<span class="keyword">int</span> len = arr.length;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">		key = arr[i];</span><br><span class="line">		pre = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(pre &gt;= <span class="number">0</span> &amp;&amp; arr[pre] &gt; key)&#123;</span><br><span class="line">			<span class="comment">//留出来一个空白位置来实现依次后移（不会造成数据丢失问题）</span></span><br><span class="line">			arr[pre+<span class="number">1</span>] = arr[pre];</span><br><span class="line">			pre--;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[pre+<span class="number">1</span>] = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>平均时间复杂度O(n^2)<br>最差情况：反序，需要移动n*(n-1)/2个元素 ，运行时间为O(n^2)。<br>最好情况：正序，不需要移动元素，运行时间为O(n)</p>
</blockquote>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>折半插入排序,使用使用<strong>折半查找</strong>的方式寻找插入点的位置, 可以减少比较的次数,但移动的次数不变, 时间复杂度和空间复杂度和直接插入排序一样，在元素较多的情况下能提高查找性能。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binary_insert_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = arr.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> key = arr[i];		<span class="comment">//暂存要插入的值</span></span><br><span class="line">		<span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> last = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(pre &lt;= last)&#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (pre + last)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(key &lt; arr[mid])&#123;</span><br><span class="line">				last = mid -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				pre = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//arr[i]已经取出来存放在key中，把下标从pre + 1到 i-1的元素依次后移</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= pre + <span class="number">1</span>; j--) &#123;</span><br><span class="line">			arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		arr[pre] = key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p><strong>计数排序的原理</strong>：设被排序的数组为A,排序后存储到B，C为临时数组。所谓计数，首先是通过一个数组C[i]计算大小等于i的元素个数，此过程只需要一次循环遍历就可以；在此基础上，计算小于或者等于i的元素个数，也是一重循环就完成。下一步是关键：逆序循环，从length[A]到1，将A[i]放到B中第C[A[i]]个位置上。原理是：C[A[i]]表示小于等于A[i]的元素个数，正好是A[i]排序后应该在的位置。而且从length[A]到1逆序循环，可以<strong>保证相同元素间的相对顺序不变</strong>，这也是计数排序稳定性的体现。在数组A有附件属性的时候，稳定性是非常重要的。</p>
<p><strong>计数排序的前提及适用范围</strong>: A中的元素不能大于k，而且元素要作为数组的下标，所以元素应该为非负整数。而且如果A中有很大的元素，不能够分配足够大的空间。所以计数排序有很大局限性，其主要适用于元素个数多，但是普遍不太大而且总小于k的情况，这种情况下使用计数排序可以获得很高的效率。</p>
<p><img src="http://static.zybuluo.com/guoxs/zh7jpkqigmlxm2eby46ve8vj/2.png" alt="计数排序"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] counting_sort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">	<span class="comment">//建立C数组</span></span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i &gt; max)&#123;</span><br><span class="line">			max = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span>[] C = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//建立B数组</span></span><br><span class="line">	<span class="keyword">int</span> length = arr.length;</span><br><span class="line">	<span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//统计A中各元素个数，存入C数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		C[arr[i]] ++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改C数组</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max+<span class="number">1</span>; i++) &#123;</span><br><span class="line">		sum += C[i];</span><br><span class="line">		C[i] = sum;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历A数组，构造B数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		B[C[arr[i]] - <span class="number">1</span>] = arr[i];</span><br><span class="line">		C[arr[i]]--;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>《Pro Git》学习笔记之分支</title>
    <url>/Blog/2016/06/27/the-branch-of-Pro-Git/</url>
    <content><![CDATA[<h2 id="何谓分支"><a href="#何谓分支" class="headerlink" title="何谓分支"></a>何谓分支</h2><h3 id="提交的数据结构"><a href="#提交的数据结构" class="headerlink" title="提交的数据结构"></a>提交的数据结构</h3><p>Git 保存的不是文件差异或者变化量，而只是一系列文件快照。在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。<br><span id="more"></span></p>
<p>当使用 <code>git commit</code> 新建一个提交对象前，Git 会先计算每一个子目录的校验和，然后在 Git 仓库中将这些目录保存为<strong>树（tree）对象</strong>。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。</p>
<p>单个提交对象在仓库中的数据结构：<br><img src="http://git.oschina.net/progit/figures/18333fig0301-tn.png" alt="单个提交对象在仓库中的数据结构"></p>
<p>多个提交对象之间的链接关系：<br><img src="http://git.oschina.net/progit/figures/18333fig0302-tn.png" alt="多个提交对象之间的链接关系"></p>
<h3 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h3><p>Git 中的分支其实就是一个指向 commit 对象的<strong>可变指针</strong>，master为默认的分支名。在若干次提交后，该指针指向最后一次提交对象的master分支，并且每次提交的时候它都会自动向前移动。</p>
<p><img src="http://git.oschina.net/progit/figures/18333fig0303-tn.png" alt="分支其实就是从某个提交对象往回看的历史"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch testing              #创建分支</span><br><span class="line">git checkout testing            #切换分支</span><br></pre></td></tr></table></figure>
<p>Git 通过一个<strong>HEAD</strong>指针知道你当前在那个分支工作，运行<code>git branch</code> 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去。</p>
<p><img src="http://git.oschina.net/progit/figures/18333fig0305-tn.png" alt="HEAD 指向当前所在的分支"></p>
<p>在testing分支提交了一次，然后再切换到master分支：</p>
<p><img src="http://git.oschina.net/progit/figures/18333fig0308-tn.png" alt="HEAD 在一次 checkout 之后移动到了另一个分支"></p>
<p>若此时在master分支提交了一次，则会产生分叉：</p>
<p><img src="http://git.oschina.net/progit/figures/18333fig0309-tn.png" alt="不同流向的分支历史"></p>
<blockquote>
<p>由于 Git 中的分支实际上仅是一个<strong>包含所指对象校验和</strong>（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，所以速度很快。</p>
</blockquote>
<h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><h3 id="分支的新建"><a href="#分支的新建" class="headerlink" title="分支的新建"></a>分支的新建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b dev       #新建并切换到dev分支</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Git 会把工作目录的内容恢复为检出某分支时它所指向的那个<strong>提交对象</strong>的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。</p>
</blockquote>
<h3 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h3><h4 id="简单分支的合并"><a href="#简单分支的合并" class="headerlink" title="简单分支的合并"></a>简单分支的合并</h4><p><img src="http://git.oschina.net/progit/figures/18333fig0313-tn.png" alt="hotfix 分支是从 master 分支所在点分化出来的"><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge hotfix        ##将当前分支与hotfix分支合并</span><br></pre></td></tr></table></figure><br>合并后：<br><img src="http://git.oschina.net/progit/figures/18333fig0314-tn.png" alt="合并分支"></p>
<p>这种直接的合并模式是<strong>Fast formard</strong>模式。由于当前 master 分支所在的提交对象是要并入的 hotfix 分支的直接上游，Git 只需把 master 分支指针直接右移。因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为<strong>快进（Fast forward）</strong>。</p>
<p>之后删除hotfix分支:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d hotfix        #删除分支</span><br></pre></td></tr></table></figure></p>
<h4 id="多祖先分支的合并"><a href="#多祖先分支的合并" class="headerlink" title="多祖先分支的合并"></a>多祖先分支的合并</h4><p>现在分支情况是这样：<br><img src="http://git.oschina.net/progit/figures/18333fig0315-tn.png" alt="iss53"><br>这次 master 与 iss53 分支的合并，并不同于之前 hotfix 的并入方式。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，Git 不得不进行一些额外处理。这里，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算，为分支合并自动识别出最佳的同源合并点：</p>
<p><img src="http://git.oschina.net/progit/figures/18333fig0316-tn.png" alt="Git 为分支合并自动识别出最佳的同源合并点"></p>
<p>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p>
<p><img src="http://git.oschina.net/progit/figures/18333fig0317-tn.png" alt="Git 自动创建了一个包含了合并结果的提交对象"></p>
<h3 id="分支合并冲突时的处理"><a href="#分支合并冲突时的处理" class="headerlink" title="分支合并冲突时的处理"></a>分支合并冲突时的处理</h3><p>当在不同分支中修改同一文件是，合并时就会发生冲突。这时需要手动解决。任何包含未解决冲突的文件都会以<strong>未合并（unmerged）</strong>的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><br>可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。</p>
<p>如果想用一个有图形界面的工具来解决这些问题，不妨运行 <code>git mergetool</code>，它会调用一个可视化的合并工具并引导你解决所有冲突：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git mergetool</span><br><span class="line">    merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff</span><br><span class="line">    Merging the files: index.html</span><br><span class="line"></span><br><span class="line">    Normal merge conflict for &#x27;index.html&#x27;:</span><br><span class="line">    &#123;local&#125;: modified</span><br><span class="line">    &#123;remote&#125;: modified</span><br><span class="line">    Hit return to start merge resolution tool (opendiff):</span><br></pre></td></tr></table></figure><br>如果不想用默认的合并工具，你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入想用的工具名。<br>确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。</p>
<h2 id="分支的管理"><a href="#分支的管理" class="headerlink" title="分支的管理"></a>分支的管理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch                      #列出当前所有分支</span><br><span class="line">git branch -v                   #查看各个分支最后一个提交对象的信息</span><br><span class="line">git branch --merge              #查看哪些分支已被并入当前分支</span><br><span class="line">git branch --no-merged          #查看哪些分支没有被并入当前分支</span><br><span class="line">git branch -D                   #强制删除分支</span><br></pre></td></tr></table></figure>
<h2 id="利用分支进行开发的工作流程"><a href="#利用分支进行开发的工作流程" class="headerlink" title="利用分支进行开发的工作流程"></a>利用分支进行开发的工作流程</h2><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p><img src="http://git.oschina.net/progit/figures/18333fig0319-tn.png" alt="分支流水线"><br>一般 <code>master</code> 分支中保留完全稳定的代码，即已经发布或即将发布的代码；<br><code>develop</code> 或 <code>next</code> 的平行分支，专门用于后续的开发，不过一旦进入某种稳定状态，便可以把它合并到 <code>master</code> 里；<br>某些大项目还会有个 <code>proposed</code>（建议）或 <code>pu</code>（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入 <code>next</code> 或 <code>master</code> 的内容。</p>
<p>建立不同分支的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。</p>
<h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p>在任何规模的项目中都可以使用<strong>特性（Topic）分支</strong>。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。</p>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程分支（remote branch）是对远程仓库中的分支的<strong>索引</strong>。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。</p>
<p>从github克隆项目，Git 会自动为你将此远程仓库命名为 <code>origin</code>，并下载其中所有的数据，建立一个指向它的 <code>master</code> 分支的指针，在本地命名为 <code>origin/master</code>，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地 <code>master</code> 分支，始于 origin 上 master 分支相同的位置，你可以就此开始工作。</p>
<p><img src="http://git.oschina.net/progit/figures/18333fig0322-tn.png" alt="git clone 过程"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin            #同步远程服务器上的数据到本地</span><br></pre></td></tr></table></figure>
<p>该命令首先找到 origin 是哪个服务器，从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 <code>origin/master</code> 的指针移到它最新的位置上。</p>
<p><img src="http://git.oschina.net/progit/figures/18333fig0324-tn.png" alt="git fetch"></p>
<p>若有多个远程分支，可以用 <code>git remote add</code> 添加为当前项目的远程分支之一。</p>
<p><img src="http://git.oschina.net/progit/figures/18333fig0325-tn.png" alt="把另一个服务器加为远程仓库"></p>
<p>现在，可以使用 <code>git fetch teamone</code> 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 <code>origin</code> 服务器上的<strong>子集</strong>，Git 不会下载任何数据，而只是简单地创建一个名为 <code>teamone/master</code> 的远程分支，指向 <code>teamone</code> 服务器上 <code>master</code> 分支所在的提交对象 31b8e：</p>
<p><img src="http://git.oschina.net/progit/figures/18333fig0326-tn.png" alt="指向 teamone 服务器上 master 分支的索引"></p>
<h3 id="推送本地分支"><a href="#推送本地分支" class="headerlink" title="推送本地分支"></a>推送本地分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push (远程仓库名) (分支名)</span><br></pre></td></tr></table></figure>
<p>Git 自动把 <code>serverfix</code> 分支名扩展为 <code>refs/heads/serverfix:refs/heads/serverfix</code>，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。<br>也可以运行 <code>git push origin serverfix:serverfix</code> 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。<br>通过此语法，可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 <code>awesomebranch</code>，可以用 <code>git push origin serverfix:awesomebranch</code> 来推送数据。</p>
<p>接下来协同作者使用<code>git fetch</code> 下载远程分支。注意，在 <code>fetch</code> 操作下载好新的远程分支之后，仍然无法在本地编辑该远程仓库中的分支。在本例中，你不会有一个新的 <code>serverfix</code> 分支，有的只是一个你无法移动的 <code>origin/serverfix</code> 指针。</p>
<p>如果要把该远程分支的内容合并到当前分支，可以运行 <code>git merge origin/serverfix</code>。如果想要一份自己的 <code>serverfix</code> 来开发，可以在远程分支的基础上分化出一个新的分支来：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b serverfix origin/serverfix</span><br><span class="line">git checkout -b sf origin/serverfix             #设定不同的本地分支名</span><br></pre></td></tr></table></figure></p>
<h3 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h3><p>从远程分支 <code>checkout</code> 出来的本地分支，称为 <strong>跟踪分支</strong> (tracking branch)。跟踪分支是一种和某个远程分支有<strong>直接联系</strong>的本地分支。在跟踪分支里输入 <code>git push</code>，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 <code>git pull</code> 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p>
<blockquote>
<p>在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">    Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.</span><br><span class="line">    Switched to a new branch &quot;serverfix&quot;</span><br></pre></td></tr></table></figure>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push [远程名] :[分支名]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin :serverfix</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line">- [deleted] serverfix</span><br></pre></td></tr></table></figure>
<p><code>git push [远程名] [本地分支]:[远程分支]</code> ，如果省略 [本地分支]，那就等于是在说 “在这里提取空白然后把它变成[远程分支]”，也就是删除远程分支了。</p>
<h2 id="分支的衍合"><a href="#分支的衍合" class="headerlink" title="分支的衍合"></a>分支的衍合</h2><h3 id="基本衍合操作"><a href="#基本衍合操作" class="headerlink" title="基本衍合操作"></a>基本衍合操作</h3><p>把一个分支中的修改整合到另一个分支的办法有两种：merge 和 rebase（衍合）。</p>
<p><img src="http://git.oschina.net/progit/figures/18333fig0329-tn.png" alt="把 C3 里产生的改变到 C4 上重演一遍"></p>
<p>把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍。在 Git 里，这种操作叫做衍合（rebase）。有了 <code>rebase</code> 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout experiment</span><br><span class="line">$ git rebase master</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: added staged command</span><br></pre></td></tr></table></figure><br>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 experiment）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 experiment 的提交历史，使它成为 master 分支的直接下游。</p>
<p>回到 master 分支，进行一次快进合并：<br> <img src="http://git.oschina.net/progit/figures/18333fig0330-tn.png" alt="master 分支的快进"></p>
<blockquote>
<p>衍合能产生一个更为整洁的提交历史。如果视察一个衍合过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。</p>
<p>一般使用衍合的目的是想要得到一个能在远程分支上干净应用的补丁。注意，合并结果中最后一次提交所指向的快照，无论是通过衍合，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p>
</blockquote>
<h3 id="有趣的衍合"><a href="#有趣的衍合" class="headerlink" title="有趣的衍合"></a>有趣的衍合</h3><p>对于下面的工作分支图：<br><img src="http://git.oschina.net/progit/figures/18333fig0331-tn.png" alt="分支图"><br>如果想要一次性把 client 分支合并到 master 分支而不通过 server 分支，这是可以通过衍合：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rebase --onto master server client</span><br></pre></td></tr></table></figure><br>使用 <code>--onto</code>选项指定新的基底分支 master。这段命令的大致意思就是：取出 client 分支，找出 client 分支和 server 分支的共同祖先之后的变化，然后把它们在 master 上重演一遍。</p>
<p>合并之后，分支图如下图：<br><img src="http://git.oschina.net/progit/figures/18333fig0332-tn.png" alt="特性分支衍合"><br>之后<code>git merge client</code>：<br><img src="http://git.oschina.net/progit/figures/18333fig0333-tn.png" alt="merge client"></p>
<p>若此时把 server 分支的变化也包含进来，可以直接把 server 衍合到 master 中，而不用手工切换到server分支后再衍合——<code>git rebase [主分支] [特性分支]</code> 命令会先取出特性分支 server，然后在主分支 master 上重演。<br><img src="http://git.oschina.net/progit/figures/18333fig0334-tn.png" alt="衍合server"><br>之后再merge然后删掉特性分支就行了。</p>
<h2 id="衍合的风险"><a href="#衍合的风险" class="headerlink" title="衍合的风险"></a>衍合的风险</h2><p>使用衍合要遵守一条准则：<br><strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。</strong></p>
<blockquote>
<p>在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用 <code>git rebase</code> 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。</p>
</blockquote>
<p>假如在一个人中央服务器克隆然后在它的基础上研发：<br><img src="http://git.oschina.net/progit/figures/18333fig0336-tn.png" alt="衍合的风险"><br>现在，某人在 C1 的基础上做了些改变，并合并他自己的分支得到结果 C6，推送到中央服务器。当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果 C7，历史提交会变成下图：<br><img src="http://git.oschina.net/progit/figures/18333fig0337-tn.png" alt="衍合的风险"><br>接下来，那个推送 C6 上来的人决定用衍合取代之前的合并操作；继而又用 <code>git push --force</code> 覆盖了服务器上的历史，得到 C4’。而之后当你再从服务器上下载最新提交后，会得到：<br><img src="http://git.oschina.net/progit/figures/18333fig0338-tn.png" alt="衍合的风险"></p>
<p>此时下载更新后需要合并，然而此时衍合产生的C4的SHA-1校验码和之前的C4完全不同，所以 Git 会把它们当作新的提交对象处理，而实际上此刻你的提交历史 C7 中早已经包含了 C4 的修改内容，于是合并操作会把 C7 和 C4’ 合并为 C8。<br><img src="http://git.oschina.net/progit/figures/18333fig0339-tn.png" alt="衍合的风险"><br>而当你推送C8时，由于你的提交历史里就会同时包含 C4 和 C4’，两者有着不同的 SHA-1 校验值，如果用 git log 查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。而更糟的是，当你把这样的历史推送到服务器后，会再次把这些衍合后的提交引入到中央服务器，进一步困扰其他人。</p>
<blockquote>
<p>如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些尚未公开的提交对象，就没问题。如果衍合那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。</p>
</blockquote>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>《Pro Git》学习笔记（基础篇）</title>
    <url>/Blog/2016/06/26/the-fundamental-part-of-Pro-Git/</url>
    <content><![CDATA[<h2 id="git工作原理"><a href="#git工作原理" class="headerlink" title="git工作原理"></a>git工作原理</h2><p>Git 和其他版本控制系统的主要差别在于，Git只关心文件数据的<strong>整体</strong>是否发生变化，而大多数其他系统则只关心文件内容的具体差异。Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作<strong>快照</strong>后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的<strong>指纹信息</strong>并对文件作一快照，然后保存一个指向这次快照的<strong>索引</strong>。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一<strong>链接</strong>。</p>
<p><img src="http://git.oschina.net/progit/figures/18333fig0105-tn.png" alt="git工作原理"></p>
<span id="more"></span>
<blockquote>
<p>文件在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。</p>
</blockquote>
<p>Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是：</p>
<blockquote>
<p>24b9da6552252987aa493b52f8696cd6d3b00373</p>
</blockquote>
<p><strong>所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。</strong></p>
<h2 id="文件的三种状态"><a href="#文件的三种状态" class="headerlink" title="文件的三种状态"></a>文件的三种状态</h2><p>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；<strong>已暂存表示把已修改的文件放在下次提交时要保存的清单中</strong>。<br> Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库:<br><img src="http://git.oschina.net/progit/figures/18333fig0106-tn.png" alt="git中文件三种状态"></p>
<blockquote>
<p>每个项目都有一个 Git 目录，如果 <code>git clone</code> 出来的话，就是其中 <code>.git</code> 的目录；如果 <code>git clone --bare</code> 的话，新建的目录本身就是 Git 目录。它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，<strong>每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。</strong></p>
</blockquote>
<p>从项目中取出某个版本的所有文件和目录，。这些文件实际上都是从 Git 目录中的<strong>压缩对象数据库</strong>中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。</p>
<p>所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。</p>
<p>基本Git工作流程：</p>
<ul>
<li>在工作目录修改某些文件</li>
<li>对修改的文件进行快照，然后保存到暂存区域</li>
<li>提价更新，将保存在暂存区域的文件快照永久转储在Git目录中。</li>
</ul>
<h2 id="Git-基本配置"><a href="#Git-基本配置" class="headerlink" title="Git 基本配置"></a>Git 基本配置</h2><p>Git 提供了一个叫做 <code>git-config</code> 的工具，专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<p><code>/etc/gitconfig</code>文件：系统中对<strong>所有用户</strong>都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。<br><code>~/.gitconfig</code> 文件：<strong>用户目录</strong>下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。<br>当前项目的 git 目录中的配置文件：这里的配置仅仅针对<strong>当前项目</strong>有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</p>
<p>在 Windows 系统上，Git 会找寻用户主目录下的 <code>.gitconfig</code> 文件。主目录即 <code>$HOME</code> 变量指定的目录，一般都是 <code>C:\Documents and Settings\$USER</code>。此外，Git 还会尝试找寻 <code>/etc/gitconfig</code> 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>
<p><strong>用户信息</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;name&quot;</span><br><span class="line">git config --global user.email 1111111@qq.com</span><br></pre></td></tr></table></figure><br><strong>文本编辑器</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.editor sublime</span><br></pre></td></tr></table></figure><br><strong>差异分析比较器</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global merge.tool vimdiff</span><br></pre></td></tr></table></figure><br>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。</p>
<p><strong>查看配置信息</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><br><strong>获取帮助</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git help &lt;verb&gt;</span><br><span class="line">git &lt;verb&gt; --help</span><br><span class="line">man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Git-仓库"><a href="#Git-仓库" class="headerlink" title="Git 仓库"></a>Git 仓库</h2><p><strong>初始化</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><br><strong>添加文件</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add *.c</span><br><span class="line">git add README</span><br><span class="line">git add commit -m &quot;initial project version&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="仓库的操作"><a href="#仓库的操作" class="headerlink" title="仓库的操作"></a>仓库的操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure>
<p>工作目录下面的所有文件都不外乎这两种状态：<strong>已跟踪或未跟踪</strong>。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p>
<p>文件的状态变化周期<br><img src="http://git.oschina.net/progit/figures/18333fig0201-tn.png" alt="文件状态"></p>
<h4 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">    # On branch master</span><br><span class="line">    nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure>
<p>有未跟踪文件时：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim README</span><br><span class="line">    $ git status</span><br><span class="line">    # On branch master</span><br><span class="line">    # Untracked files:</span><br><span class="line">    # (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">    #</span><br><span class="line">    # README</span><br><span class="line">    nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，因而不用担心把临时文件什么的也归入版本管理。</p>
</blockquote>
<h4 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">    # On branch master</span><br><span class="line">    # Changes to be committed:</span><br><span class="line">    # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">    #</span><br><span class="line">    # new file: README</span><br><span class="line">    #</span><br></pre></td></tr></table></figure>
<p>只要在 “Changes to be committed” 这行下面的，就说明是<strong>已暂存</strong>状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用 git init 后就运行了 git add 命令，开始跟踪当前目录下的文件。在 git add 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要<strong>递归</strong>跟踪该目录下的所有文件。（其实 <code>git add</code> 就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。）</p>
<h4 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h4><p>若修改已跟踪的文件 <code>benchmarks.rb</code>，然后在运行 status ：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> $ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   test.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>文件 <code>benchmarks.rb</code> 出现在 “<strong>Changes not staged for commit</strong>” 这行下面，说明<strong>已跟踪文件的内容发生了变化，但还没有放到暂存区</strong>。可以运行<code>git add</code> 命令将已跟踪文件放入暂存区。<code>git add</code>是个<strong>多功能</strong>命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态。</p>
<p><strong>注意：</strong> 运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来</p>
<h4 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h4><p><code>.gitignore</code>用来存放忽略文件的过滤方法。<br>文件 .gitignore 的格式规范如下：</p>
<ul>
<li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
<p><strong>glob 模式</strong>是指 shell 所使用的简化了的正则表达式。星号（*）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line">    # 忽略所有 .a 结尾的文件</span><br><span class="line">    *.a</span><br><span class="line">    # 但 lib.a 除外</span><br><span class="line">    !lib.a</span><br><span class="line">    # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">    /TODO</span><br><span class="line">    # 忽略 build/ 目录下的所有文件</span><br><span class="line">    build/</span><br><span class="line">    # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">    doc/*.txt</span><br></pre></td></tr></table></figure>
<p><strong>查看已暂存和未暂存的更新</strong><br><code>git status</code> 列出了修改过的文件<br><code>git diff</code> 使用文件补丁的格式显示具体添加和删除的行。<br>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/test.txt b/test.txt</span><br><span class="line">index 18534df..77ba542 100644</span><br><span class="line">--- a/test.txt</span><br><span class="line">+++ b/test.txt</span><br><span class="line">@@ -2,3 +2,8 @@ this is a test!</span><br><span class="line"> ~~~</span><br><span class="line"> fghdfkl</span><br><span class="line">  g</span><br><span class="line">+&lt;B8&gt;ջָ&lt;B4&gt;&lt;BD&gt;&lt;A1&gt;&lt;BF&gt;&lt;B5&gt; &lt;B9&gt;ۿ&lt;B4&gt;  &lt;BF&gt;&lt;AA&gt;&lt;B9&gt;ط&lt;B3&gt;&lt;B5&gt;ú&lt;DC&gt;</span><br><span class="line">+</span><br><span class="line">+ghd</span><br><span class="line">+ &lt;CB&gt;&lt;FB&gt;</span><br><span class="line">+</span><br></pre></td></tr></table></figure><br>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 <code>git diff --cached</code> 命令。Git 1.6.1 及更高版本还允许使用 <code>git diff --staged</code>，效果是相同的。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/test.txt b/test.txt</span><br><span class="line">index f862775..72825dd 100644</span><br><span class="line">--- a/test.txt</span><br><span class="line">+++ b/test.txt</span><br><span class="line">@@ -7,4 +7,6 @@ fghdfkl</span><br><span class="line"> ghd</span><br><span class="line">  &lt;CB&gt;&lt;FB&gt;</span><br><span class="line"></span><br><span class="line">-&lt;B7&gt;ֹ&lt;A4&gt; &lt;B5&gt;ط&lt;BD&gt;</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+&lt;B7&gt;ֹ&lt;A4&gt; &lt;B5&gt;ط&lt;BD&gt;</span><br><span class="line">+&lt;B4&gt;&lt;F3&gt;&lt;B8&gt;&lt;C5&gt;</span><br><span class="line">+ Ⱦ&lt;B7&gt;&lt;A2&gt;&lt;B8&gt;&lt;E0&gt;</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意：</strong> 单单 <code>git diff</code> 不过是显示还没有暂存起来的改动，而不是这次工作和上次提交之间的差异。所以在<code>git commit</code>之前运行该命令，否则什么也没有。</p>
</blockquote>
<h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p><code>git commit</code> 使用之前一定要确认修改或新建的文件已经add过了，否则提交时不会记录这些还没暂存起来的变化。<br>提交时记录的是放在暂存区域的<strong>快照</strong>，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<p><code>git commit -a</code> 跳过暂存区域，自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -a -m &quot;delete something&quot;</span><br><span class="line">[master 923cea9] delete something</span><br><span class="line"> 1 file changed, 4 deletions(-)</span><br></pre></td></tr></table></figure></p>
<h4 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h4><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是未暂存清单）看到：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><br>然后再运行 git rm 记录此次移除文件的操作：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br></pre></td></tr></table></figure><br>最后提交的时候，该文件就不再纳入版本管理了。<strong>如果删除之前修改过并且已经放到暂存区域的话</strong>，则必须要用强制删除选项 <code>-f</code>，以防误删除文件后丢失修改的内容。</p>
<p>如果想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件，不小心纳入仓库后，<strong>要移除跟踪但不删除文件</strong>，以便稍后在 .gitignore 文件中补上，用 —cached 选项即可：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm --cached readme.txt</span><br></pre></td></tr></table></figure><br>也可以使用 glob 模式：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm log/\*.log</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意</strong>: 星号 <code>*</code>之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，所以不用 shell 来帮忙展开（实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，<strong>仅仅删除指定目录下的文件而不会递归匹配。</strong>上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有 log/ 目录下扩展名为 .log 的文件。类似的比如：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rm \*~</span><br></pre></td></tr></table></figure><br>会递归删除当前目录及其子目录中所有<code>~</code>结尾的文件。</p>
</blockquote>
<h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><p>不同于VCS系统，Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 可以推断出发生了什么。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mv &lt;file_from&gt; &lt;file_to&gt;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        renamed:    test.txt -&gt; list.txt</span><br></pre></td></tr></table></figure><br>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mv README.txt README</span><br><span class="line">$ git rm README.txt</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure><br>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式都一样。</p>
<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p><code>git log</code> 默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -p                  #展开显示每次提交的内容差异</span><br><span class="line">git log -2                  #仅显示最近的两次更新</span><br><span class="line">git log --stat              #仅显示简要的增改行数统计</span><br><span class="line">git log --pretty=oneline    #将每个提交放在一行显示，另外还有 short，full 和 fuller</span><br></pre></td></tr></table></figure>
<p>另外还可以使用<code>format</code>定制要显示的记录格式，这样的输出便于后期编程提取分析<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</span><br><span class="line">e314300 - guoxs, 25 minutes ago : recovery test.txt</span><br><span class="line">923cea9 - guoxs, 60 minutes ago : delete something</span><br><span class="line">989b58b - guoxs, 61 minutes ago : change test.txt</span><br><span class="line">1362de0 - guoxs, 85 minutes ago : change test.txt</span><br><span class="line">87d047f - guoxs, 87 minutes ago : add .gitignore</span><br><span class="line">1f0fec8 - guoxs, 2 hours ago : first commit</span><br></pre></td></tr></table></figure><br>常用的格式占位符写法及其代表的意义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%H</td>
<td style="text-align:center">提交对象（commit）的完整哈希字串</td>
</tr>
<tr>
<td style="text-align:center">%h</td>
<td style="text-align:center">提交对象的简短哈希字串</td>
</tr>
<tr>
<td style="text-align:center">%T</td>
<td style="text-align:center">树对象（tree）的完整哈希字串</td>
</tr>
<tr>
<td style="text-align:center">%t</td>
<td style="text-align:center">树对象的简短哈希字串</td>
</tr>
<tr>
<td style="text-align:center">%P</td>
<td style="text-align:center">父对象（parent）的完整哈希字串</td>
</tr>
<tr>
<td style="text-align:center">%p</td>
<td style="text-align:center">父对象的简短哈希字串</td>
</tr>
<tr>
<td style="text-align:center">%an</td>
<td style="text-align:center">作者（author）的名字</td>
</tr>
<tr>
<td style="text-align:center">%ae</td>
<td style="text-align:center">作者的电子邮件地址</td>
</tr>
<tr>
<td style="text-align:center">%ad</td>
<td style="text-align:center">作者修订日期（可以用 -date= 选项定制格式）</td>
</tr>
<tr>
<td style="text-align:center">%ar</td>
<td style="text-align:center">作者修订日期，按多久以前的方式显示</td>
</tr>
<tr>
<td style="text-align:center">%cn</td>
<td style="text-align:center">提交者(committer)的名字</td>
</tr>
<tr>
<td style="text-align:center">%ce</td>
<td style="text-align:center">提交者的电子邮件地址</td>
</tr>
<tr>
<td style="text-align:center">%cd</td>
<td style="text-align:center">提交日期</td>
</tr>
<tr>
<td style="text-align:center">%cr</td>
<td style="text-align:center">提交日期，按多久以前的方式显示</td>
</tr>
<tr>
<td style="text-align:center">%s</td>
<td style="text-align:center">提交说明</td>
</tr>
</tbody>
</table>
</div>
<p>用 <code>oneline</code> 或 <code>format</code> 时结合 <code>--graph</code> 选项，可以看到开头多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=format:&quot;%h %s&quot; --graph</span><br><span class="line">*   96c99cd pull</span><br><span class="line">|\</span><br><span class="line">| * baf89e7 merge</span><br><span class="line">| *   8d6c560 merge</span><br><span class="line">| |\</span><br><span class="line">| | *   14cffc7 Merge pull request #8 from jiangjiuxing/master</span><br><span class="line">| | |\</span><br><span class="line">| | | *   7519696 Merge branch &#x27;dev&#x27;</span><br><span class="line">| | | |\</span><br><span class="line">| | | * \   30e5c0e Merge branch &#x27;dev&#x27;</span><br><span class="line">| | | |\ \</span><br><span class="line">| | | * \ \   849ef03 Merge pull request #7 from jiangjiuxing/dev</span><br><span class="line">| | | |\ \ \</span><br><span class="line">| | | * \ \ \   0c3056d Merge pull request #6 from jiangjiuxing/dev</span><br><span class="line">| | | |\ \ \ \</span><br><span class="line">| | | * | | | | b4b1e86 remove package data</span><br><span class="line">| | | * | | | |   c921cac Merge branch &#x27;dev&#x27;</span><br><span class="line">| | | |\ \ \ \ \</span><br><span class="line">| | | * | | | | | d622055 add package data</span><br><span class="line">| | | * | | | | | 0f78e74 delete test.txt</span><br><span class="line">| | | * | | | | |   602c999 Merge pull request #5 from jiangjiuxing/dev</span><br><span class="line">| | | |\ \ \ \ \ \</span><br><span class="line">| | | * \ \ \ \ \ \   ac98953 merge dev</span><br><span class="line">| | | |\ \ \ \ \ \ \</span><br><span class="line">| | | * | | | | | | | 0450640 delete test.txt</span><br><span class="line">| | | * | | | | | | |   062a1cd Merge pull request #4 from jiangjiuxing/dev</span><br><span class="line">| | | |\ \ \ \ \ \ \ \</span><br><span class="line">| | | * \ \ \ \ \ \ \ \   8e8c7a8 Merge pull request #2 from jiangjiuxing/dev</span><br><span class="line">| | | |\ \ \ \ \ \ \ \ \</span><br><span class="line">| | | * | | | | | | | | | a0d1942 reset master</span><br><span class="line">| | * | | | | | | | | | | 90dd06c fix bugs</span><br><span class="line">| | | |_|_|_|_|_|_|_|_|/</span><br><span class="line">| | |/| | | | | | | | |</span><br><span class="line">| * | | | | | | | | | | f5e744c merge</span><br></pre></td></tr></table></figure><br><code>git log</code>一些其他的命令<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-p                      #按补丁格式显示每个更新之间的差异。</span><br><span class="line">--stat                  #显示每次更新的文件修改统计信息。</span><br><span class="line">--shortstat             #只显示 --stat 中最后的行数修改添加移除统计。</span><br><span class="line">--name-only             #仅在提交信息后显示已修改的文件清单。</span><br><span class="line">--name-status           #显示新增、修改、删除的文件清单。</span><br><span class="line">--abbrev-commit         #仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</span><br><span class="line">--relative-date         #使用较短的相对时间显示（比如，“2 weeks ago”）。</span><br><span class="line">--graph                 #显示 ASCII 图形表示的分支合并历史。</span><br><span class="line">--pretty                #使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</span><br></pre></td></tr></table></figure><br><strong>限制输出长度</strong><br>除了定制输出格式的选项之外，<code>git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -n                   # n 可以是任何自然数，表示仅显示最近的若干条提交。</span><br><span class="line">git log --since=2.weeks      #按照时间作限制的选项， --since 和 --until</span><br><span class="line">git log --author             #显示指定作者的提交</span><br><span class="line">git log --grep               #显示指定作者的提交 如果要得到同时满足这两个选项搜索条件的提交，就必须用 --all-match 选项</span><br><span class="line">git log --path</span><br></pre></td></tr></table></figure></p>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend                      #使用当前的暂存区域快照提交</span><br><span class="line">git commit --amend -m &quot;rename_commit&quot;   #重新编辑提交说明</span><br></pre></td></tr></table></figure>
<p>如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 <code>--amend</code> 提交：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;initial commit&#x27;</span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><br>上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p>
<p><strong>取消已经暂存的文件</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;filename&gt;</span><br></pre></td></tr></table></figure><br><strong>取消对文件的修改</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout --&lt;filename&gt;   #把之前版本的文件复制过来重写了此文件，有一定危险性危险性</span><br></pre></td></tr></table></figure><br>任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 —amend 重新改写的提交，都可以被恢复。可能失去的数据仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。</p>
<h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote                   #列出每个远程库的简短名字</span><br><span class="line">git remote -v                #显示对应的克隆地址</span><br><span class="line">git remote add pb &lt;url&gt;      #添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用</span><br><span class="line">git fetch pb                 #抓取所有 Pb 有的，但本地仓库没有的信息</span><br><span class="line">git fetch [remote-name]      #从远程仓库抓取数据到本地</span><br><span class="line">git push [remote-name] [branch-name]    #将本地仓库中的数据推送到远程仓库</span><br><span class="line">git remote show [remote-name]           #查看某个远程仓库的详细信息</span><br><span class="line">git remote rename               #修改某个远程仓库在本地的简称</span><br><span class="line">git remote rm  [remote-name]    #移除对应的远端仓库</span><br></pre></td></tr></table></figure>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag                     #列显已有的标签</span><br><span class="line">git tag -l &#x27;v1.4.2.*&#x27;       #用特定的搜索模式列出符合条件的标签</span><br></pre></td></tr></table></figure>
<p>Git 使用的标签有两种类型：<strong>轻量级的（lightweight）和含附注的（annotated）</strong>。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息。</p>
<p><strong>创建一个含附注类型的标签：</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -a v1.4 -m &#x27;my version 1.4&#x27;     #-a 指定标签名字 -m 指定了对应的标签说明</span><br><span class="line">git show  v0.1                      #查看相应标签的版本信息，并连同显示打标签时的提交对象</span><br></pre></td></tr></table></figure><br><strong>后期加注标签</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -a v1.2 9fceb02[校验和前几位数字]</span><br></pre></td></tr></table></figure></p>
<h2 id="技巧与窍门"><a href="#技巧与窍门" class="headerlink" title="技巧与窍门"></a>技巧与窍门</h2><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><p>下载 Git 的源代码，进入 contrib/completion 目录，会看到一个 git-completion.bash 文件。将此文件复制到你自己的用户主目录中（译注：按照下面的示例，还应改名加上点：cp git-completion.bash ~/.git-completion.bash），并把下面一行内容添加到你的 <code>.bashrc</code> 文件中：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.git-completion.bash</span><br></pre></td></tr></table></figure></p>
<h3 id="Git-命令别名"><a href="#Git-命令别名" class="headerlink" title="Git 命令别名"></a>Git 命令别名</h3><p>用 <code>git config</code> 为命令设置别名:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure><br>现在，如果要输入 git commit 只需键入 git ci 即可。<br>使用这种技术还可以创造出新的命令，比方说取消暂存文件时的输入比较繁琐，可以自己设置一下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.unstage &#x27;reset HEAD --&#x27;</span><br></pre></td></tr></table></figure><br>设置last:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.last &#x27;log -1 HEAD&#x27;</span><br></pre></td></tr></table></figure><br>设置图形log:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.log_graph &#x27;log --pretty=format:&quot;%h %s&quot; --graph`</span><br></pre></td></tr></table></figure><br>有时候我们希望运行某个外部命令，而非 Git 的子命令，只需要在命令前加上<code>!</code>就行:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.visual &#x27;!gitk&#x27;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫问题与成套方法</title>
    <url>/Blog/2016/10/04/the-jorsephus-problem/</url>
    <content><![CDATA[<p>这篇学习笔记探讨约瑟夫问题以及由该问题衍生的求解递归式地<strong>成套方法</strong>，来源于《具体数学》第一章。</p>
<h3 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h3><p><strong>约瑟夫问题</strong> 的来源是这样的：在犹太罗马战争期间，41名犹太反抗者困在了罗马人包围的洞穴中。这些反抗者宁愿自杀也不愿被活捉，于是决定围成一个圈，并沿着圆圈每隔两人杀死一人，直到剩下最后两人为止。但是约瑟夫和一个未被告发的同谋者不希望无谓地自杀，于是他迅速计算出他和其朋友在这个圆圈中应该站的位置。<br><span id="more"></span><br>现在我们把问题抽象一下：从围成标有几号 1 到 n 的圆圈的 n 个数开始，每隔一个数就删去一个数，直到剩下最后一个数，要求解剩余数的一般表达式 J(n)。</p>
<p>这是 n 为 10 的情况，删除的顺序是 2 4 6 8 10 3 7 1 9，留下的数为 5。</p>
<p><img src="http://static.zybuluo.com/guoxs/pwac6l2y5781hq3vq3e8r2tz/1.png" alt="1.png-3.9kB"></p>
<p>现在，我们来考虑一般情况，假设一开始有 2n 个数，经过第一轮删除后只剩下奇数：</p>
<p><img src="http://static.zybuluo.com/guoxs/y8zoofsoapt7fnspetljo450/2.png" alt="2.png-3.9kB"></p>
<p>而 3 是下一个要被删除的数。<strong>除每个数加倍然后减 1 以外，</strong> 这正像是对应 n 个人开始时的情况。也就是说：</p>
<script type="math/tex; mode=display">
J(2n) = 2J(n) - 1, n ≥ 1.</script><p>对于一开始有 2n+1 个数，经过第一轮删除，情况是这样的：</p>
<p><img src="http://static.zybuluo.com/guoxs/64d04t1fwo8c3vdexcum6yq9/3.png" alt="3.png-3.9kB"></p>
<p>不难看出，这一次可以推出下面的递推式：</p>
<script type="math/tex; mode=display">
J(2n) = 2J(n) + 1, n ≥ 1.</script><p>把这两个方程与 J(1) = 1 组合起来，就可以给出所有情况下定义 J 的递归式：</p>
<script type="math/tex; mode=display">
J(1) = 1 \\
J(2n) = 2J(n) - 1, n ≥ 1\\
J(2n) = 2J(n) + 1, n ≥ 1</script><h3 id="递归式地求解"><a href="#递归式地求解" class="headerlink" title="递归式地求解"></a>递归式地求解</h3><p>有了递归式，我们可以计算出前几个解，看看能不能发现什么规律：</p>
<p><img src="http://static.zybuluo.com/guoxs/usg5sbblxdbtfak0kefc87or/4.png" alt="4.png-4.8kB"></p>
<p>很容易注意到，可以按照 2 的幂将表中的数据分组，在每一组的开始 J(n) 都为 1，且组内数据每次递增 2。因此，递归式地解似乎可以写成这样：</p>
<script type="math/tex; mode=display">
J(2^m+l) = 2l + 1, m ≥ 0，n ≤ l ≤ 2^m \\</script><p>（注意，如果 $2^m ≤ n &lt; 2^{m+1}$，则余下来的数 $l = n - 2^m$ 满足 $0 ≤ l &lt; 2^{m+1} - 2^m = 2^m$.)</p>
<p>对于上式的证明，可以使用数学归纳法：当 m 为 0 时必然有 l = 0，于是 J(1)=1；下一步证明需要分奇偶分别讨论.<br>如果 m &gt; 0 并且 $2^m + l = 2n$，那么 l 是偶数，故有</p>
<script type="math/tex; mode=display">
J(2^m + l) = 2J(2^{m-1} + \frac{l}{2}) - 1 = 2(2\frac{l}{2} + 1) - 1 = 2l + 1</script><p>这就证明了该公式在 $2^m + l = 2n$ 时是成立的。同理可证另一种情况也是成立的。</p>
<h3 id="解的二进制表示"><a href="#解的二进制表示" class="headerlink" title="解的二进制表示"></a>解的二进制表示</h3><p>问题的每一个解都可以加以推广，使得它能运用于更加一般的问题，这是一件很有启发意义的事情。接下来，我们将对上诉递归式以及递归式地解进行推广，揭示所有这类问题背后所隐藏的结构。</p>
<p>在求解过程中，我们注意到 2 的幂起到了重要作用。一个很自然的想法就是研究 n 和 J(n) 的以 2 为基数的表示。假设 n 的二进制表示为：</p>
<p>$n = (b<em>m b</em>{m-1} … b_1 b_0)_2 $</p>
<p>也就是说，</p>
<script type="math/tex; mode=display">
n = b_m2^m + b_{m-1}2^{m-1} + · · · + b_12 + b_0</script><p>其中首位数字$b_m$为 1，注意到 $n = 2^m + l$，于是依次有：</p>
<script type="math/tex; mode=display">
n = (1 b_{m-1} b_{m-2} ... b_1 b_0)_2 \\
l = (0 b_{m-1} b_{m-2} ... b_1 b_0)_2 \\
2l = (b_{m-1} b_{m-2} ... b_1 b_0 0)_2 \\
2l + 1 = (b_{m-1} b_{m-2} ... b_1 b_0 1)_2 \\
J(n) = 2l + 1 = (b_{m-1} b_{m-2} ... b_1 b_0 b_m)_2</script><p>于是我们证明了</p>
<script type="math/tex; mode=display">
J(b_m b_{m-1} ... b_1 b_0)_2 = (b_{m-1} ... b_1 b_0 b_m)_2</script><p>用程序语言来说就是， n 左循环移动一位就得到了 J(n)， 这真是不可思议！</p>
<p>另一个值得注意的现象是，如果重复进行循环左移，即重复运用 J 函数，会出现首位数字为 0 的情况，这种情况下数的位数将会减少，即首位 0 将会被丢弃。重复运用 J 会得到一列递减的值，它们最终会到达一个<strong>不动点</strong>。利用循环左移的性质不难发现，最后的不动点全由 1 组成，它的值为 $2^{v(n)} - 1$，其中 v(n) 是二进制表示中 1 的个数。<br>于是由于 v(13) = 3，有</p>
<script type="math/tex; mode=display">
\underbrace{J(J(...J}_{\text{2 or more}}(13)...)) = 2^3 - 1 = 7</script><p>类似地有</p>
<script type="math/tex; mode=display">
\underbrace{J(J(...J}_{\text{8 or more}}(101101101101011)_2...)) = 2^10 - 1 = 7</script><p>结果令人称奇，但准确无误。</p>
<h3 id="成套方法"><a href="#成套方法" class="headerlink" title="成套方法"></a>成套方法</h3><p>下一步我们要推广的递归式 J，看看在一般情况下形如递归式 J 的函数该如何求出一个封闭形式的解。<br>首先我们来构造一般情况下的 J 表达式，引入常数 α、β、γ</p>
<script type="math/tex; mode=display">
J(1) = α \\
J(2n) = 2J(n) - β, n ≥ 1\\
J(2n) = 2J(n) + γ, n ≥ 1</script><p>类似约瑟夫问题的求解，我们首先对小的 n 值构造出如下的一般性的表：</p>
<p><img src="http://static.zybuluo.com/guoxs/phrgtpkbwqa7pmbdefa13dzp/5.png" alt="5.png-14.7kB"></p>
<p>很容易发现这其中的规律。<br>如果把 f(n) 对 α、β、γ 的依赖关系分离出来，表示成如下形式：</p>
<script type="math/tex; mode=display">
f(n) = A(n)α + B(n)β + C(n)γ</script><p>根据一般性表我们可以猜测：</p>
<script type="math/tex; mode=display">
A(n) = 2^m \\
B(n) = 2^{m - 1} - l \\
C(n) = l</script><p>这里也有 $n = 2^m + l$ 以及 $0≤ l &lt; 2^m (n ≥ 1)$<br>用归纳法证明上述猜想并不困难，但是计算起来比较复杂，这里介绍一个更好的方法，通过取特殊值，然后将它们组合起来。<br>考虑 $α = 1、β=γ=0$ 这一特殊情况，此时递归式变为：</p>
<script type="math/tex; mode=display">
J(1) = 1 \\
J(2n) = 2J(n), n ≥ 1\\
J(2n) = 2J(n), n ≥ 1</script><p>可知，$f(2^m+l) = 2^m$ 为真（对 m 进行归纳法）。<br>接下来，反过来使用一般递归式以及其一般解，从一个简单的函数 $f(n)$ 出发，研究是否有任何常数 $(α，β，γ)$ 能定义它。<br>比如，将函数 $f(n) = 1$ 代入有</p>
<script type="math/tex; mode=display">
J(1) = α \\
1 = 2 \times 1 - β, n ≥ 1\\
1 = 2 \times 1 + γ, n ≥ 1</script><p>于是得到满足这些方程的值$（α，β，γ）= （1，-1，-1）$， 将给出 $A(n) - B(n) - C(n) = f(n) = 1$。类似的，<br>也可以代入 $f(n) = n$ 也能得到为一个 $（α，β，γ） = （1,0,1）$，于是有 $A(n) + C(n) = n$。<br>这样一般递归式对每个 $n$ 值都唯一的定义了 $f(n)$。</p>
<p>现在，我们证明了在一般情况解该一般递归式时，所得到的解中函数 $A(n)、B(n)、C(n)$ 满足方程：</p>
<script type="math/tex; mode=display">
A(n) = 2^m ; 当 n = 2^m + l 且 0 ≤ l < 2m\\
A(n) - B(n) - C(n) = 1 \\
A(n) + C(n) = n</script><p>于是解得</p>
<script type="math/tex; mode=display">
C(n) = n - A(n) = l\\
B(n) = A(n) - 1 - C(n) = 2m - 1 - l</script><p>这就证明了猜想</p>
<script type="math/tex; mode=display">
A(n) = 2^m \\
B(n) = 2^{m - 1} - l \\
C(n) = l</script><p>这一解题方法称为<strong>成套方法</strong>。成套方法的一般步骤是：寻求一组已知其解的通用参数，然后将特殊情况组合起来得到一般的情形，<br>有多少个独立的参数就需要多少个独立的特解。</p>
<h3 id="解的推广"><a href="#解的推广" class="headerlink" title="解的推广"></a>解的推广</h3><p>上文以及证明了对于约瑟夫问题，可以用二进制表示巧妙的解决，那么对于推广的约瑟夫问题是否也存在相应的奇妙解法呢？<br>令 $β_0 = β，β_1 = γ$，推广的递归式就可以改写成：</p>
<script type="math/tex; mode=display">
f(1) = α \\
f(2n + j) = 2f(n) + β_j   ( j = 0,1 ; n ≥ 1)</script><p>这个递归式按照二进制展开就是</p>
<script type="math/tex; mode=display">
f((b_m b_{m-1} ... b_1 b_0)_2) = 2f((b_m b_{m-1} ... b_1)_2)+ β_{b_0} \\
= 4f((b_m b_{m-1} ... b_2)_2)+ 2β_{b_1} + β_{b_0} \\
...\\
= 2^mf((b_m)_2)+2^{m-1}β_{b_{m-1}}+· · ·+2β_{b_1} + β_{b_0}\\
= 2^mα+2^{m-1}β_{b_{m-1}}+· · ·+2β_{b_1} + β_{b_0}</script><p>如果解除二进制表示，允许使用任何数字，而不仅仅是0和1，则有</p>
<script type="math/tex; mode=display">
f((b_m b_{m-1} ... b_1 b_0)_2) = (αβ_{b_{m-1}}β_{b_{m-2}}· · ·β_{b_1}β_{b_0})_2</script><p>例如，当n = 100 = (1100100)2，原来的约瑟夫问题中 α = 1, β = -1, γ = 1，于是有</p>
<p><img src="http://static.zybuluo.com/guoxs/lbw6uakrly9c4xzudahgnup1/6.png" alt="6.png-9.2kB"></p>
<p>由于在n的二进制表示中每一块二进制数字(100…00)2 都被变换成</p>
<script type="math/tex; mode=display">
(1-1...-1-1)_2 = (0 0 ... 0 1)_2</script><p>因而这就推出了循环移位的性质。<br>所以，改变表示法可以给出一般递归式更紧凑的解。<br>如果再进一步推广，对于更一般的递归式</p>
<script type="math/tex; mode=display">
f(j) = α_j ； 1 ≤ j < d\\
f(dn + j) = cf(n) + β_j ；  0 ≤ j < d ， n ≥ 1,</script><p>这里从基数为 d 的数着手，而产生的值用基数 c 来表示，它有变动基数的解：</p>
<script type="math/tex; mode=display">
f((b_m b_{m-1} ... b_1 b_0)_d) = (αβ_{b_{m-1}}β_{b_{m-2}}· · ·β_{b_1}β_{b_0})_c</script><p>这就是对该类递归式地通解。</p>
<h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>① 改变进制看问题有时候会收获奇效。我们总是习惯于十进制，而现实中很多问题在十进制下很难看出规律，这个时候不妨转换一下进制，说不定规律会脱颖而出。<br>② 从一个普通的问题到一类问题，这是问题的抽象。对于解决抽象问题，它涉及到的方法一般都源于它的某一个具体问题。而从具体问题上升到抽象问题，然后寻找这类问题的通解，这往往能够揭示问题的本源。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
